{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js"],"sourcesContent":["/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\n\"production\" !== process.env.NODE_ENV &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n        case REACT_ACTIVITY_TYPE:\n          return \"Activity\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_PORTAL_TYPE:\n            return \"Portal\";\n          case REACT_CONTEXT_TYPE:\n            return (type.displayName || \"Context\") + \".Provider\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function getTaskName(type) {\n      if (type === REACT_FRAGMENT_TYPE) return \"<>\";\n      if (\n        \"object\" === typeof type &&\n        null !== type &&\n        type.$$typeof === REACT_LAZY_TYPE\n      )\n        return \"<...>\";\n      try {\n        var name = getComponentNameFromType(type);\n        return name ? \"<\" + name + \">\" : \"<...>\";\n      } catch (x) {\n        return \"<...>\";\n      }\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function UnknownOwner() {\n      return Error(\"react-stack-top-frame\");\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(\n      type,\n      key,\n      self,\n      source,\n      owner,\n      props,\n      debugStack,\n      debugTask\n    ) {\n      self = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== self ? self : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.defineProperty(type, \"_debugStack\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugStack\n      });\n      Object.defineProperty(type, \"_debugTask\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugTask\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      debugStack,\n      debugTask\n    ) {\n      var children = config.children;\n      if (void 0 !== children)\n        if (isStaticChildren)\n          if (isArrayImpl(children)) {\n            for (\n              isStaticChildren = 0;\n              isStaticChildren < children.length;\n              isStaticChildren++\n            )\n              validateChildKeys(children[isStaticChildren]);\n            Object.freeze && Object.freeze(children);\n          } else\n            console.error(\n              \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n            );\n        else validateChildKeys(children);\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(\n        type,\n        children,\n        self,\n        source,\n        getOwner(),\n        maybeKey,\n        debugStack,\n        debugTask\n      );\n    }\n    function validateChildKeys(node) {\n      \"object\" === typeof node &&\n        null !== node &&\n        node.$$typeof === REACT_ELEMENT_TYPE &&\n        node._store &&\n        (node._store.validated = 1);\n    }\n    var React = require(\"next/dist/compiled/react\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n    Symbol.for(\"react.provider\");\n    var REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"),\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      isArrayImpl = Array.isArray,\n      createTask = console.createTask\n        ? console.createTask\n        : function () {\n            return null;\n          };\n    React = {\n      \"react-stack-bottom-frame\": function (callStackForError) {\n        return callStackForError();\n      }\n    };\n    var specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var unknownOwnerDebugStack = React[\"react-stack-bottom-frame\"].bind(\n      React,\n      UnknownOwner\n    )();\n    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n    var didWarnAboutKeySpread = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = function (\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      var trackActualOwner =\n        1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;\n      return jsxDEVImpl(\n        type,\n        config,\n        maybeKey,\n        isStaticChildren,\n        source,\n        self,\n        trackActualOwner\n          ? Error(\"react-stack-top-frame\")\n          : unknownOwnerDebugStack,\n        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask\n      );\n    };\n  })();\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 214, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/next/dist/compiled/react/jsx-dev-runtime.js"],"sourcesContent":["'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-jsx-dev-runtime.production.js');\n} else {\n  module.exports = require('./cjs/react-jsx-dev-runtime.development.js');\n}\n"],"names":[],"mappings":"AAEI;AAFJ;AAEA,uCAA2C;;AAE3C,OAAO;IACL,OAAO,OAAO;AAChB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 227, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40tanstack/react-query/src/QueryClientProvider.tsx"],"sourcesContent":["'use client'\nimport * as React from 'react'\n\nimport type { QueryClient } from '@tanstack/query-core'\n\nexport const QueryClientContext = React.createContext<QueryClient | undefined>(\n  undefined,\n)\n\nexport const useQueryClient = (queryClient?: QueryClient) => {\n  const client = React.useContext(QueryClientContext)\n\n  if (queryClient) {\n    return queryClient\n  }\n\n  if (!client) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one')\n  }\n\n  return client\n}\n\nexport type QueryClientProviderProps = {\n  client: QueryClient\n  children?: React.ReactNode\n}\n\nexport const QueryClientProvider = ({\n  client,\n  children,\n}: QueryClientProviderProps): React.JSX.Element => {\n  React.useEffect(() => {\n    client.mount()\n    return () => {\n      client.unmount()\n    }\n  }, [client])\n\n  return (\n    <QueryClientContext.Provider value={client}>\n      {children}\n    </QueryClientContext.Provider>\n  )\n}\n"],"names":[],"mappings":";;;;;;AACA,YAAY,WAAW;AAuCnB;;;;AAnCG,IAAM,uLAA2B,gBAAA,EACtC,KAAA;AAGK,IAAM,iBAAiB,CAAC,gBAA8B;IAC3D,MAAM,UAAe,8KAAA,EAAW,kBAAkB;IAElD,IAAI,aAAa;QACf,OAAO;IACT;IAEA,IAAI,CAAC,QAAQ;QACX,MAAM,IAAI,MAAM,wDAAwD;IAC1E;IAEA,OAAO;AACT;AAOO,IAAM,sBAAsB,CAAC,EAClC,MAAA,EACA,QAAA,EACF,KAAmD;sKAC3C,YAAA;yCAAU,MAAM;YACpB,OAAO,KAAA,CAAM;YACb;iDAAO,MAAM;oBACX,OAAO,OAAA,CAAQ;gBACjB;;QACF;wCAAG;QAAC,MAAM;KAAC;IAEX,OACE,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,mBAAmB,QAAA,EAAnB;QAA4B,OAAO;QACjC;IAAA,CACH;AAEJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 275, "column": 0}, "map": {"version":3,"file":"objectSpread2-BvkFp-_Y.mjs","sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/typeof.js","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/toPrimitive.js","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/toPropertyKey.js","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/defineProperty.js","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/objectSpread2.js"],"sourcesContent":["function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return module.exports = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports, _typeof(o);\n}\nmodule.exports = _typeof, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var _typeof = require(\"./typeof.js\")[\"default\"];\nfunction toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nmodule.exports = toPrimitive, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var _typeof = require(\"./typeof.js\")[\"default\"];\nvar toPrimitive = require(\"./toPrimitive.js\");\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nmodule.exports = toPropertyKey, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var toPropertyKey = require(\"./toPropertyKey.js\");\nfunction _defineProperty(e, r, t) {\n  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nmodule.exports = _defineProperty, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var defineProperty = require(\"./defineProperty.js\");\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nmodule.exports = _objectSpread2, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;"],"names":["_typeof","o","_typeof","toPrimitive","toPropertyKey","r"],"mappings":"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","ignoreList":[0,1,2,3,4],"debugId":null}},
    {"offset": {"line": 406, "column": 0}, "map": {"version":3,"file":"observable-UMO3vUa_.mjs","sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/server/src/observable/observable.ts"],"sourcesContent":["import type { Result } from '../unstable-core-do-not-import';\nimport type {\n  Observable,\n  Observer,\n  OperatorFunction,\n  TeardownLogic,\n  UnaryFunction,\n  Unsubscribable,\n} from './types';\n\n/** @public */\nexport type inferObservableValue<TObservable> =\n  TObservable extends Observable<infer TValue, unknown> ? TValue : never;\n\n/** @public */\nexport function isObservable(x: unknown): x is Observable<unknown, unknown> {\n  return typeof x === 'object' && x !== null && 'subscribe' in x;\n}\n\n/** @public */\nexport function observable<TValue, TError = unknown>(\n  subscribe: (observer: Observer<TValue, TError>) => TeardownLogic,\n): Observable<TValue, TError> {\n  const self: Observable<TValue, TError> = {\n    subscribe(observer) {\n      let teardownRef: TeardownLogic | null = null;\n      let isDone = false;\n      let unsubscribed = false;\n      let teardownImmediately = false;\n      function unsubscribe() {\n        if (teardownRef === null) {\n          teardownImmediately = true;\n          return;\n        }\n        if (unsubscribed) {\n          return;\n        }\n        unsubscribed = true;\n\n        if (typeof teardownRef === 'function') {\n          teardownRef();\n        } else if (teardownRef) {\n          teardownRef.unsubscribe();\n        }\n      }\n      teardownRef = subscribe({\n        next(value) {\n          if (isDone) {\n            return;\n          }\n          observer.next?.(value);\n        },\n        error(err) {\n          if (isDone) {\n            return;\n          }\n          isDone = true;\n          observer.error?.(err);\n          unsubscribe();\n        },\n        complete() {\n          if (isDone) {\n            return;\n          }\n          isDone = true;\n          observer.complete?.();\n          unsubscribe();\n        },\n      });\n      if (teardownImmediately) {\n        unsubscribe();\n      }\n      return {\n        unsubscribe,\n      };\n    },\n    pipe(\n      ...operations: OperatorFunction<any, any, any, any>[]\n    ): Observable<any, any> {\n      return operations.reduce(pipeReducer, self);\n    },\n  };\n  return self;\n}\n\nfunction pipeReducer(prev: any, fn: UnaryFunction<any, any>) {\n  return fn(prev);\n}\n\n/** @internal */\nexport function observableToPromise<TValue>(\n  observable: Observable<TValue, unknown>,\n) {\n  const ac = new AbortController();\n  const promise = new Promise<TValue>((resolve, reject) => {\n    let isDone = false;\n    function onDone() {\n      if (isDone) {\n        return;\n      }\n      isDone = true;\n      obs$.unsubscribe();\n    }\n    ac.signal.addEventListener('abort', () => {\n      reject(ac.signal.reason);\n    });\n    const obs$ = observable.subscribe({\n      next(data) {\n        isDone = true;\n        resolve(data);\n        onDone();\n      },\n      error(data) {\n        reject(data);\n      },\n      complete() {\n        ac.abort();\n        onDone();\n      },\n    });\n  });\n  return promise;\n}\n\n/**\n * @internal\n */\nfunction observableToReadableStream<TValue>(\n  observable: Observable<TValue, unknown>,\n  signal: AbortSignal,\n): ReadableStream<Result<TValue>> {\n  let unsub: Unsubscribable | null = null;\n\n  const onAbort = () => {\n    unsub?.unsubscribe();\n    unsub = null;\n    signal.removeEventListener('abort', onAbort);\n  };\n\n  return new ReadableStream<Result<TValue>>({\n    start(controller) {\n      unsub = observable.subscribe({\n        next(data) {\n          controller.enqueue({ ok: true, value: data });\n        },\n        error(error) {\n          controller.enqueue({ ok: false, error });\n          controller.close();\n        },\n        complete() {\n          controller.close();\n        },\n      });\n\n      if (signal.aborted) {\n        onAbort();\n      } else {\n        signal.addEventListener('abort', onAbort, { once: true });\n      }\n    },\n    cancel() {\n      onAbort();\n    },\n  });\n}\n\n/** @internal */\nexport function observableToAsyncIterable<TValue>(\n  observable: Observable<TValue, unknown>,\n  signal: AbortSignal,\n): AsyncIterable<TValue> {\n  const stream = observableToReadableStream(observable, signal);\n\n  const reader = stream.getReader();\n  const iterator: AsyncIterator<TValue> = {\n    async next() {\n      const value = await reader.read();\n      if (value.done) {\n        return {\n          value: undefined,\n          done: true,\n        };\n      }\n      const { value: result } = value;\n      if (!result.ok) {\n        throw result.error;\n      }\n      return {\n        value: result.value,\n        done: false,\n      };\n    },\n    async return() {\n      await reader.cancel();\n      return {\n        value: undefined,\n        done: true,\n      };\n    },\n  };\n  return {\n    [Symbol.asyncIterator]() {\n      return iterator;\n    },\n  };\n}\n"],"names":["x: unknown","subscribe: (observer: Observer<TValue, TError>) => TeardownLogic","self: Observable<TValue, TError>","teardownRef: TeardownLogic | null","prev: any","fn: UnaryFunction<any, any>","observable: Observable<TValue, unknown>","signal: AbortSignal","unsub: Unsubscribable | null","observable","iterator: AsyncIterator<TValue>"],"mappings":";;;;;;;AAeA,SAAgB,aAAaA,CAAAA,EAA+C;IAC1E,OAAA,OAAc,MAAM,YAAY,MAAM,QAAQ,eAAe;AAC9D;eAGD,SAAgB,WACdC,SAAAA,EAC4B;IAC5B,MAAMC,OAAmC;QACvC,WAAU,QAAA,EAAU;YAClB,IAAIC,cAAoC;YACxC,IAAI,SAAS;YACb,IAAI,eAAe;YACnB,IAAI,sBAAsB;YAC1B,SAAS,cAAc;gBACrB,IAAI,gBAAgB,MAAM;oBACxB,sBAAsB;oBACtB;gBACD;gBACD,IAAI,aACF,CAAA;gBAEF,eAAe;gBAEf,IAAA,OAAW,gBAAgB,WACzB,CAAA,aAAa;yBACJ,YACT,CAAA,YAAY,WAAA,EAAa;YAE5B;YACD,cAAc,UAAU;gBACtB,MAAK,KAAA,EAAO;;oBACV,IAAI,OACF,CAAA;oBAEF,CAAA,iBAAA,SAAS,IAAA,MAAA,QAAA,mBAAA,KAAA,KAAT,eAAA,IAAA,CAAA,UAAgB,MAAM;gBACvB;gBACD,OAAM,GAAA,EAAK;;oBACT,IAAI,OACF,CAAA;oBAEF,SAAS;oBACT,CAAA,kBAAA,SAAS,KAAA,MAAA,QAAA,oBAAA,KAAA,KAAT,gBAAA,IAAA,CAAA,UAAiB,IAAI;oBACrB,aAAa;gBACd;gBACD,WAAW;;oBACT,IAAI,OACF,CAAA;oBAEF,SAAS;oBACT,CAAA,qBAAA,SAAS,QAAA,MAAA,QAAA,uBAAA,KAAA,KAAT,mBAAA,IAAA,CAAA,SAAqB;oBACrB,aAAa;gBACd;YACF,EAAC;YACF,IAAI,oBACF,CAAA,aAAa;YAEf,OAAO;gBACL;YACD;QACF;QACD,MACE,GAAG,UAAA,EACmB;YACtB,OAAO,WAAW,MAAA,CAAO,aAAa,KAAK;QAC5C;IACF;IACD,OAAO;AACR;AAED,SAAS,YAAYC,IAAAA,EAAWC,EAAAA,EAA6B;IAC3D,OAAO,GAAG,KAAK;AAChB;iBAGD,SAAgB,oBACdC,YAAAA,EACA;IACA,MAAM,KAAK,IAAI;IACf,MAAM,UAAU,IAAI,QAAgB,CAAC,SAAS,WAAW;QACvD,IAAI,SAAS;QACb,SAAS,SAAS;YAChB,IAAI,OACF,CAAA;YAEF,SAAS;YACT,KAAK,WAAA,EAAa;QACnB;QACD,GAAG,MAAA,CAAO,gBAAA,CAAiB,SAAS,MAAM;YACxC,OAAO,GAAG,MAAA,CAAO,MAAA,CAAO;QACzB,EAAC;QACF,MAAM,OAAO,aAAW,SAAA,CAAU;YAChC,MAAK,IAAA,EAAM;gBACT,SAAS;gBACT,QAAQ,KAAK;gBACb,QAAQ;YACT;YACD,OAAM,IAAA,EAAM;gBACV,OAAO,KAAK;YACb;YACD,WAAW;gBACT,GAAG,KAAA,EAAO;gBACV,QAAQ;YACT;QACF,EAAC;IACH;IACD,OAAO;AACR;;;GAKD,SAAS,2BACPA,YAAAA,EACAC,MAAAA,EACgC;IAChC,IAAIC,QAA+B;IAEnC,MAAM,UAAU,MAAM;QACpB,UAAA,QAAA,UAAA,KAAA,KAAA,MAAO,WAAA,EAAa;QACpB,QAAQ;QACR,OAAO,mBAAA,CAAoB,SAAS,QAAQ;IAC7C;IAED,OAAO,IAAI,eAA+B;QACxC,OAAM,UAAA,EAAY;YAChB,QAAQ,aAAW,SAAA,CAAU;gBAC3B,MAAK,IAAA,EAAM;oBACT,WAAW,OAAA,CAAQ;wBAAE,IAAI;wBAAM,OAAO;oBAAM,EAAC;gBAC9C;gBACD,OAAM,KAAA,EAAO;oBACX,WAAW,OAAA,CAAQ;wBAAE,IAAI;wBAAO;oBAAO,EAAC;oBACxC,WAAW,KAAA,EAAO;gBACnB;gBACD,WAAW;oBACT,WAAW,KAAA,EAAO;gBACnB;YACF,EAAC;YAEF,IAAI,OAAO,OAAA,CACT,CAAA,SAAS;iBAET,OAAO,gBAAA,CAAiB,SAAS,SAAS;gBAAE,MAAM;YAAM,EAAC;QAE5D;QACD,SAAS;YACP,SAAS;QACV;IACF;AACF;iBAGD,SAAgB,0BACdF,YAAAA,EACAC,MAAAA,EACuB;IACvB,MAAM,SAAS,2BAA2BE,cAAY,OAAO;IAE7D,MAAM,SAAS,OAAO,SAAA,EAAW;IACjC,MAAMC,WAAkC;QACtC,MAAM,OAAO;YACX,MAAM,QAAQ,MAAM,OAAO,IAAA,EAAM;YACjC,IAAI,MAAM,IAAA,CACR,CAAA,OAAO;gBACL,OAAA,KAAA;gBACA,MAAM;YACP;YAEH,MAAM,EAAE,OAAO,MAAA,EAAQ,GAAG;YAC1B,IAAA,CAAK,OAAO,EAAA,CACV,CAAA,MAAM,OAAO,KAAA;YAEf,OAAO;gBACL,OAAO,OAAO,KAAA;gBACd,MAAM;YACP;QACF;QACD,MAAM,SAAS;YACb,MAAM,OAAO,MAAA,EAAQ;YACrB,OAAO;gBACL,OAAA,KAAA;gBACA,MAAM;YACP;QACF;IACF;IACD,OAAO;QACL,CAAC,OAAO,aAAA,CAAA,GAAiB;YACvB,OAAO;QACR;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 575, "column": 0}, "map": {"version":3,"file":"splitLink-B7Cuf2c_.mjs","sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/client/src/links/internals/createChain.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/client/src/links/splitLink.ts"],"sourcesContent":["import { observable } from '@trpc/server/observable';\nimport type { AnyRouter } from '@trpc/server/unstable-core-do-not-import';\nimport type {\n  Operation,\n  OperationLink,\n  OperationResultObservable,\n} from '../types';\n\n/** @internal */\nexport function createChain<\n  TRouter extends AnyRouter,\n  TInput = unknown,\n  TOutput = unknown,\n>(opts: {\n  links: OperationLink<TRouter, TInput, TOutput>[];\n  op: Operation<TInput>;\n}): OperationResultObservable<TRouter, TOutput> {\n  return observable((observer) => {\n    function execute(index = 0, op = opts.op) {\n      const next = opts.links[index];\n      if (!next) {\n        throw new Error(\n          'No more links to execute - did you forget to add an ending link?',\n        );\n      }\n      const subscription = next({\n        op,\n        next(nextOp) {\n          const nextObserver = execute(index + 1, nextOp);\n\n          return nextObserver;\n        },\n      });\n      return subscription;\n    }\n\n    const obs$ = execute();\n    return obs$.subscribe(observer);\n  });\n}\n","import { observable } from '@trpc/server/observable';\nimport type { AnyRouter } from '@trpc/server/unstable-core-do-not-import';\nimport { createChain } from './internals/createChain';\nimport type { Operation, TRPCLink } from './types';\n\nfunction asArray<TType>(value: TType | TType[]) {\n  return Array.isArray(value) ? value : [value];\n}\nexport function splitLink<TRouter extends AnyRouter = AnyRouter>(opts: {\n  condition: (op: Operation) => boolean;\n  /**\n   * The link to execute next if the test function returns `true`.\n   */\n  true: TRPCLink<TRouter> | TRPCLink<TRouter>[];\n  /**\n   * The link to execute next if the test function returns `false`.\n   */\n  false: TRPCLink<TRouter> | TRPCLink<TRouter>[];\n}): TRPCLink<TRouter> {\n  return (runtime) => {\n    const yes = asArray(opts.true).map((link) => link(runtime));\n    const no = asArray(opts.false).map((link) => link(runtime));\n    return (props) => {\n      return observable((observer) => {\n        const links = opts.condition(props.op) ? yes : no;\n        return createChain({ op: props.op, links }).subscribe(observer);\n      });\n    };\n  };\n}\n"],"names":["opts: {\n  links: OperationLink<TRouter, TInput, TOutput>[];\n  op: Operation<TInput>;\n}","value: TType | TType[]","opts: {\n  condition: (op: Operation) => boolean;\n  /**\n   * The link to execute next if the test function returns `true`.\n   */\n  true: TRPCLink<TRouter> | TRPCLink<TRouter>[];\n  /**\n   * The link to execute next if the test function returns `false`.\n   */\n  false: TRPCLink<TRouter> | TRPCLink<TRouter>[];\n}"],"mappings":";;;;;;;iBASA,SAAgB,YAIdA,IAAAA,EAG8C;IAC9C,kLAAO,aAAA,EAAW,CAAC,aAAa;QAC9B,SAAS,QAAQ,QAAQ,CAAA,EAAG,KAAK,KAAK,EAAA,EAAI;YACxC,MAAM,OAAO,KAAK,KAAA,CAAM,MAAA;YACxB,IAAA,CAAK,KACH,CAAA,MAAM,IAAI,MACR;YAGJ,MAAM,eAAe,KAAK;gBACxB;gBACA,MAAK,MAAA,EAAQ;oBACX,MAAM,eAAe,QAAQ,QAAQ,GAAG,OAAO;oBAE/C,OAAO;gBACR;YACF,EAAC;YACF,OAAO;QACR;QAED,MAAM,OAAO,SAAS;QACtB,OAAO,KAAK,SAAA,CAAU,SAAS;IAChC,EAAC;AACH;;;AClCD,SAAS,QAAeC,KAAAA,EAAwB;IAC9C,OAAO,MAAM,OAAA,CAAQ,MAAM,GAAG,QAAQ;QAAC,KAAM;KAAA;AAC9C;AACD,SAAgB,UAAiDC,IAAAA,EAU3C;IACpB,OAAO,CAAC,YAAY;QAClB,MAAM,MAAM,QAAQ,KAAK,IAAA,CAAK,CAAC,GAAA,CAAI,CAAC,OAAS,KAAK,QAAQ,CAAC;QAC3D,MAAM,KAAK,QAAQ,KAAK,KAAA,CAAM,CAAC,GAAA,CAAI,CAAC,OAAS,KAAK,QAAQ,CAAC;QAC3D,OAAO,CAAC,UAAU;YAChB,QAAO,uLAAA,EAAW,CAAC,aAAa;gBAC9B,MAAM,QAAQ,KAAK,SAAA,CAAU,MAAM,EAAA,CAAG,GAAG,MAAM;gBAC/C,OAAO,YAAY;oBAAE,IAAI,MAAM,EAAA;oBAAI;gBAAO,EAAC,CAAC,SAAA,CAAU,SAAS;YAChE,EAAC;QACH;IACF;AACF","ignoreList":[0,1],"debugId":null}},
    {"offset": {"line": 630, "column": 0}, "map": {"version":3,"file":"utils-DdbbrDku.mjs","sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/server/src/unstable-core-do-not-import/rpc/codes.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/server/src/unstable-core-do-not-import/utils.ts"],"sourcesContent":["import type { InvertKeyValue, ValueOf } from '../types';\n\n// reference: https://www.jsonrpc.org/specification\n\n/**\n * JSON-RPC 2.0 Error codes\n *\n * `-32000` to `-32099` are reserved for implementation-defined server-errors.\n * For tRPC we're copying the last digits of HTTP 4XX errors.\n */\nexport const TRPC_ERROR_CODES_BY_KEY = {\n  /**\n   * Invalid JSON was received by the server.\n   * An error occurred on the server while parsing the JSON text.\n   */\n  PARSE_ERROR: -32700,\n  /**\n   * The JSON sent is not a valid Request object.\n   */\n  BAD_REQUEST: -32600, // 400\n\n  // Internal JSON-RPC error\n  INTERNAL_SERVER_ERROR: -32603, // 500\n  NOT_IMPLEMENTED: -32603, // 501\n  BAD_GATEWAY: -32603, // 502\n  SERVICE_UNAVAILABLE: -32603, // 503\n  GATEWAY_TIMEOUT: -32603, // 504\n\n  // Implementation specific errors\n  UNAUTHORIZED: -32001, // 401\n  PAYMENT_REQUIRED: -32002, // 402\n  FORBIDDEN: -32003, // 403\n  NOT_FOUND: -32004, // 404\n  METHOD_NOT_SUPPORTED: -32005, // 405\n  TIMEOUT: -32008, // 408\n  CONFLICT: -32009, // 409\n  PRECONDITION_FAILED: -32012, // 412\n  PAYLOAD_TOO_LARGE: -32013, // 413\n  UNSUPPORTED_MEDIA_TYPE: -32015, // 415\n  UNPROCESSABLE_CONTENT: -32022, // 422\n  TOO_MANY_REQUESTS: -32029, // 429\n  CLIENT_CLOSED_REQUEST: -32099, // 499\n} as const;\n\n// pure\nexport const TRPC_ERROR_CODES_BY_NUMBER: InvertKeyValue<\n  typeof TRPC_ERROR_CODES_BY_KEY\n> = {\n  [-32700]: 'PARSE_ERROR',\n  [-32600]: 'BAD_REQUEST',\n  [-32603]: 'INTERNAL_SERVER_ERROR',\n  [-32001]: 'UNAUTHORIZED',\n  [-32002]: 'PAYMENT_REQUIRED',\n  [-32003]: 'FORBIDDEN',\n  [-32004]: 'NOT_FOUND',\n  [-32005]: 'METHOD_NOT_SUPPORTED',\n  [-32008]: 'TIMEOUT',\n  [-32009]: 'CONFLICT',\n  [-32012]: 'PRECONDITION_FAILED',\n  [-32013]: 'PAYLOAD_TOO_LARGE',\n  [-32015]: 'UNSUPPORTED_MEDIA_TYPE',\n  [-32022]: 'UNPROCESSABLE_CONTENT',\n  [-32029]: 'TOO_MANY_REQUESTS',\n  [-32099]: 'CLIENT_CLOSED_REQUEST',\n};\n\nexport type TRPC_ERROR_CODE_NUMBER = ValueOf<typeof TRPC_ERROR_CODES_BY_KEY>;\nexport type TRPC_ERROR_CODE_KEY = keyof typeof TRPC_ERROR_CODES_BY_KEY;\n\n/**\n * tRPC error codes that are considered retryable\n * With out of the box SSE, the client will reconnect when these errors are encountered\n */\nexport const retryableRpcCodes: TRPC_ERROR_CODE_NUMBER[] = [\n  TRPC_ERROR_CODES_BY_KEY.BAD_GATEWAY,\n  TRPC_ERROR_CODES_BY_KEY.SERVICE_UNAVAILABLE,\n  TRPC_ERROR_CODES_BY_KEY.GATEWAY_TIMEOUT,\n  TRPC_ERROR_CODES_BY_KEY.INTERNAL_SERVER_ERROR,\n];\n","/** @internal */\nexport type UnsetMarker = 'unsetMarker' & {\n  __brand: 'unsetMarker';\n};\n\n/**\n * Ensures there are no duplicate keys when building a procedure.\n * @internal\n */\nexport function mergeWithoutOverrides<TType extends Record<string, unknown>>(\n  obj1: TType,\n  ...objs: Partial<TType>[]\n): TType {\n  const newObj: TType = Object.assign(Object.create(null), obj1);\n\n  for (const overrides of objs) {\n    for (const key in overrides) {\n      if (key in newObj && newObj[key] !== overrides[key]) {\n        throw new Error(`Duplicate key ${key}`);\n      }\n      newObj[key as keyof TType] = overrides[key] as TType[keyof TType];\n    }\n  }\n  return newObj;\n}\n\n/**\n * Check that value is object\n * @internal\n */\nexport function isObject(value: unknown): value is Record<string, unknown> {\n  return !!value && !Array.isArray(value) && typeof value === 'object';\n}\n\ntype AnyFn = ((...args: any[]) => unknown) & Record<keyof any, unknown>;\nexport function isFunction(fn: unknown): fn is AnyFn {\n  return typeof fn === 'function';\n}\n\n/**\n * Create an object without inheriting anything from `Object.prototype`\n * @internal\n */\nexport function omitPrototype<TObj extends Record<string, unknown>>(\n  obj: TObj,\n): TObj {\n  return Object.assign(Object.create(null), obj);\n}\n\nconst asyncIteratorsSupported =\n  typeof Symbol === 'function' && !!Symbol.asyncIterator;\n\nexport function isAsyncIterable<TValue>(\n  value: unknown,\n): value is AsyncIterable<TValue> {\n  return (\n    asyncIteratorsSupported && isObject(value) && Symbol.asyncIterator in value\n  );\n}\n\n/**\n * Run an IIFE\n */\nexport const run = <TValue>(fn: () => TValue): TValue => fn();\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport function noop(): void {}\n\nexport function identity<T>(it: T): T {\n  return it;\n}\n\n/**\n * Generic runtime assertion function. Throws, if the condition is not `true`.\n *\n * Can be used as a slightly less dangerous variant of type assertions. Code\n * mistakes would be revealed at runtime then (hopefully during testing).\n */\nexport function assert(\n  condition: boolean,\n  msg = 'no additional info',\n): asserts condition {\n  if (!condition) {\n    throw new Error(`AssertionError: ${msg}`);\n  }\n}\n\nexport function sleep(ms = 0): Promise<void> {\n  return new Promise<void>((res) => setTimeout(res, ms));\n}\n\n/**\n * Ponyfill for\n * [`AbortSignal.any`](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/any_static).\n */\nexport function abortSignalsAnyPonyfill(signals: AbortSignal[]): AbortSignal {\n  if (typeof AbortSignal.any === 'function') {\n    return AbortSignal.any(signals);\n  }\n\n  const ac = new AbortController();\n\n  for (const signal of signals) {\n    if (signal.aborted) {\n      trigger();\n      break;\n    }\n    signal.addEventListener('abort', trigger, { once: true });\n  }\n\n  return ac.signal;\n\n  function trigger() {\n    ac.abort();\n    for (const signal of signals) {\n      signal.removeEventListener('abort', trigger);\n    }\n  }\n}\n"],"names":["TRPC_ERROR_CODES_BY_NUMBER: InvertKeyValue<\n  typeof TRPC_ERROR_CODES_BY_KEY\n>","retryableRpcCodes: TRPC_ERROR_CODE_NUMBER[]","obj1: TType","newObj: TType","value: unknown","fn: unknown","obj: TObj","fn: () => TValue","it: T","condition: boolean","signals: AbortSignal[]"],"mappings":"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","ignoreList":[0,1],"debugId":null}},
    {"offset": {"line": 781, "column": 0}, "map": {"version":3,"file":"TRPCClientError-CjKyS10w.mjs","sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/client/src/TRPCClientError.ts"],"sourcesContent":["import type {\n  inferClientTypes,\n  InferrableClientTypes,\n  Maybe,\n  TRPCErrorResponse,\n} from '@trpc/server/unstable-core-do-not-import';\nimport {\n  isObject,\n  type DefaultErrorShape,\n} from '@trpc/server/unstable-core-do-not-import';\n\ntype inferErrorShape<TInferrable extends InferrableClientTypes> =\n  inferClientTypes<TInferrable>['errorShape'];\nexport interface TRPCClientErrorBase<TShape extends DefaultErrorShape> {\n  readonly message: string;\n  readonly shape: Maybe<TShape>;\n  readonly data: Maybe<TShape['data']>;\n}\nexport type TRPCClientErrorLike<TInferrable extends InferrableClientTypes> =\n  TRPCClientErrorBase<inferErrorShape<TInferrable>>;\n\nexport function isTRPCClientError<TInferrable extends InferrableClientTypes>(\n  cause: unknown,\n): cause is TRPCClientError<TInferrable> {\n  return cause instanceof TRPCClientError;\n}\n\nfunction isTRPCErrorResponse(obj: unknown): obj is TRPCErrorResponse<any> {\n  return (\n    isObject(obj) &&\n    isObject(obj['error']) &&\n    typeof obj['error']['code'] === 'number' &&\n    typeof obj['error']['message'] === 'string'\n  );\n}\n\nfunction getMessageFromUnknownError(err: unknown, fallback: string): string {\n  if (typeof err === 'string') {\n    return err;\n  }\n  if (isObject(err) && typeof err['message'] === 'string') {\n    return err['message'];\n  }\n  return fallback;\n}\n\nexport class TRPCClientError<TRouterOrProcedure extends InferrableClientTypes>\n  extends Error\n  implements TRPCClientErrorBase<inferErrorShape<TRouterOrProcedure>>\n{\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore override doesn't work in all environments due to \"This member cannot have an 'override' modifier because it is not declared in the base class 'Error'\"\n  public override readonly cause;\n  public readonly shape: Maybe<inferErrorShape<TRouterOrProcedure>>;\n  public readonly data: Maybe<inferErrorShape<TRouterOrProcedure>['data']>;\n\n  /**\n   * Additional meta data about the error\n   * In the case of HTTP-errors, we'll have `response` and potentially `responseJSON` here\n   */\n  public meta;\n\n  constructor(\n    message: string,\n    opts?: {\n      result?: Maybe<TRPCErrorResponse<inferErrorShape<TRouterOrProcedure>>>;\n      cause?: Error;\n      meta?: Record<string, unknown>;\n    },\n  ) {\n    const cause = opts?.cause;\n\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore https://github.com/tc39/proposal-error-cause\n    super(message, { cause });\n\n    this.meta = opts?.meta;\n\n    this.cause = cause;\n    this.shape = opts?.result?.error;\n    this.data = opts?.result?.error.data;\n    this.name = 'TRPCClientError';\n\n    Object.setPrototypeOf(this, TRPCClientError.prototype);\n  }\n\n  public static from<TRouterOrProcedure extends InferrableClientTypes>(\n    _cause: Error | TRPCErrorResponse<any> | object,\n    opts: { meta?: Record<string, unknown> } = {},\n  ): TRPCClientError<TRouterOrProcedure> {\n    const cause = _cause as unknown;\n\n    if (isTRPCClientError(cause)) {\n      if (opts.meta) {\n        // Decorate with meta error data\n        cause.meta = {\n          ...cause.meta,\n          ...opts.meta,\n        };\n      }\n      return cause;\n    }\n    if (isTRPCErrorResponse(cause)) {\n      return new TRPCClientError(cause.error.message, {\n        ...opts,\n        result: cause,\n      });\n    }\n    return new TRPCClientError(\n      getMessageFromUnknownError(cause, 'Unknown error'),\n      {\n        ...opts,\n        cause: cause as any,\n      },\n    );\n  }\n}\n"],"names":["cause: unknown","obj: unknown","err: unknown","fallback: string","message: string","opts?: {\n      result?: Maybe<TRPCErrorResponse<inferErrorShape<TRouterOrProcedure>>>;\n      cause?: Error;\n      meta?: Record<string, unknown>;\n    }","_cause: Error | TRPCErrorResponse<any> | object","opts: { meta?: Record<string, unknown> }"],"mappings":";;;;;;;;;;;AAqBA,SAAgB,kBACdA,KAAAA,EACuC;IACvC,OAAO,iBAAiB;AACzB;AAED,SAAS,oBAAoBC,GAAAA,EAA6C;IACxE,6KACE,WAAA,EAAS,IAAI,QACb,6KAAA,EAAS,GAAA,CAAI,QAAA,CAAS,IAAA,OACf,GAAA,CAAI,QAAA,CAAS,OAAA,KAAY,YAAA,OACzB,GAAA,CAAI,QAAA,CAAS,UAAA,KAAe;AAEtC;AAED,SAAS,2BAA2BC,GAAAA,EAAcC,QAAAA,EAA0B;IAC1E,IAAA,OAAW,QAAQ,SACjB,CAAA,OAAO;IAET,0KAAI,WAAA,EAAS,IAAI,IAAA,OAAW,GAAA,CAAI,UAAA,KAAe,SAC7C,CAAA,OAAO,GAAA,CAAI,UAAA;IAEb,OAAO;AACR;AAED,IAAa,kBAAb,MAAa,wBACH,MAEV;IAaE,YACEC,OAAAA,EACAC,IAAAA,CAKA;;QACA,MAAM,QAAA,SAAA,QAAA,SAAA,KAAA,IAAA,KAAA,IAAQ,KAAM,KAAA;QAIpB,KAAA,CAAM,SAAS;YAAE;QAAO,EAAC;2CA2C1B,IAAA,EAjEwB,SAAA,KAAA;2CAiEvB,IAAA,EAhEc,SAAA,KAAA;2CAgEb,IAAA,EA/Da,QAAA,KAAA;2CA+DZ,IAAA,EAzDG,QAAA,KAAA;QAgBL,IAAA,CAAK,IAAA,GAAA,SAAA,QAAA,SAAA,KAAA,IAAA,KAAA,IAAO,KAAM,IAAA;QAElB,IAAA,CAAK,KAAA,GAAQ;QACb,IAAA,CAAK,KAAA,GAAA,SAAA,QAAA,SAAA,KAAA,KAAA,CAAA,eAAQ,KAAM,MAAA,MAAA,QAAA,iBAAA,KAAA,IAAA,KAAA,IAAA,aAAQ,KAAA;QAC3B,IAAA,CAAK,IAAA,GAAA,SAAA,QAAA,SAAA,KAAA,KAAA,CAAA,gBAAO,KAAM,MAAA,MAAA,QAAA,kBAAA,KAAA,IAAA,KAAA,IAAA,cAAQ,KAAA,CAAM,IAAA;QAChC,IAAA,CAAK,IAAA,GAAO;QAEZ,OAAO,cAAA,CAAe,IAAA,EAAM,gBAAgB,SAAA,CAAU;IACvD;IAED,OAAc,KACZC,MAAAA,EACAC,OAA2C,CAAE,CAAA,EACR;QACrC,MAAM,QAAQ;QAEd,IAAI,kBAAkB,MAAM,EAAE;YAC5B,IAAI,KAAK,IAAA,CAEP,CAAA,MAAM,IAAA,GAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GACD,MAAM,IAAA,GACN,KAAK,IAAA;YAGZ,OAAO;QACR;QACD,IAAI,oBAAoB,MAAM,CAC5B,CAAA,OAAO,IAAI,gBAAgB,MAAM,KAAA,CAAM,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAClC,OAAA,CAAA,GAAA;YACH,QAAQ;QAAA;QAGZ,OAAO,IAAI,gBACT,2BAA2B,OAAO,gBAAgB,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAE7C,OAAA,CAAA,GAAA;YACI;QAAA;IAGZ;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 843, "column": 0}, "map": {"version":3,"file":"unstable-internals-Bg7n9BBj.mjs","sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/client/src/internals/transformer.ts"],"sourcesContent":["import type {\n  AnyClientTypes,\n  CombinedDataTransformer,\n  DataTransformerOptions,\n  TypeError,\n} from '@trpc/server/unstable-core-do-not-import';\n\n/**\n * @internal\n */\nexport type CoercedTransformerParameters = {\n  transformer?: DataTransformerOptions;\n};\n\ntype TransformerOptionYes = {\n  /**\n   * Data transformer\n   *\n   * You must use the same transformer on the backend and frontend\n   * @see https://trpc.io/docs/v11/data-transformers\n   **/\n  transformer: DataTransformerOptions;\n};\ntype TransformerOptionNo = {\n  /**\n   * Data transformer\n   *\n   * You must use the same transformer on the backend and frontend\n   * @see https://trpc.io/docs/v11/data-transformers\n   **/\n  transformer?: TypeError<'You must define a transformer on your your `initTRPC`-object first'>;\n};\n\n/**\n * @internal\n */\nexport type TransformerOptions<\n  TRoot extends Pick<AnyClientTypes, 'transformer'>,\n> = TRoot['transformer'] extends true\n  ? TransformerOptionYes\n  : TransformerOptionNo;\n/**\n * @internal\n */\n\n/**\n * @internal\n */\nexport function getTransformer(\n  transformer:\n    | TransformerOptions<{ transformer: false }>['transformer']\n    | TransformerOptions<{ transformer: true }>['transformer']\n    | undefined,\n): CombinedDataTransformer {\n  const _transformer =\n    transformer as CoercedTransformerParameters['transformer'];\n  if (!_transformer) {\n    return {\n      input: {\n        serialize: (data) => data,\n        deserialize: (data) => data,\n      },\n      output: {\n        serialize: (data) => data,\n        deserialize: (data) => data,\n      },\n    };\n  }\n  if ('input' in _transformer) {\n    return _transformer;\n  }\n  return {\n    input: _transformer,\n    output: _transformer,\n  };\n}\n"],"names":["transformer:\n    | TransformerOptions<{ transformer: false }>['transformer']\n    | TransformerOptions<{ transformer: true }>['transformer']\n    | undefined"],"mappings":";;;;;;;;AAgDA,SAAgB,eACdA,WAAAA,EAIyB;IACzB,MAAM,eACJ;IACF,IAAA,CAAK,aACH,CAAA,OAAO;QACL,OAAO;YACL,WAAW,CAAC,OAAS;YACrB,aAAa,CAAC,OAAS;QACxB;QACD,QAAQ;YACN,WAAW,CAAC,OAAS;YACrB,aAAa,CAAC,OAAS;QACxB;IACF;IAEH,IAAI,WAAW,aACb,CAAA,OAAO;IAET,OAAO;QACL,OAAO;QACP,QAAQ;IACT;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 877, "column": 0}, "map": {"version":3,"file":"httpUtils-Bkv1johT.mjs","sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/client/src/getFetch.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/client/src/links/internals/httpUtils.ts"],"sourcesContent":["import type { FetchEsque, NativeFetchEsque } from './internals/types';\n\ntype AnyFn = (...args: any[]) => unknown;\n\nconst isFunction = (fn: unknown): fn is AnyFn => typeof fn === 'function';\n\nexport function getFetch(\n  customFetchImpl?: FetchEsque | NativeFetchEsque,\n): FetchEsque {\n  if (customFetchImpl) {\n    return customFetchImpl as FetchEsque;\n  }\n\n  if (typeof window !== 'undefined' && isFunction(window.fetch)) {\n    return window.fetch as FetchEsque;\n  }\n\n  if (typeof globalThis !== 'undefined' && isFunction(globalThis.fetch)) {\n    return globalThis.fetch as FetchEsque;\n  }\n\n  throw new Error('No fetch implementation found');\n}\n","import type {\n  AnyClientTypes,\n  CombinedDataTransformer,\n  Maybe,\n  ProcedureType,\n  TRPCAcceptHeader,\n  TRPCResponse,\n} from '@trpc/server/unstable-core-do-not-import';\nimport { getFetch } from '../../getFetch';\nimport type {\n  FetchEsque,\n  RequestInitEsque,\n  ResponseEsque,\n} from '../../internals/types';\nimport type { TransformerOptions } from '../../unstable-internals';\nimport { getTransformer } from '../../unstable-internals';\nimport type { HTTPHeaders } from '../types';\n\n/**\n * @internal\n */\nexport type HTTPLinkBaseOptions<\n  TRoot extends Pick<AnyClientTypes, 'transformer'>,\n> = {\n  url: string | URL;\n  /**\n   * Add ponyfill for fetch\n   */\n  fetch?: FetchEsque;\n  /**\n   * Send all requests `as POST`s requests regardless of the procedure type\n   * The HTTP handler must separately allow overriding the method. See:\n   * @see https://trpc.io/docs/rpc\n   */\n  methodOverride?: 'POST';\n} & TransformerOptions<TRoot>;\n\nexport interface ResolvedHTTPLinkOptions {\n  url: string;\n  fetch?: FetchEsque;\n  transformer: CombinedDataTransformer;\n  methodOverride?: 'POST';\n}\n\nexport function resolveHTTPLinkOptions(\n  opts: HTTPLinkBaseOptions<AnyClientTypes>,\n): ResolvedHTTPLinkOptions {\n  return {\n    url: opts.url.toString(),\n    fetch: opts.fetch,\n    transformer: getTransformer(opts.transformer),\n    methodOverride: opts.methodOverride,\n  };\n}\n\n// https://github.com/trpc/trpc/pull/669\nfunction arrayToDict(array: unknown[]) {\n  const dict: Record<number, unknown> = {};\n  for (let index = 0; index < array.length; index++) {\n    const element = array[index];\n    dict[index] = element;\n  }\n  return dict;\n}\n\nconst METHOD = {\n  query: 'GET',\n  mutation: 'POST',\n  subscription: 'PATCH',\n} as const;\n\nexport interface HTTPResult {\n  json: TRPCResponse;\n  meta: {\n    response: ResponseEsque;\n    responseJSON?: unknown;\n  };\n}\n\ntype GetInputOptions = {\n  transformer: CombinedDataTransformer;\n} & ({ input: unknown } | { inputs: unknown[] });\n\nexport function getInput(opts: GetInputOptions) {\n  return 'input' in opts\n    ? opts.transformer.input.serialize(opts.input)\n    : arrayToDict(\n        opts.inputs.map((_input) => opts.transformer.input.serialize(_input)),\n      );\n}\n\nexport type HTTPBaseRequestOptions = GetInputOptions &\n  ResolvedHTTPLinkOptions & {\n    type: ProcedureType;\n    path: string;\n    signal: Maybe<AbortSignal>;\n  };\n\ntype GetUrl = (opts: HTTPBaseRequestOptions) => string;\ntype GetBody = (opts: HTTPBaseRequestOptions) => RequestInitEsque['body'];\n\nexport type ContentOptions = {\n  trpcAcceptHeader?: TRPCAcceptHeader;\n  contentTypeHeader?: string;\n  getUrl: GetUrl;\n  getBody: GetBody;\n};\n\nexport const getUrl: GetUrl = (opts) => {\n  const parts = opts.url.split('?') as [string, string?];\n  const base = parts[0].replace(/\\/$/, ''); // Remove any trailing slashes\n\n  let url = base + '/' + opts.path;\n  const queryParts: string[] = [];\n\n  if (parts[1]) {\n    queryParts.push(parts[1]);\n  }\n  if ('inputs' in opts) {\n    queryParts.push('batch=1');\n  }\n  if (opts.type === 'query' || opts.type === 'subscription') {\n    const input = getInput(opts);\n    if (input !== undefined && opts.methodOverride !== 'POST') {\n      queryParts.push(`input=${encodeURIComponent(JSON.stringify(input))}`);\n    }\n  }\n  if (queryParts.length) {\n    url += '?' + queryParts.join('&');\n  }\n  return url;\n};\n\nexport const getBody: GetBody = (opts) => {\n  if (opts.type === 'query' && opts.methodOverride !== 'POST') {\n    return undefined;\n  }\n  const input = getInput(opts);\n  return input !== undefined ? JSON.stringify(input) : undefined;\n};\n\nexport type Requester = (\n  opts: HTTPBaseRequestOptions & {\n    headers: () => HTTPHeaders | Promise<HTTPHeaders>;\n  },\n) => Promise<HTTPResult>;\n\nexport const jsonHttpRequester: Requester = (opts) => {\n  return httpRequest({\n    ...opts,\n    contentTypeHeader: 'application/json',\n    getUrl,\n    getBody,\n  });\n};\n\n/**\n * Polyfill for DOMException with AbortError name\n */\nclass AbortError extends Error {\n  constructor() {\n    const name = 'AbortError';\n    super(name);\n    this.name = name;\n    this.message = name;\n  }\n}\n\nexport type HTTPRequestOptions = ContentOptions &\n  HTTPBaseRequestOptions & {\n    headers: () => HTTPHeaders | Promise<HTTPHeaders>;\n  };\n\n/**\n * Polyfill for `signal.throwIfAborted()`\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/throwIfAborted\n */\nconst throwIfAborted = (signal: Maybe<AbortSignal>) => {\n  if (!signal?.aborted) {\n    return;\n  }\n  // If available, use the native implementation\n  signal.throwIfAborted?.();\n\n  // If we have `DOMException`, use it\n  if (typeof DOMException !== 'undefined') {\n    throw new DOMException('AbortError', 'AbortError');\n  }\n\n  // Otherwise, use our own implementation\n  throw new AbortError();\n};\n\nexport async function fetchHTTPResponse(opts: HTTPRequestOptions) {\n  throwIfAborted(opts.signal);\n\n  const url = opts.getUrl(opts);\n  const body = opts.getBody(opts);\n  const { type } = opts;\n  const resolvedHeaders = await (async () => {\n    const heads = await opts.headers();\n    if (Symbol.iterator in heads) {\n      return Object.fromEntries(heads);\n    }\n    return heads;\n  })();\n  const headers = {\n    ...(opts.contentTypeHeader\n      ? { 'content-type': opts.contentTypeHeader }\n      : {}),\n    ...(opts.trpcAcceptHeader\n      ? { 'trpc-accept': opts.trpcAcceptHeader }\n      : undefined),\n    ...resolvedHeaders,\n  };\n\n  return getFetch(opts.fetch)(url, {\n    method: opts.methodOverride ?? METHOD[type],\n    signal: opts.signal,\n    body,\n    headers,\n  });\n}\n\nexport async function httpRequest(\n  opts: HTTPRequestOptions,\n): Promise<HTTPResult> {\n  const meta = {} as HTTPResult['meta'];\n\n  const res = await fetchHTTPResponse(opts);\n  meta.response = res;\n\n  const json = await res.json();\n\n  meta.responseJSON = json;\n\n  return {\n    json: json as TRPCResponse,\n    meta,\n  };\n}\n"],"names":["fn: unknown","customFetchImpl?: FetchEsque | NativeFetchEsque","opts: HTTPLinkBaseOptions<AnyClientTypes>","array: unknown[]","dict: Record<number, unknown>","opts: GetInputOptions","getUrl: GetUrl","queryParts: string[]","getBody: GetBody","jsonHttpRequester: Requester","signal: Maybe<AbortSignal>","opts: HTTPRequestOptions"],"mappings":"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","ignoreList":[0,1],"debugId":null}},
    {"offset": {"line": 1014, "column": 0}, "map": {"version":3,"file":"getErrorShape-Uhlrl4Bk.mjs","sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/server/src/unstable-core-do-not-import/createProxy.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/server/src/unstable-core-do-not-import/http/getHTTPStatusCode.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/typeof.js","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/toPrimitive.js","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/toPropertyKey.js","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/defineProperty.js","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/objectSpread2.js","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/server/src/unstable-core-do-not-import/error/getErrorShape.ts"],"sourcesContent":["interface ProxyCallbackOptions {\n  path: readonly string[];\n  args: readonly unknown[];\n}\ntype ProxyCallback = (opts: ProxyCallbackOptions) => unknown;\n\nconst noop = () => {\n  // noop\n};\n\nconst freezeIfAvailable = (obj: object) => {\n  if (Object.freeze) {\n    Object.freeze(obj);\n  }\n};\n\nfunction createInnerProxy(\n  callback: ProxyCallback,\n  path: readonly string[],\n  memo: Record<string, unknown>,\n) {\n  const cacheKey = path.join('.');\n\n  memo[cacheKey] ??= new Proxy(noop, {\n    get(_obj, key) {\n      if (typeof key !== 'string' || key === 'then') {\n        // special case for if the proxy is accidentally treated\n        // like a PromiseLike (like in `Promise.resolve(proxy)`)\n        return undefined;\n      }\n      return createInnerProxy(callback, [...path, key], memo);\n    },\n    apply(_1, _2, args) {\n      const lastOfPath = path[path.length - 1];\n\n      let opts = { args, path };\n      // special handling for e.g. `trpc.hello.call(this, 'there')` and `trpc.hello.apply(this, ['there'])\n      if (lastOfPath === 'call') {\n        opts = {\n          args: args.length >= 2 ? [args[1]] : [],\n          path: path.slice(0, -1),\n        };\n      } else if (lastOfPath === 'apply') {\n        opts = {\n          args: args.length >= 2 ? args[1] : [],\n          path: path.slice(0, -1),\n        };\n      }\n      freezeIfAvailable(opts.args);\n      freezeIfAvailable(opts.path);\n      return callback(opts);\n    },\n  });\n\n  return memo[cacheKey];\n}\n\n/**\n * Creates a proxy that calls the callback with the path and arguments\n *\n * @internal\n */\nexport const createRecursiveProxy = <TFaux = unknown>(\n  callback: ProxyCallback,\n): TFaux => createInnerProxy(callback, [], Object.create(null)) as TFaux;\n\n/**\n * Used in place of `new Proxy` where each handler will map 1 level deep to another value.\n *\n * @internal\n */\nexport const createFlatProxy = <TFaux>(\n  callback: (path: keyof TFaux) => any,\n): TFaux => {\n  return new Proxy(noop, {\n    get(_obj, name) {\n      if (name === 'then') {\n        // special case for if the proxy is accidentally treated\n        // like a PromiseLike (like in `Promise.resolve(proxy)`)\n        return undefined;\n      }\n      return callback(name as any);\n    },\n  }) as TFaux;\n};\n","import type { TRPCError } from '../error/TRPCError';\nimport type { TRPC_ERROR_CODES_BY_KEY, TRPCResponse } from '../rpc';\nimport { TRPC_ERROR_CODES_BY_NUMBER } from '../rpc';\nimport type { InvertKeyValue, ValueOf } from '../types';\nimport { isObject } from '../utils';\n\nexport const JSONRPC2_TO_HTTP_CODE: Record<\n  keyof typeof TRPC_ERROR_CODES_BY_KEY,\n  number\n> = {\n  PARSE_ERROR: 400,\n  BAD_REQUEST: 400,\n  UNAUTHORIZED: 401,\n  PAYMENT_REQUIRED: 402,\n  FORBIDDEN: 403,\n  NOT_FOUND: 404,\n  METHOD_NOT_SUPPORTED: 405,\n  TIMEOUT: 408,\n  CONFLICT: 409,\n  PRECONDITION_FAILED: 412,\n  PAYLOAD_TOO_LARGE: 413,\n  UNSUPPORTED_MEDIA_TYPE: 415,\n  UNPROCESSABLE_CONTENT: 422,\n  TOO_MANY_REQUESTS: 429,\n  CLIENT_CLOSED_REQUEST: 499,\n  INTERNAL_SERVER_ERROR: 500,\n  NOT_IMPLEMENTED: 501,\n  BAD_GATEWAY: 502,\n  SERVICE_UNAVAILABLE: 503,\n  GATEWAY_TIMEOUT: 504,\n};\n\nexport const HTTP_CODE_TO_JSONRPC2: InvertKeyValue<\n  typeof JSONRPC2_TO_HTTP_CODE\n> = {\n  400: 'BAD_REQUEST',\n  401: 'UNAUTHORIZED',\n  402: 'PAYMENT_REQUIRED',\n  403: 'FORBIDDEN',\n  404: 'NOT_FOUND',\n  405: 'METHOD_NOT_SUPPORTED',\n  408: 'TIMEOUT',\n  409: 'CONFLICT',\n  412: 'PRECONDITION_FAILED',\n  413: 'PAYLOAD_TOO_LARGE',\n  415: 'UNSUPPORTED_MEDIA_TYPE',\n  422: 'UNPROCESSABLE_CONTENT',\n  429: 'TOO_MANY_REQUESTS',\n  499: 'CLIENT_CLOSED_REQUEST',\n  500: 'INTERNAL_SERVER_ERROR',\n  501: 'NOT_IMPLEMENTED',\n  502: 'BAD_GATEWAY',\n  503: 'SERVICE_UNAVAILABLE',\n  504: 'GATEWAY_TIMEOUT',\n} as const;\n\nexport function getStatusCodeFromKey(\n  code: keyof typeof TRPC_ERROR_CODES_BY_KEY,\n) {\n  return JSONRPC2_TO_HTTP_CODE[code] ?? 500;\n}\n\nexport function getStatusKeyFromCode(\n  code: keyof typeof HTTP_CODE_TO_JSONRPC2,\n): ValueOf<typeof HTTP_CODE_TO_JSONRPC2> {\n  return HTTP_CODE_TO_JSONRPC2[code] ?? 'INTERNAL_SERVER_ERROR';\n}\n\nexport function getHTTPStatusCode(json: TRPCResponse | TRPCResponse[]) {\n  const arr = Array.isArray(json) ? json : [json];\n  const httpStatuses = new Set<number>(\n    arr.map((res) => {\n      if ('error' in res && isObject(res.error.data)) {\n        if (typeof res.error.data?.['httpStatus'] === 'number') {\n          return res.error.data['httpStatus'];\n        }\n        const code = TRPC_ERROR_CODES_BY_NUMBER[res.error.code];\n        return getStatusCodeFromKey(code);\n      }\n      return 200;\n    }),\n  );\n\n  if (httpStatuses.size !== 1) {\n    return 207;\n  }\n\n  const httpStatus = httpStatuses.values().next().value;\n\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  return httpStatus!;\n}\n\nexport function getHTTPStatusCodeFromError(error: TRPCError) {\n  return getStatusCodeFromKey(error.code);\n}\n","function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return module.exports = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports, _typeof(o);\n}\nmodule.exports = _typeof, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var _typeof = require(\"./typeof.js\")[\"default\"];\nfunction toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nmodule.exports = toPrimitive, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var _typeof = require(\"./typeof.js\")[\"default\"];\nvar toPrimitive = require(\"./toPrimitive.js\");\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nmodule.exports = toPropertyKey, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var toPropertyKey = require(\"./toPropertyKey.js\");\nfunction _defineProperty(e, r, t) {\n  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nmodule.exports = _defineProperty, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var defineProperty = require(\"./defineProperty.js\");\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nmodule.exports = _objectSpread2, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","import { getHTTPStatusCodeFromError } from '../http/getHTTPStatusCode';\nimport type { ProcedureType } from '../procedure';\nimport type { AnyRootTypes, RootConfig } from '../rootConfig';\nimport { TRPC_ERROR_CODES_BY_KEY } from '../rpc';\nimport type { DefaultErrorShape } from './formatter';\nimport type { TRPCError } from './TRPCError';\n\n/**\n * @internal\n */\nexport function getErrorShape<TRoot extends AnyRootTypes>(opts: {\n  config: RootConfig<TRoot>;\n  error: TRPCError;\n  type: ProcedureType | 'unknown';\n  path: string | undefined;\n  input: unknown;\n  ctx: TRoot['ctx'] | undefined;\n}): TRoot['errorShape'] {\n  const { path, error, config } = opts;\n  const { code } = opts.error;\n  const shape: DefaultErrorShape = {\n    message: error.message,\n    code: TRPC_ERROR_CODES_BY_KEY[code],\n    data: {\n      code,\n      httpStatus: getHTTPStatusCodeFromError(error),\n    },\n  };\n  if (config.isDev && typeof opts.error.stack === 'string') {\n    shape.data.stack = opts.error.stack;\n  }\n  if (typeof path === 'string') {\n    shape.data.path = path;\n  }\n  return config.errorFormatter({ ...opts, shape });\n}\n"],"names":["obj: object","callback: ProxyCallback","path: readonly string[]","memo: Record<string, unknown>","callback: (path: keyof TFaux) => any","JSONRPC2_TO_HTTP_CODE: Record<\n  keyof typeof TRPC_ERROR_CODES_BY_KEY,\n  number\n>","HTTP_CODE_TO_JSONRPC2: InvertKeyValue<\n  typeof JSONRPC2_TO_HTTP_CODE\n>","code: keyof typeof TRPC_ERROR_CODES_BY_KEY","code: keyof typeof HTTP_CODE_TO_JSONRPC2","json: TRPCResponse | TRPCResponse[]","error: TRPCError","_typeof","o","_typeof","toPrimitive","toPropertyKey","r","opts: {\n  config: RootConfig<TRoot>;\n  error: TRPCError;\n  type: ProcedureType | 'unknown';\n  path: string | undefined;\n  input: unknown;\n  ctx: TRoot['ctx'] | undefined;\n}","shape: DefaultErrorShape"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7],"debugId":null}},
    {"offset": {"line": 1308, "column": 0}, "map": {"version":3,"file":"tracked-gU3ttYjg.mjs","sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/server/src/unstable-core-do-not-import/error/formatter.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/server/src/unstable-core-do-not-import/error/TRPCError.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/server/src/unstable-core-do-not-import/transformer.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/server/src/unstable-core-do-not-import/router.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/server/src/unstable-core-do-not-import/stream/tracked.ts"],"sourcesContent":["import type { ProcedureType } from '../procedure';\nimport type {\n  TRPC_ERROR_CODE_KEY,\n  TRPC_ERROR_CODE_NUMBER,\n  TRPCErrorShape,\n} from '../rpc';\nimport type { TRPCError } from './TRPCError';\n\n/**\n * @internal\n */\nexport type ErrorFormatter<TContext, TShape extends TRPCErrorShape> = (opts: {\n  error: TRPCError;\n  type: ProcedureType | 'unknown';\n  path: string | undefined;\n  input: unknown;\n  ctx: TContext | undefined;\n  shape: DefaultErrorShape;\n}) => TShape;\n\n/**\n * @internal\n */\nexport type DefaultErrorData = {\n  code: TRPC_ERROR_CODE_KEY;\n  httpStatus: number;\n  /**\n   * Path to the procedure that threw the error\n   */\n  path?: string;\n  /**\n   * Stack trace of the error (only in development)\n   */\n  stack?: string;\n};\n\n/**\n * @internal\n */\nexport interface DefaultErrorShape extends TRPCErrorShape<DefaultErrorData> {\n  message: string;\n  code: TRPC_ERROR_CODE_NUMBER;\n}\n\nexport const defaultFormatter: ErrorFormatter<any, any> = ({ shape }) => {\n  return shape;\n};\n","import type { TRPC_ERROR_CODE_KEY } from '../rpc/codes';\nimport { isObject } from '../utils';\n\nclass UnknownCauseError extends Error {\n  [key: string]: unknown;\n}\nexport function getCauseFromUnknown(cause: unknown): Error | undefined {\n  if (cause instanceof Error) {\n    return cause;\n  }\n\n  const type = typeof cause;\n  if (type === 'undefined' || type === 'function' || cause === null) {\n    return undefined;\n  }\n\n  // Primitive types just get wrapped in an error\n  if (type !== 'object') {\n    // eslint-disable-next-line @typescript-eslint/no-base-to-string\n    return new Error(String(cause));\n  }\n\n  // If it's an object, we'll create a synthetic error\n  if (isObject(cause)) {\n    return Object.assign(new UnknownCauseError(), cause);\n  }\n\n  return undefined;\n}\n\nexport function getTRPCErrorFromUnknown(cause: unknown): TRPCError {\n  if (cause instanceof TRPCError) {\n    return cause;\n  }\n  if (cause instanceof Error && cause.name === 'TRPCError') {\n    // https://github.com/trpc/trpc/pull/4848\n    return cause as TRPCError;\n  }\n\n  const trpcError = new TRPCError({\n    code: 'INTERNAL_SERVER_ERROR',\n    cause,\n  });\n\n  // Inherit stack from error\n  if (cause instanceof Error && cause.stack) {\n    trpcError.stack = cause.stack;\n  }\n\n  return trpcError;\n}\n\nexport class TRPCError extends Error {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore override doesn't work in all environments due to \"This member cannot have an 'override' modifier because it is not declared in the base class 'Error'\"\n  public override readonly cause?: Error;\n  public readonly code;\n\n  constructor(opts: {\n    message?: string;\n    code: TRPC_ERROR_CODE_KEY;\n    cause?: unknown;\n  }) {\n    const cause = getCauseFromUnknown(opts.cause);\n    const message = opts.message ?? cause?.message ?? opts.code;\n\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore https://github.com/tc39/proposal-error-cause\n    super(message, { cause });\n\n    this.code = opts.code;\n    this.name = 'TRPCError';\n    this.cause ??= cause;\n  }\n}\n","import type { AnyRootTypes, RootConfig } from './rootConfig';\nimport type { AnyRouter, inferRouterError } from './router';\nimport type {\n  TRPCResponse,\n  TRPCResponseMessage,\n  TRPCResultMessage,\n} from './rpc';\nimport { isObject } from './utils';\n\n/**\n * @public\n */\nexport interface DataTransformer {\n  serialize: (object: any) => any;\n  deserialize: (object: any) => any;\n}\n\ninterface InputDataTransformer extends DataTransformer {\n  /**\n   * This function runs **on the client** before sending the data to the server.\n   */\n  serialize: (object: any) => any;\n  /**\n   * This function runs **on the server** to transform the data before it is passed to the resolver\n   */\n  deserialize: (object: any) => any;\n}\n\ninterface OutputDataTransformer extends DataTransformer {\n  /**\n   * This function runs **on the server** before sending the data to the client.\n   */\n  serialize: (object: any) => any;\n  /**\n   * This function runs **only on the client** to transform the data sent from the server.\n   */\n  deserialize: (object: any) => any;\n}\n\n/**\n * @public\n */\nexport interface CombinedDataTransformer {\n  /**\n   * Specify how the data sent from the client to the server should be transformed.\n   */\n  input: InputDataTransformer;\n  /**\n   * Specify how the data sent from the server to the client should be transformed.\n   */\n  output: OutputDataTransformer;\n}\n\n/**\n * @public\n */\nexport type CombinedDataTransformerClient = {\n  input: Pick<CombinedDataTransformer['input'], 'serialize'>;\n  output: Pick<CombinedDataTransformer['output'], 'deserialize'>;\n};\n\n/**\n * @public\n */\nexport type DataTransformerOptions = CombinedDataTransformer | DataTransformer;\n\n/**\n * @internal\n */\nexport function getDataTransformer(\n  transformer: DataTransformerOptions,\n): CombinedDataTransformer {\n  if ('input' in transformer) {\n    return transformer;\n  }\n  return { input: transformer, output: transformer };\n}\n\n/**\n * @internal\n */\nexport const defaultTransformer: CombinedDataTransformer = {\n  input: { serialize: (obj) => obj, deserialize: (obj) => obj },\n  output: { serialize: (obj) => obj, deserialize: (obj) => obj },\n};\n\nfunction transformTRPCResponseItem<\n  TResponseItem extends TRPCResponse | TRPCResponseMessage,\n>(config: RootConfig<AnyRootTypes>, item: TResponseItem): TResponseItem {\n  if ('error' in item) {\n    return {\n      ...item,\n      error: config.transformer.output.serialize(item.error),\n    };\n  }\n\n  if ('data' in item.result) {\n    return {\n      ...item,\n      result: {\n        ...item.result,\n        data: config.transformer.output.serialize(item.result.data),\n      },\n    };\n  }\n\n  return item;\n}\n\n/**\n * Takes a unserialized `TRPCResponse` and serializes it with the router's transformers\n **/\nexport function transformTRPCResponse<\n  TResponse extends\n    | TRPCResponse\n    | TRPCResponse[]\n    | TRPCResponseMessage\n    | TRPCResponseMessage[],\n>(config: RootConfig<AnyRootTypes>, itemOrItems: TResponse) {\n  return Array.isArray(itemOrItems)\n    ? itemOrItems.map((item) => transformTRPCResponseItem(config, item))\n    : transformTRPCResponseItem(config, itemOrItems);\n}\n\n// FIXME:\n// - the generics here are probably unnecessary\n// - the RPC-spec could probably be simplified to combine HTTP + WS\n/** @internal */\nfunction transformResultInner<TRouter extends AnyRouter, TOutput>(\n  response:\n    | TRPCResponse<TOutput, inferRouterError<TRouter>>\n    | TRPCResponseMessage<TOutput, inferRouterError<TRouter>>,\n  transformer: DataTransformer,\n) {\n  if ('error' in response) {\n    const error = transformer.deserialize(\n      response.error,\n    ) as inferRouterError<TRouter>;\n    return {\n      ok: false,\n      error: {\n        ...response,\n        error,\n      },\n    } as const;\n  }\n\n  const result = {\n    ...response.result,\n    ...((!response.result.type || response.result.type === 'data') && {\n      type: 'data',\n      data: transformer.deserialize(response.result.data),\n    }),\n  } as TRPCResultMessage<TOutput>['result'];\n  return { ok: true, result } as const;\n}\n\nclass TransformResultError extends Error {\n  constructor() {\n    super('Unable to transform response from server');\n  }\n}\n\n/**\n * Transforms and validates that the result is a valid TRPCResponse\n * @internal\n */\nexport function transformResult<TRouter extends AnyRouter, TOutput>(\n  response:\n    | TRPCResponse<TOutput, inferRouterError<TRouter>>\n    | TRPCResponseMessage<TOutput, inferRouterError<TRouter>>,\n  transformer: DataTransformer,\n): ReturnType<typeof transformResultInner> {\n  let result: ReturnType<typeof transformResultInner>;\n  try {\n    // Use the data transformers on the JSON-response\n    result = transformResultInner(response, transformer);\n  } catch {\n    throw new TransformResultError();\n  }\n\n  // check that output of the transformers is a valid TRPCResponse\n  if (\n    !result.ok &&\n    (!isObject(result.error.error) ||\n      typeof result.error.error['code'] !== 'number')\n  ) {\n    throw new TransformResultError();\n  }\n  if (result.ok && !isObject(result.result)) {\n    throw new TransformResultError();\n  }\n  return result;\n}\n","import type { Observable } from '../observable';\nimport { createRecursiveProxy } from './createProxy';\nimport { defaultFormatter } from './error/formatter';\nimport { getTRPCErrorFromUnknown, TRPCError } from './error/TRPCError';\nimport type {\n  AnyProcedure,\n  ErrorHandlerOptions,\n  inferProcedureInput,\n  inferProcedureOutput,\n  LegacyObservableSubscriptionProcedure,\n} from './procedure';\nimport type { ProcedureCallOptions } from './procedureBuilder';\nimport type { AnyRootTypes, RootConfig } from './rootConfig';\nimport { defaultTransformer } from './transformer';\nimport type { MaybePromise, ValueOf } from './types';\nimport {\n  isFunction,\n  isObject,\n  mergeWithoutOverrides,\n  omitPrototype,\n} from './utils';\n\nexport interface RouterRecord {\n  [key: string]: AnyProcedure | RouterRecord;\n}\n\ntype DecorateProcedure<TProcedure extends AnyProcedure> = (\n  input: inferProcedureInput<TProcedure>,\n) => Promise<\n  TProcedure['_def']['type'] extends 'subscription'\n    ? TProcedure extends LegacyObservableSubscriptionProcedure<any>\n      ? Observable<inferProcedureOutput<TProcedure>, TRPCError>\n      : inferProcedureOutput<TProcedure>\n    : inferProcedureOutput<TProcedure>\n>;\n\n/**\n * @internal\n */\nexport type DecorateRouterRecord<TRecord extends RouterRecord> = {\n  [TKey in keyof TRecord]: TRecord[TKey] extends infer $Value\n    ? $Value extends AnyProcedure\n      ? DecorateProcedure<$Value>\n      : $Value extends RouterRecord\n        ? DecorateRouterRecord<$Value>\n        : never\n    : never;\n};\n\n/**\n * @internal\n */\n\nexport type RouterCallerErrorHandler<TContext> = (\n  opts: ErrorHandlerOptions<TContext>,\n) => void;\n\n/**\n * @internal\n */\nexport type RouterCaller<\n  TRoot extends AnyRootTypes,\n  TRecord extends RouterRecord,\n> = (\n  /**\n   * @note\n   * If passing a function, we recommend it's a cached function\n   * e.g. wrapped in `React.cache` to avoid unnecessary computations\n   */\n  ctx: TRoot['ctx'] | (() => MaybePromise<TRoot['ctx']>),\n  options?: {\n    onError?: RouterCallerErrorHandler<TRoot['ctx']>;\n    signal?: AbortSignal;\n  },\n) => DecorateRouterRecord<TRecord>;\n\nconst lazySymbol = Symbol('lazy');\nexport type Lazy<TAny> = (() => Promise<TAny>) & { [lazySymbol]: true };\n\ntype LazyLoader<TAny> = {\n  load: () => Promise<void>;\n  ref: Lazy<TAny>;\n};\n\nfunction once<T>(fn: () => T): () => T {\n  const uncalled = Symbol();\n  let result: T | typeof uncalled = uncalled;\n  return (): T => {\n    if (result === uncalled) {\n      result = fn();\n    }\n    return result;\n  };\n}\n\n/**\n * Lazy load a router\n * @see https://trpc.io/docs/server/merging-routers#lazy-load\n */\nexport function lazy<TRouter extends AnyRouter>(\n  importRouter: () => Promise<\n    | TRouter\n    | {\n        [key: string]: TRouter;\n      }\n  >,\n): Lazy<NoInfer<TRouter>> {\n  async function resolve(): Promise<TRouter> {\n    const mod = await importRouter();\n\n    // if the module is a router, return it\n    if (isRouter(mod)) {\n      return mod;\n    }\n\n    const routers = Object.values(mod);\n\n    if (routers.length !== 1 || !isRouter(routers[0])) {\n      throw new Error(\n        \"Invalid router module - either define exactly 1 export or return the router directly.\\nExample: `lazy(() => import('./slow.js').then((m) => m.slowRouter))`\",\n      );\n    }\n\n    return routers[0];\n  }\n  resolve[lazySymbol] = true as const;\n\n  return resolve;\n}\n\nfunction isLazy<TAny>(input: unknown): input is Lazy<TAny> {\n  return typeof input === 'function' && lazySymbol in input;\n}\n\n/**\n * @internal\n */\nexport interface RouterDef<\n  TRoot extends AnyRootTypes,\n  TRecord extends RouterRecord,\n> {\n  _config: RootConfig<TRoot>;\n  router: true;\n  procedure?: never;\n  procedures: TRecord;\n  record: TRecord;\n  lazy: Record<string, LazyLoader<AnyRouter>>;\n}\n\nexport interface Router<\n  TRoot extends AnyRootTypes,\n  TRecord extends RouterRecord,\n> {\n  _def: RouterDef<TRoot, TRecord>;\n  /**\n   * @see https://trpc.io/docs/v11/server/server-side-calls\n   */\n  createCaller: RouterCaller<TRoot, TRecord>;\n}\n\nexport type BuiltRouter<\n  TRoot extends AnyRootTypes,\n  TRecord extends RouterRecord,\n> = Router<TRoot, TRecord> & TRecord;\n\nexport interface RouterBuilder<TRoot extends AnyRootTypes> {\n  <TIn extends CreateRouterOptions>(\n    _: TIn,\n  ): BuiltRouter<TRoot, DecorateCreateRouterOptions<TIn>>;\n}\n\nexport type AnyRouter = Router<any, any>;\n\nexport type inferRouterRootTypes<TRouter extends AnyRouter> =\n  TRouter['_def']['_config']['$types'];\n\nexport type inferRouterContext<TRouter extends AnyRouter> =\n  inferRouterRootTypes<TRouter>['ctx'];\nexport type inferRouterError<TRouter extends AnyRouter> =\n  inferRouterRootTypes<TRouter>['errorShape'];\nexport type inferRouterMeta<TRouter extends AnyRouter> =\n  inferRouterRootTypes<TRouter>['meta'];\n\nfunction isRouter(value: unknown): value is AnyRouter {\n  return (\n    isObject(value) && isObject(value['_def']) && 'router' in value['_def']\n  );\n}\n\nconst emptyRouter = {\n  _ctx: null as any,\n  _errorShape: null as any,\n  _meta: null as any,\n  queries: {},\n  mutations: {},\n  subscriptions: {},\n  errorFormatter: defaultFormatter,\n  transformer: defaultTransformer,\n};\n\n/**\n * Reserved words that can't be used as router or procedure names\n */\nconst reservedWords = [\n  /**\n   * Then is a reserved word because otherwise we can't return a promise that returns a Proxy\n   * since JS will think that `.then` is something that exists\n   */\n  'then',\n  /**\n   * `fn.call()` and `fn.apply()` are reserved words because otherwise we can't call a function using `.call` or `.apply`\n   */\n  'call',\n  'apply',\n];\n\n/** @internal */\nexport type CreateRouterOptions = {\n  [key: string]:\n    | AnyProcedure\n    | AnyRouter\n    | CreateRouterOptions\n    | Lazy<AnyRouter>;\n};\n\n/** @internal */\nexport type DecorateCreateRouterOptions<\n  TRouterOptions extends CreateRouterOptions,\n> = {\n  [K in keyof TRouterOptions]: TRouterOptions[K] extends infer $Value\n    ? $Value extends AnyProcedure\n      ? $Value\n      : $Value extends Router<any, infer TRecord>\n        ? TRecord\n        : $Value extends Lazy<Router<any, infer TRecord>>\n          ? TRecord\n          : $Value extends CreateRouterOptions\n            ? DecorateCreateRouterOptions<$Value>\n            : never\n    : never;\n};\n\n/**\n * @internal\n */\nexport function createRouterFactory<TRoot extends AnyRootTypes>(\n  config: RootConfig<TRoot>,\n) {\n  function createRouterInner<TInput extends CreateRouterOptions>(\n    input: TInput,\n  ): BuiltRouter<TRoot, DecorateCreateRouterOptions<TInput>> {\n    const reservedWordsUsed = new Set(\n      Object.keys(input).filter((v) => reservedWords.includes(v)),\n    );\n    if (reservedWordsUsed.size > 0) {\n      throw new Error(\n        'Reserved words used in `router({})` call: ' +\n          Array.from(reservedWordsUsed).join(', '),\n      );\n    }\n\n    const procedures: Record<string, AnyProcedure> = omitPrototype({});\n    const lazy: Record<string, LazyLoader<AnyRouter>> = omitPrototype({});\n\n    function createLazyLoader(opts: {\n      ref: Lazy<AnyRouter>;\n      path: readonly string[];\n      key: string;\n      aggregate: RouterRecord;\n    }): LazyLoader<AnyRouter> {\n      return {\n        ref: opts.ref,\n        load: once(async () => {\n          const router = await opts.ref();\n          const lazyPath = [...opts.path, opts.key];\n          const lazyKey = lazyPath.join('.');\n\n          opts.aggregate[opts.key] = step(router._def.record, lazyPath);\n\n          delete lazy[lazyKey];\n\n          // add lazy loaders for nested routers\n          for (const [nestedKey, nestedItem] of Object.entries(\n            router._def.lazy,\n          )) {\n            const nestedRouterKey = [...lazyPath, nestedKey].join('.');\n\n            // console.log('adding lazy', nestedRouterKey);\n            lazy[nestedRouterKey] = createLazyLoader({\n              ref: nestedItem.ref,\n              path: lazyPath,\n              key: nestedKey,\n              aggregate: opts.aggregate[opts.key] as RouterRecord,\n            });\n          }\n        }),\n      };\n    }\n\n    function step(from: CreateRouterOptions, path: readonly string[] = []) {\n      const aggregate: RouterRecord = omitPrototype({});\n      for (const [key, item] of Object.entries(from ?? {})) {\n        if (isLazy(item)) {\n          lazy[[...path, key].join('.')] = createLazyLoader({\n            path,\n            ref: item,\n            key,\n            aggregate,\n          });\n          continue;\n        }\n        if (isRouter(item)) {\n          aggregate[key] = step(item._def.record, [...path, key]);\n          continue;\n        }\n        if (!isProcedure(item)) {\n          // RouterRecord\n          aggregate[key] = step(item, [...path, key]);\n          continue;\n        }\n\n        const newPath = [...path, key].join('.');\n\n        if (procedures[newPath]) {\n          throw new Error(`Duplicate key: ${newPath}`);\n        }\n\n        procedures[newPath] = item;\n        aggregate[key] = item;\n      }\n\n      return aggregate;\n    }\n    const record = step(input);\n\n    const _def: AnyRouter['_def'] = {\n      _config: config,\n      router: true,\n      procedures,\n      lazy,\n      ...emptyRouter,\n      record,\n    };\n\n    const router: BuiltRouter<TRoot, {}> = {\n      ...(record as {}),\n      _def,\n      createCaller: createCallerFactory<TRoot>()({\n        _def,\n      }),\n    };\n    return router as BuiltRouter<TRoot, DecorateCreateRouterOptions<TInput>>;\n  }\n\n  return createRouterInner;\n}\n\nfunction isProcedure(\n  procedureOrRouter: ValueOf<CreateRouterOptions>,\n): procedureOrRouter is AnyProcedure {\n  return typeof procedureOrRouter === 'function';\n}\n\n/**\n * @internal\n */\nexport async function getProcedureAtPath(\n  router: Pick<Router<any, any>, '_def'>,\n  path: string,\n): Promise<AnyProcedure | null> {\n  const { _def } = router;\n  let procedure = _def.procedures[path];\n\n  while (!procedure) {\n    const key = Object.keys(_def.lazy).find((key) => path.startsWith(key));\n    // console.log(`found lazy: ${key ?? 'NOPE'} (fullPath: ${fullPath})`);\n\n    if (!key) {\n      return null;\n    }\n    // console.log('loading', key, '.......');\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const lazyRouter = _def.lazy[key]!;\n    await lazyRouter.load();\n\n    procedure = _def.procedures[path];\n  }\n\n  return procedure;\n}\n\n/**\n * @internal\n */\nexport async function callProcedure(\n  opts: ProcedureCallOptions<unknown> & {\n    router: AnyRouter;\n    allowMethodOverride?: boolean;\n  },\n) {\n  const { type, path } = opts;\n  const proc = await getProcedureAtPath(opts.router, path);\n  if (\n    !proc ||\n    !isProcedure(proc) ||\n    (proc._def.type !== type && !opts.allowMethodOverride)\n  ) {\n    throw new TRPCError({\n      code: 'NOT_FOUND',\n      message: `No \"${type}\"-procedure on path \"${path}\"`,\n    });\n  }\n\n  /* istanbul ignore if -- @preserve */\n  if (\n    proc._def.type !== type &&\n    opts.allowMethodOverride &&\n    proc._def.type === 'subscription'\n  ) {\n    throw new TRPCError({\n      code: 'METHOD_NOT_SUPPORTED',\n      message: `Method override is not supported for subscriptions`,\n    });\n  }\n\n  return proc(opts);\n}\n\nexport interface RouterCallerFactory<TRoot extends AnyRootTypes> {\n  <TRecord extends RouterRecord>(\n    router: Pick<Router<TRoot, TRecord>, '_def'>,\n  ): RouterCaller<TRoot, TRecord>;\n}\n\nexport function createCallerFactory<\n  TRoot extends AnyRootTypes,\n>(): RouterCallerFactory<TRoot> {\n  return function createCallerInner<TRecord extends RouterRecord>(\n    router: Pick<Router<TRoot, TRecord>, '_def'>,\n  ): RouterCaller<TRoot, TRecord> {\n    const { _def } = router;\n    type Context = TRoot['ctx'];\n\n    return function createCaller(ctxOrCallback, opts) {\n      return createRecursiveProxy<ReturnType<RouterCaller<any, any>>>(\n        async ({ path, args }) => {\n          const fullPath = path.join('.');\n\n          if (path.length === 1 && path[0] === '_def') {\n            return _def;\n          }\n\n          const procedure = await getProcedureAtPath(router, fullPath);\n\n          let ctx: Context | undefined = undefined;\n          try {\n            if (!procedure) {\n              throw new TRPCError({\n                code: 'NOT_FOUND',\n                message: `No procedure found on path \"${path}\"`,\n              });\n            }\n            ctx = isFunction(ctxOrCallback)\n              ? await Promise.resolve(ctxOrCallback())\n              : ctxOrCallback;\n\n            return await procedure({\n              path: fullPath,\n              getRawInput: async () => args[0],\n              ctx,\n              type: procedure._def.type,\n              signal: opts?.signal,\n            });\n          } catch (cause) {\n            opts?.onError?.({\n              ctx,\n              error: getTRPCErrorFromUnknown(cause),\n              input: args[0],\n              path: fullPath,\n              type: procedure?._def.type ?? 'unknown',\n            });\n            throw cause;\n          }\n        },\n      );\n    };\n  };\n}\n\n/** @internal */\nexport type MergeRouters<\n  TRouters extends AnyRouter[],\n  TRoot extends AnyRootTypes = TRouters[0]['_def']['_config']['$types'],\n  TRecord extends RouterRecord = {},\n> = TRouters extends [\n  infer Head extends AnyRouter,\n  ...infer Tail extends AnyRouter[],\n]\n  ? MergeRouters<Tail, TRoot, Head['_def']['record'] & TRecord>\n  : BuiltRouter<TRoot, TRecord>;\n\nexport function mergeRouters<TRouters extends AnyRouter[]>(\n  ...routerList: [...TRouters]\n): MergeRouters<TRouters> {\n  const record = mergeWithoutOverrides(\n    {},\n    ...routerList.map((r) => r._def.record),\n  );\n  const errorFormatter = routerList.reduce(\n    (currentErrorFormatter, nextRouter) => {\n      if (\n        nextRouter._def._config.errorFormatter &&\n        nextRouter._def._config.errorFormatter !== defaultFormatter\n      ) {\n        if (\n          currentErrorFormatter !== defaultFormatter &&\n          currentErrorFormatter !== nextRouter._def._config.errorFormatter\n        ) {\n          throw new Error('You seem to have several error formatters');\n        }\n        return nextRouter._def._config.errorFormatter;\n      }\n      return currentErrorFormatter;\n    },\n    defaultFormatter,\n  );\n\n  const transformer = routerList.reduce((prev, current) => {\n    if (\n      current._def._config.transformer &&\n      current._def._config.transformer !== defaultTransformer\n    ) {\n      if (\n        prev !== defaultTransformer &&\n        prev !== current._def._config.transformer\n      ) {\n        throw new Error('You seem to have several transformers');\n      }\n      return current._def._config.transformer;\n    }\n    return prev;\n  }, defaultTransformer);\n\n  const router = createRouterFactory({\n    errorFormatter,\n    transformer,\n    isDev: routerList.every((r) => r._def._config.isDev),\n    allowOutsideOfServer: routerList.every(\n      (r) => r._def._config.allowOutsideOfServer,\n    ),\n    isServer: routerList.every((r) => r._def._config.isServer),\n    $types: routerList[0]?._def._config.$types,\n  })(record);\n\n  return router as MergeRouters<TRouters>;\n}\n","const trackedSymbol = Symbol();\n\ntype TrackedId = string & {\n  __brand: 'TrackedId';\n};\nexport type TrackedEnvelope<TData> = [TrackedId, TData, typeof trackedSymbol];\n\nexport interface TrackedData<TData> {\n  /**\n   * The id of the message to keep track of in case the connection gets lost\n   */\n  id: string;\n  /**\n   * The data field of the message\n   */\n  data: TData;\n}\n/**\n * Produce a typed server-sent event message\n * @deprecated use `tracked(id, data)` instead\n */\nexport function sse<TData>(event: { id: string; data: TData }) {\n  return tracked(event.id, event.data);\n}\n\nexport function isTrackedEnvelope<TData>(\n  value: unknown,\n): value is TrackedEnvelope<TData> {\n  return Array.isArray(value) && value[2] === trackedSymbol;\n}\n\n/**\n * Automatically track an event so that it can be resumed from a given id if the connection is lost\n */\nexport function tracked<TData>(\n  id: string,\n  data: TData,\n): TrackedEnvelope<TData> {\n  if (id === '') {\n    // This limitation could be removed by using different SSE event names / channels for tracked event and non-tracked event\n    throw new Error(\n      '`id` must not be an empty string as empty string is the same as not setting the id at all',\n    );\n  }\n  return [id as TrackedId, data, trackedSymbol];\n}\n\nexport type inferTrackedOutput<TData> =\n  TData extends TrackedEnvelope<infer $Data> ? TrackedData<$Data> : TData;\n"],"names":["defaultFormatter: ErrorFormatter<any, any>","cause: unknown","opts: {\n    message?: string;\n    code: TRPC_ERROR_CODE_KEY;\n    cause?: unknown;\n  }","transformer: DataTransformerOptions","defaultTransformer: CombinedDataTransformer","config: RootConfig<AnyRootTypes>","item: TResponseItem","itemOrItems: TResponse","response:\n    | TRPCResponse<TOutput, inferRouterError<TRouter>>\n    | TRPCResponseMessage<TOutput, inferRouterError<TRouter>>","transformer: DataTransformer","result: ReturnType<typeof transformResultInner>","fn: () => T","result: T | typeof uncalled","importRouter: () => Promise<\n    | TRouter\n    | {\n        [key: string]: TRouter;\n      }\n  >","input: unknown","value: unknown","config: RootConfig<TRoot>","input: TInput","procedures: Record<string, AnyProcedure>","lazy: Record<string, LazyLoader<AnyRouter>>","opts: {\n      ref: Lazy<AnyRouter>;\n      path: readonly string[];\n      key: string;\n      aggregate: RouterRecord;\n    }","router","lazy","from: CreateRouterOptions","path: readonly string[]","aggregate: RouterRecord","_def: AnyRouter['_def']","router: BuiltRouter<TRoot, {}>","procedureOrRouter: ValueOf<CreateRouterOptions>","router: Pick<Router<any, any>, '_def'>","path: string","key","opts: ProcedureCallOptions<unknown> & {\n    router: AnyRouter;\n    allowMethodOverride?: boolean;\n  }","router: Pick<Router<TRoot, TRecord>, '_def'>","ctx: Context | undefined","event: { id: string; data: TData }","value: unknown","id: string","data: TData"],"mappings":"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","ignoreList":[0,1,2,3,4],"debugId":null}},
    {"offset": {"line": 1719, "column": 0}, "map": {"version":3,"file":"httpLink-CYOcG9kQ.mjs","sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/client/src/links/internals/contentTypes.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/client/src/links/httpLink.ts"],"sourcesContent":["export function isOctetType(input: unknown) {\n  return (\n    input instanceof Uint8Array ||\n    // File extends from Blob but is only available in nodejs from v20\n    input instanceof Blob\n  );\n}\n\nexport function isFormData(input: unknown) {\n  return input instanceof FormData;\n}\n\nexport function isNonJsonSerializable(input: unknown) {\n  return isOctetType(input) || isFormData(input);\n}\n","import { observable } from '@trpc/server/observable';\nimport type {\n  AnyClientTypes,\n  AnyRouter,\n} from '@trpc/server/unstable-core-do-not-import';\nimport { transformResult } from '@trpc/server/unstable-core-do-not-import';\nimport { TRPCClientError } from '../TRPCClientError';\nimport type {\n  HTTPLinkBaseOptions,\n  HTTPResult,\n  Requester,\n} from './internals/httpUtils';\nimport {\n  getUrl,\n  httpRequest,\n  jsonHttpRequester,\n  resolveHTTPLinkOptions,\n} from './internals/httpUtils';\nimport {\n  isFormData,\n  isOctetType,\n  type HTTPHeaders,\n  type Operation,\n  type TRPCLink,\n} from './types';\n\nexport type HTTPLinkOptions<TRoot extends AnyClientTypes> =\n  HTTPLinkBaseOptions<TRoot> & {\n    /**\n     * Headers to be set on outgoing requests or a callback that of said headers\n     * @see http://trpc.io/docs/client/headers\n     */\n    headers?:\n      | HTTPHeaders\n      | ((opts: { op: Operation }) => HTTPHeaders | Promise<HTTPHeaders>);\n  };\n\nconst universalRequester: Requester = (opts) => {\n  if ('input' in opts) {\n    const { input } = opts;\n    if (isFormData(input)) {\n      if (opts.type !== 'mutation' && opts.methodOverride !== 'POST') {\n        throw new Error('FormData is only supported for mutations');\n      }\n\n      return httpRequest({\n        ...opts,\n        // The browser will set this automatically and include the boundary= in it\n        contentTypeHeader: undefined,\n        getUrl,\n        getBody: () => input,\n      });\n    }\n\n    if (isOctetType(input)) {\n      if (opts.type !== 'mutation' && opts.methodOverride !== 'POST') {\n        throw new Error('Octet type input is only supported for mutations');\n      }\n\n      return httpRequest({\n        ...opts,\n        contentTypeHeader: 'application/octet-stream',\n        getUrl,\n        getBody: () => input,\n      });\n    }\n  }\n\n  return jsonHttpRequester(opts);\n};\n\n/**\n * @see https://trpc.io/docs/client/links/httpLink\n */\nexport function httpLink<TRouter extends AnyRouter = AnyRouter>(\n  opts: HTTPLinkOptions<TRouter['_def']['_config']['$types']>,\n): TRPCLink<TRouter> {\n  const resolvedOpts = resolveHTTPLinkOptions(opts);\n  return () => {\n    return ({ op }) => {\n      return observable((observer) => {\n        const { path, input, type } = op;\n        /* istanbul ignore if -- @preserve */\n        if (type === 'subscription') {\n          throw new Error(\n            'Subscriptions are unsupported by `httpLink` - use `httpSubscriptionLink` or `wsLink`',\n          );\n        }\n\n        const request = universalRequester({\n          ...resolvedOpts,\n          type,\n          path,\n          input,\n          signal: op.signal,\n          headers() {\n            if (!opts.headers) {\n              return {};\n            }\n            if (typeof opts.headers === 'function') {\n              return opts.headers({\n                op,\n              });\n            }\n            return opts.headers;\n          },\n        });\n        let meta: HTTPResult['meta'] | undefined = undefined;\n        request\n          .then((res) => {\n            meta = res.meta;\n            const transformed = transformResult(\n              res.json,\n              resolvedOpts.transformer.output,\n            );\n\n            if (!transformed.ok) {\n              observer.error(\n                TRPCClientError.from(transformed.error, {\n                  meta,\n                }),\n              );\n              return;\n            }\n            observer.next({\n              context: res.meta,\n              result: transformed.result,\n            });\n            observer.complete();\n          })\n          .catch((cause) => {\n            observer.error(TRPCClientError.from(cause, { meta }));\n          });\n\n        return () => {\n          // noop\n        };\n      });\n    };\n  };\n}\n"],"names":["input: unknown","universalRequester: Requester","opts: HTTPLinkOptions<TRouter['_def']['_config']['$types']>","meta: HTTPResult['meta'] | undefined"],"mappings":";;;;;;;;;;;;;;;;;AAAA,SAAgB,YAAYA,KAAAA,EAAgB;IAC1C,OACE,iBAAiB,cAEjB,iBAAiB;AAEpB;AAED,SAAgB,WAAWA,KAAAA,EAAgB;IACzC,OAAO,iBAAiB;AACzB;AAED,SAAgB,sBAAsBA,KAAAA,EAAgB;IACpD,OAAO,YAAY,MAAM,IAAI,WAAW,MAAM;AAC/C;;;;ACuBD,MAAMC,qBAAgC,CAAC,SAAS;IAC9C,IAAI,WAAW,MAAM;QACnB,MAAM,EAAE,KAAA,EAAO,GAAG;QAClB,IAAI,WAAW,MAAM,EAAE;YACrB,IAAI,KAAK,IAAA,KAAS,cAAc,KAAK,cAAA,KAAmB,OACtD,CAAA,MAAM,IAAI,MAAM;YAGlB,iLAAO,cAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GACF,OAAA,CAAA,GAAA;gBAEH,mBAAA,KAAA;8LACA,SAAA;gBACA,SAAS,IAAM;eACf;QACH;QAED,IAAI,YAAY,MAAM,EAAE;YACtB,IAAI,KAAK,IAAA,KAAS,cAAc,KAAK,cAAA,KAAmB,OACtD,CAAA,MAAM,IAAI,MAAM;YAGlB,iLAAO,cAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GACF,OAAA,CAAA,GAAA;gBACH,mBAAmB;8LACnB,SAAA;gBACA,SAAS,IAAM;eACf;QACH;IACF;IAED,iLAAO,oBAAA,EAAkB,KAAK;AAC/B;;;GAKD,SAAgB,SACdC,IAAAA,EACmB;IACnB,MAAM,eAAe,mMAAA,EAAuB,KAAK;IACjD,OAAO,MAAM;QACX,OAAO,CAAC,EAAE,EAAA,EAAI,KAAK;YACjB,kLAAO,aAAA,EAAW,CAAC,aAAa;gBAC9B,MAAM,EAAE,IAAA,EAAM,KAAA,EAAO,IAAA,EAAM,GAAG;sDAE9B,IAAI,SAAS,eACX,CAAA,MAAM,IAAI,MACR;gBAIJ,MAAM,UAAU,mBAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GACX,eAAA,CAAA,GAAA;oBACH;oBACA;oBACA;oBACA,QAAQ,GAAG,MAAA;oBACX,UAAU;wBACR,IAAA,CAAK,KAAK,OAAA,CACR,CAAA,OAAO,CAAE;wBAEX,IAAA,OAAW,KAAK,OAAA,KAAY,WAC1B,CAAA,OAAO,KAAK,OAAA,CAAQ;4BAClB;wBACD,EAAC;wBAEJ,OAAO,KAAK,OAAA;oBACb;mBACD;gBACF,IAAIC,OAAAA,KAAAA;gBACJ,QACG,IAAA,CAAK,CAAC,QAAQ;oBACb,OAAO,IAAI,IAAA;oBACX,MAAM,eAAc,yLAAA,EAClB,IAAI,IAAA,EACJ,aAAa,WAAA,CAAY,MAAA,CAC1B;oBAED,IAAA,CAAK,YAAY,EAAA,EAAI;wBACnB,SAAS,KAAA,6KACP,kBAAA,CAAgB,IAAA,CAAK,YAAY,KAAA,EAAO;4BACtC;wBACD,EAAC,CACH;wBACD;oBACD;oBACD,SAAS,IAAA,CAAK;wBACZ,SAAS,IAAI,IAAA;wBACb,QAAQ,YAAY,MAAA;oBACrB,EAAC;oBACF,SAAS,QAAA,EAAU;gBACpB,EAAC,CACD,KAAA,CAAM,CAAC,UAAU;oBAChB,SAAS,KAAA,6KAAM,kBAAA,CAAgB,IAAA,CAAK,OAAO;wBAAE;oBAAM,EAAC,CAAC;gBACtD,EAAC;gBAEJ,OAAO,KAEN,CAFY;YAGd,EAAC;QACH;IACF;AACF","ignoreList":[0,1],"debugId":null}},
    {"offset": {"line": 1825, "column": 0}, "map": {"version":3,"file":"httpBatchLink-CA96-gnJ.mjs","sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/client/src/internals/dataLoader.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/client/src/internals/signals.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/client/src/links/httpBatchLink.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-non-null-assertion */\n\ntype BatchItem<TKey, TValue> = {\n  aborted: boolean;\n  key: TKey;\n  resolve: ((value: TValue) => void) | null;\n  reject: ((error: Error) => void) | null;\n  batch: Batch<TKey, TValue> | null;\n};\ntype Batch<TKey, TValue> = {\n  items: BatchItem<TKey, TValue>[];\n};\nexport type BatchLoader<TKey, TValue> = {\n  validate: (keys: TKey[]) => boolean;\n  fetch: (keys: TKey[]) => Promise<TValue[] | Promise<TValue>[]>;\n};\n\n/**\n * A function that should never be called unless we messed something up.\n */\nconst throwFatalError = () => {\n  throw new Error(\n    'Something went wrong. Please submit an issue at https://github.com/trpc/trpc/issues/new',\n  );\n};\n\n/**\n * Dataloader that's very inspired by https://github.com/graphql/dataloader\n * Less configuration, no caching, and allows you to cancel requests\n * When cancelling a single fetch the whole batch will be cancelled only when _all_ items are cancelled\n */\nexport function dataLoader<TKey, TValue>(\n  batchLoader: BatchLoader<TKey, TValue>,\n) {\n  let pendingItems: BatchItem<TKey, TValue>[] | null = null;\n  let dispatchTimer: ReturnType<typeof setTimeout> | null = null;\n\n  const destroyTimerAndPendingItems = () => {\n    clearTimeout(dispatchTimer as any);\n    dispatchTimer = null;\n    pendingItems = null;\n  };\n\n  /**\n   * Iterate through the items and split them into groups based on the `batchLoader`'s validate function\n   */\n  function groupItems(items: BatchItem<TKey, TValue>[]) {\n    const groupedItems: BatchItem<TKey, TValue>[][] = [[]];\n    let index = 0;\n    while (true) {\n      const item = items[index];\n      if (!item) {\n        // we're done\n        break;\n      }\n      const lastGroup = groupedItems[groupedItems.length - 1]!;\n\n      if (item.aborted) {\n        // Item was aborted before it was dispatched\n        item.reject?.(new Error('Aborted'));\n        index++;\n        continue;\n      }\n\n      const isValid = batchLoader.validate(\n        lastGroup.concat(item).map((it) => it.key),\n      );\n\n      if (isValid) {\n        lastGroup.push(item);\n        index++;\n        continue;\n      }\n\n      if (lastGroup.length === 0) {\n        item.reject?.(new Error('Input is too big for a single dispatch'));\n        index++;\n        continue;\n      }\n      // Create new group, next iteration will try to add the item to that\n      groupedItems.push([]);\n    }\n    return groupedItems;\n  }\n\n  function dispatch() {\n    const groupedItems = groupItems(pendingItems!);\n    destroyTimerAndPendingItems();\n\n    // Create batches for each group of items\n    for (const items of groupedItems) {\n      if (!items.length) {\n        continue;\n      }\n      const batch: Batch<TKey, TValue> = {\n        items,\n      };\n      for (const item of items) {\n        item.batch = batch;\n      }\n      const promise = batchLoader.fetch(batch.items.map((_item) => _item.key));\n\n      promise\n        .then(async (result) => {\n          await Promise.all(\n            result.map(async (valueOrPromise, index) => {\n              const item = batch.items[index]!;\n              try {\n                const value = await Promise.resolve(valueOrPromise);\n\n                item.resolve?.(value);\n              } catch (cause) {\n                item.reject?.(cause as Error);\n              }\n\n              item.batch = null;\n              item.reject = null;\n              item.resolve = null;\n            }),\n          );\n\n          for (const item of batch.items) {\n            item.reject?.(new Error('Missing result'));\n            item.batch = null;\n          }\n        })\n        .catch((cause) => {\n          for (const item of batch.items) {\n            item.reject?.(cause);\n            item.batch = null;\n          }\n        });\n    }\n  }\n  function load(key: TKey): Promise<TValue> {\n    const item: BatchItem<TKey, TValue> = {\n      aborted: false,\n      key,\n      batch: null,\n      resolve: throwFatalError,\n      reject: throwFatalError,\n    };\n\n    const promise = new Promise<TValue>((resolve, reject) => {\n      item.reject = reject;\n      item.resolve = resolve;\n\n      pendingItems ??= [];\n      pendingItems.push(item);\n    });\n\n    dispatchTimer ??= setTimeout(dispatch);\n\n    return promise;\n  }\n\n  return {\n    load,\n  };\n}\n","import type { Maybe } from '@trpc/server/unstable-core-do-not-import';\n\n/**\n * Like `Promise.all()` but for abort signals\n * - When all signals have been aborted, the merged signal will be aborted\n * - If one signal is `null`, no signal will be aborted\n */\nexport function allAbortSignals(...signals: Maybe<AbortSignal>[]): AbortSignal {\n  const ac = new AbortController();\n\n  const count = signals.length;\n\n  let abortedCount = 0;\n\n  const onAbort = () => {\n    if (++abortedCount === count) {\n      ac.abort();\n    }\n  };\n\n  for (const signal of signals) {\n    if (signal?.aborted) {\n      onAbort();\n    } else {\n      signal?.addEventListener('abort', onAbort, {\n        once: true,\n      });\n    }\n  }\n\n  return ac.signal;\n}\n\n/**\n * Like `Promise.race` but for abort signals\n *\n * Basically, a ponyfill for\n * [`AbortSignal.any`](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/any_static).\n */\nexport function raceAbortSignals(\n  ...signals: Maybe<AbortSignal>[]\n): AbortSignal {\n  const ac = new AbortController();\n\n  for (const signal of signals) {\n    if (signal?.aborted) {\n      ac.abort();\n    } else {\n      signal?.addEventListener('abort', () => ac.abort(), { once: true });\n    }\n  }\n\n  return ac.signal;\n}\n\nexport function abortSignalToPromise(signal: AbortSignal): Promise<never> {\n  return new Promise((_, reject) => {\n    if (signal.aborted) {\n      reject(signal.reason);\n      return;\n    }\n    signal.addEventListener(\n      'abort',\n      () => {\n        reject(signal.reason);\n      },\n      { once: true },\n    );\n  });\n}\n","import type { AnyRouter, ProcedureType } from '@trpc/server';\nimport { observable } from '@trpc/server/observable';\nimport { transformResult } from '@trpc/server/unstable-core-do-not-import';\nimport type { BatchLoader } from '../internals/dataLoader';\nimport { dataLoader } from '../internals/dataLoader';\nimport { allAbortSignals } from '../internals/signals';\nimport type { NonEmptyArray } from '../internals/types';\nimport { TRPCClientError } from '../TRPCClientError';\nimport type { HTTPBatchLinkOptions } from './HTTPBatchLinkOptions';\nimport type { HTTPResult } from './internals/httpUtils';\nimport {\n  getUrl,\n  jsonHttpRequester,\n  resolveHTTPLinkOptions,\n} from './internals/httpUtils';\nimport type { Operation, TRPCLink } from './types';\n\n/**\n * @see https://trpc.io/docs/client/links/httpBatchLink\n */\nexport function httpBatchLink<TRouter extends AnyRouter>(\n  opts: HTTPBatchLinkOptions<TRouter['_def']['_config']['$types']>,\n): TRPCLink<TRouter> {\n  const resolvedOpts = resolveHTTPLinkOptions(opts);\n  const maxURLLength = opts.maxURLLength ?? Infinity;\n  const maxItems = opts.maxItems ?? Infinity;\n\n  return () => {\n    const batchLoader = (\n      type: ProcedureType,\n    ): BatchLoader<Operation, HTTPResult> => {\n      return {\n        validate(batchOps) {\n          if (maxURLLength === Infinity && maxItems === Infinity) {\n            // escape hatch for quick calcs\n            return true;\n          }\n          if (batchOps.length > maxItems) {\n            return false;\n          }\n          const path = batchOps.map((op) => op.path).join(',');\n          const inputs = batchOps.map((op) => op.input);\n\n          const url = getUrl({\n            ...resolvedOpts,\n            type,\n            path,\n            inputs,\n            signal: null,\n          });\n\n          return url.length <= maxURLLength;\n        },\n        async fetch(batchOps) {\n          const path = batchOps.map((op) => op.path).join(',');\n          const inputs = batchOps.map((op) => op.input);\n          const signal = allAbortSignals(...batchOps.map((op) => op.signal));\n\n          const res = await jsonHttpRequester({\n            ...resolvedOpts,\n            path,\n            inputs,\n            type,\n            headers() {\n              if (!opts.headers) {\n                return {};\n              }\n              if (typeof opts.headers === 'function') {\n                return opts.headers({\n                  opList: batchOps as NonEmptyArray<Operation>,\n                });\n              }\n              return opts.headers;\n            },\n            signal,\n          });\n          const resJSON = Array.isArray(res.json)\n            ? res.json\n            : batchOps.map(() => res.json);\n          const result = resJSON.map((item) => ({\n            meta: res.meta,\n            json: item,\n          }));\n          return result;\n        },\n      };\n    };\n\n    const query = dataLoader(batchLoader('query'));\n    const mutation = dataLoader(batchLoader('mutation'));\n\n    const loaders = { query, mutation };\n    return ({ op }) => {\n      return observable((observer) => {\n        /* istanbul ignore if -- @preserve */\n        if (op.type === 'subscription') {\n          throw new Error(\n            'Subscriptions are unsupported by `httpLink` - use `httpSubscriptionLink` or `wsLink`',\n          );\n        }\n        const loader = loaders[op.type];\n        const promise = loader.load(op);\n\n        let _res = undefined as HTTPResult | undefined;\n        promise\n          .then((res) => {\n            _res = res;\n            const transformed = transformResult(\n              res.json,\n              resolvedOpts.transformer.output,\n            );\n\n            if (!transformed.ok) {\n              observer.error(\n                TRPCClientError.from(transformed.error, {\n                  meta: res.meta,\n                }),\n              );\n              return;\n            }\n            observer.next({\n              context: res.meta,\n              result: transformed.result,\n            });\n            observer.complete();\n          })\n          .catch((err) => {\n            observer.error(\n              TRPCClientError.from(err, {\n                meta: _res?.meta,\n              }),\n            );\n          });\n\n        return () => {\n          // noop\n        };\n      });\n    };\n  };\n}\n"],"names":["batchLoader: BatchLoader<TKey, TValue>","pendingItems: BatchItem<TKey, TValue>[] | null","dispatchTimer: ReturnType<typeof setTimeout> | null","items: BatchItem<TKey, TValue>[]","groupedItems: BatchItem<TKey, TValue>[][]","batch: Batch<TKey, TValue>","key: TKey","item: BatchItem<TKey, TValue>","signal: AbortSignal","opts: HTTPBatchLinkOptions<TRouter['_def']['_config']['$types']>","type: ProcedureType"],"mappings":"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","ignoreList":[0,1,2],"debugId":null}},
    {"offset": {"line": 2096, "column": 0}, "map": {"version":3,"file":"observable-CUiPknO-.mjs","sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/server/src/observable/operators.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/server/src/observable/behaviorSubject.ts"],"sourcesContent":["import { observable } from './observable';\nimport type {\n  MonoTypeOperatorFunction,\n  Observer,\n  OperatorFunction,\n  Unsubscribable,\n} from './types';\n\nexport function map<TValueBefore, TError, TValueAfter>(\n  project: (value: TValueBefore, index: number) => TValueAfter,\n): OperatorFunction<TValueBefore, TError, TValueAfter, TError> {\n  return (source) => {\n    return observable((destination) => {\n      let index = 0;\n      const subscription = source.subscribe({\n        next(value) {\n          destination.next(project(value, index++));\n        },\n        error(error) {\n          destination.error(error);\n        },\n        complete() {\n          destination.complete();\n        },\n      });\n      return subscription;\n    });\n  };\n}\n\ninterface ShareConfig {}\nexport function share<TValue, TError>(\n  _opts?: ShareConfig,\n): MonoTypeOperatorFunction<TValue, TError> {\n  return (source) => {\n    let refCount = 0;\n\n    let subscription: Unsubscribable | null = null;\n    const observers: Partial<Observer<TValue, TError>>[] = [];\n\n    function startIfNeeded() {\n      if (subscription) {\n        return;\n      }\n      subscription = source.subscribe({\n        next(value) {\n          for (const observer of observers) {\n            observer.next?.(value);\n          }\n        },\n        error(error) {\n          for (const observer of observers) {\n            observer.error?.(error);\n          }\n        },\n        complete() {\n          for (const observer of observers) {\n            observer.complete?.();\n          }\n        },\n      });\n    }\n    function resetIfNeeded() {\n      // \"resetOnRefCountZero\"\n      if (refCount === 0 && subscription) {\n        const _sub = subscription;\n        subscription = null;\n        _sub.unsubscribe();\n      }\n    }\n\n    return observable((subscriber) => {\n      refCount++;\n\n      observers.push(subscriber);\n      startIfNeeded();\n      return {\n        unsubscribe() {\n          refCount--;\n          resetIfNeeded();\n\n          const index = observers.findIndex((v) => v === subscriber);\n\n          if (index > -1) {\n            observers.splice(index, 1);\n          }\n        },\n      };\n    });\n  };\n}\n\nexport function tap<TValue, TError>(\n  observer: Partial<Observer<TValue, TError>>,\n): MonoTypeOperatorFunction<TValue, TError> {\n  return (source) => {\n    return observable((destination) => {\n      return source.subscribe({\n        next(value) {\n          observer.next?.(value);\n          destination.next(value);\n        },\n        error(error) {\n          observer.error?.(error);\n          destination.error(error);\n        },\n        complete() {\n          observer.complete?.();\n          destination.complete();\n        },\n      });\n    });\n  };\n}\n\nconst distinctUnsetMarker = Symbol();\nexport function distinctUntilChanged<TValue, TError>(\n  compare: (a: TValue, b: TValue) => boolean = (a, b) => a === b,\n): MonoTypeOperatorFunction<TValue, TError> {\n  return (source) => {\n    return observable((destination) => {\n      let lastValue: TValue | typeof distinctUnsetMarker = distinctUnsetMarker;\n\n      return source.subscribe({\n        next(value) {\n          if (lastValue !== distinctUnsetMarker && compare(lastValue, value)) {\n            return;\n          }\n          lastValue = value;\n          destination.next(value);\n        },\n        error(error) {\n          destination.error(error);\n        },\n        complete() {\n          destination.complete();\n        },\n      });\n    });\n  };\n}\n\nconst isDeepEqual = <T>(a: T, b: T): boolean => {\n  if (a === b) {\n    return true;\n  }\n  const bothAreObjects =\n    a && b && typeof a === 'object' && typeof b === 'object';\n\n  return (\n    !!bothAreObjects &&\n    Object.keys(a).length === Object.keys(b).length &&\n    Object.entries(a).every(([k, v]) => isDeepEqual(v, b[k as keyof T]))\n  );\n};\nexport function distinctUntilDeepChanged<\n  TValue,\n  TError,\n>(): MonoTypeOperatorFunction<TValue, TError> {\n  return distinctUntilChanged(isDeepEqual);\n}\n","import { observable } from './observable';\nimport type { Observable, Observer } from './types';\n\nexport interface BehaviorSubject<TValue> extends Observable<TValue, never> {\n  observable: Observable<TValue, never>;\n  next: (value: TValue) => void;\n  get: () => TValue;\n}\n\nexport interface ReadonlyBehaviorSubject<TValue>\n  extends Omit<BehaviorSubject<TValue>, 'next'> {}\n\n/**\n * @internal\n * An observable that maintains and provides a \"current value\" to subscribers\n * @see https://www.learnrxjs.io/learn-rxjs/subjects/behaviorsubject\n */\nexport function behaviorSubject<TValue>(\n  initialValue: TValue,\n): BehaviorSubject<TValue> {\n  let value: TValue = initialValue;\n\n  const observerList: Observer<TValue, never>[] = [];\n\n  const addObserver = (observer: Observer<TValue, never>) => {\n    if (value !== undefined) {\n      observer.next(value);\n    }\n    observerList.push(observer);\n  };\n  const removeObserver = (observer: Observer<TValue, never>) => {\n    observerList.splice(observerList.indexOf(observer), 1);\n  };\n\n  const obs = observable<TValue, never>((observer) => {\n    addObserver(observer);\n    return () => {\n      removeObserver(observer);\n    };\n  }) as BehaviorSubject<TValue>;\n\n  obs.next = (nextValue: TValue) => {\n    if (value === nextValue) {\n      return;\n    }\n    value = nextValue;\n    for (const observer of observerList) {\n      observer.next(nextValue);\n    }\n  };\n\n  obs.get = () => value;\n\n  return obs;\n}\n"],"names":["project: (value: TValueBefore, index: number) => TValueAfter","_opts?: ShareConfig","subscription: Unsubscribable | null","observers: Partial<Observer<TValue, TError>>[]","observer: Partial<Observer<TValue, TError>>","compare: (a: TValue, b: TValue) => boolean","lastValue: TValue | typeof distinctUnsetMarker","a: T","b: T","initialValue: TValue","value: TValue","observerList: Observer<TValue, never>[]","observer: Observer<TValue, never>","nextValue: TValue"],"mappings":"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","ignoreList":[0,1],"debugId":null}},
    {"offset": {"line": 2266, "column": 0}, "map": {"version":3,"file":"loggerLink-ineCN1PO.mjs","sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/client/src/links/loggerLink.ts"],"sourcesContent":["/// <reference lib=\"dom.iterable\" />\n\n// `dom.iterable` types are explicitly required for extracting `FormData` values,\n// as all implementations of `Symbol.iterable` are separated from the main `dom` types.\n// Using triple-slash directive makes sure that it will be available,\n// even if end-user `tsconfig.json` omits it in the `lib` array.\n\nimport { observable, tap } from '@trpc/server/observable';\nimport type {\n  AnyRouter,\n  InferrableClientTypes,\n} from '@trpc/server/unstable-core-do-not-import';\nimport type { TRPCClientError } from '../TRPCClientError';\nimport type { Operation, OperationResultEnvelope, TRPCLink } from './types';\n\ntype ConsoleEsque = {\n  log: (...args: any[]) => void;\n  error: (...args: any[]) => void;\n};\n\ntype EnableFnOptions<TRouter extends InferrableClientTypes> =\n  | {\n      direction: 'down';\n      result:\n        | OperationResultEnvelope<unknown, TRPCClientError<TRouter>>\n        | TRPCClientError<TRouter>;\n    }\n  | (Operation & {\n      direction: 'up';\n    });\ntype EnabledFn<TRouter extends AnyRouter> = (\n  opts: EnableFnOptions<TRouter>,\n) => boolean;\n\ntype LoggerLinkFnOptions<TRouter extends AnyRouter> = Operation &\n  (\n    | {\n        /**\n         * Request result\n         */\n        direction: 'down';\n        result:\n          | OperationResultEnvelope<unknown, TRPCClientError<TRouter>>\n          | TRPCClientError<TRouter>;\n        elapsedMs: number;\n      }\n    | {\n        /**\n         * Request was just initialized\n         */\n        direction: 'up';\n      }\n  );\n\ntype LoggerLinkFn<TRouter extends AnyRouter> = (\n  opts: LoggerLinkFnOptions<TRouter>,\n) => void;\n\ntype ColorMode = 'ansi' | 'css' | 'none';\n\nexport interface LoggerLinkOptions<TRouter extends AnyRouter> {\n  logger?: LoggerLinkFn<TRouter>;\n  enabled?: EnabledFn<TRouter>;\n  /**\n   * Used in the built-in defaultLogger\n   */\n  console?: ConsoleEsque;\n  /**\n   * Color mode\n   * @default typeof window === 'undefined' ? 'ansi' : 'css'\n   */\n  colorMode?: ColorMode;\n\n  /**\n   * Include context in the log - defaults to false unless `colorMode` is 'css'\n   */\n  withContext?: boolean;\n}\n\nfunction isFormData(value: unknown): value is FormData {\n  if (typeof FormData === 'undefined') {\n    // FormData is not supported\n    return false;\n  }\n  return value instanceof FormData;\n}\n\nconst palettes = {\n  css: {\n    query: ['72e3ff', '3fb0d8'],\n    mutation: ['c5a3fc', '904dfc'],\n    subscription: ['ff49e1', 'd83fbe'],\n  },\n  ansi: {\n    regular: {\n      // Cyan background, black and white text respectively\n      query: ['\\x1b[30;46m', '\\x1b[97;46m'],\n      // Magenta background, black and white text respectively\n      mutation: ['\\x1b[30;45m', '\\x1b[97;45m'],\n      // Green background, black and white text respectively\n      subscription: ['\\x1b[30;42m', '\\x1b[97;42m'],\n    },\n    bold: {\n      query: ['\\x1b[1;30;46m', '\\x1b[1;97;46m'],\n      mutation: ['\\x1b[1;30;45m', '\\x1b[1;97;45m'],\n      subscription: ['\\x1b[1;30;42m', '\\x1b[1;97;42m'],\n    },\n  },\n} as const;\n\nfunction constructPartsAndArgs(\n  opts: LoggerLinkFnOptions<any> & {\n    colorMode: ColorMode;\n    withContext?: boolean;\n  },\n) {\n  const { direction, type, withContext, path, id, input } = opts;\n\n  const parts: string[] = [];\n  const args: any[] = [];\n\n  if (opts.colorMode === 'none') {\n    parts.push(direction === 'up' ? '>>' : '<<', type, `#${id}`, path);\n  } else if (opts.colorMode === 'ansi') {\n    const [lightRegular, darkRegular] = palettes.ansi.regular[type];\n    const [lightBold, darkBold] = palettes.ansi.bold[type];\n    const reset = '\\x1b[0m';\n\n    parts.push(\n      direction === 'up' ? lightRegular : darkRegular,\n      direction === 'up' ? '>>' : '<<',\n      type,\n      direction === 'up' ? lightBold : darkBold,\n      `#${id}`,\n      path,\n      reset,\n    );\n  } else {\n    // css color mode\n    const [light, dark] = palettes.css[type];\n    const css = `\n    background-color: #${direction === 'up' ? light : dark};\n    color: ${direction === 'up' ? 'black' : 'white'};\n    padding: 2px;\n  `;\n\n    parts.push(\n      '%c',\n      direction === 'up' ? '>>' : '<<',\n      type,\n      `#${id}`,\n      `%c${path}%c`,\n      '%O',\n    );\n    args.push(\n      css,\n      `${css}; font-weight: bold;`,\n      `${css}; font-weight: normal;`,\n    );\n  }\n\n  if (direction === 'up') {\n    args.push(withContext ? { input, context: opts.context } : { input });\n  } else {\n    args.push({\n      input,\n      result: opts.result,\n      elapsedMs: opts.elapsedMs,\n      ...(withContext && { context: opts.context }),\n    });\n  }\n\n  return { parts, args };\n}\n\n// maybe this should be moved to it's own package\nconst defaultLogger =\n  <TRouter extends AnyRouter>({\n    c = console,\n    colorMode = 'css',\n    withContext,\n  }: {\n    c?: ConsoleEsque;\n    colorMode?: ColorMode;\n    withContext?: boolean;\n  }): LoggerLinkFn<TRouter> =>\n  (props) => {\n    const rawInput = props.input;\n    const input = isFormData(rawInput)\n      ? Object.fromEntries(rawInput)\n      : rawInput;\n\n    const { parts, args } = constructPartsAndArgs({\n      ...props,\n      colorMode,\n      input,\n      withContext,\n    });\n\n    const fn: 'error' | 'log' =\n      props.direction === 'down' &&\n      props.result &&\n      (props.result instanceof Error ||\n        ('error' in props.result.result && props.result.result.error))\n        ? 'error'\n        : 'log';\n\n    c[fn].apply(null, [parts.join(' ')].concat(args));\n  };\n\n/**\n * @see https://trpc.io/docs/v11/client/links/loggerLink\n */\nexport function loggerLink<TRouter extends AnyRouter = AnyRouter>(\n  opts: LoggerLinkOptions<TRouter> = {},\n): TRPCLink<TRouter> {\n  const { enabled = () => true } = opts;\n\n  const colorMode =\n    opts.colorMode ?? (typeof window === 'undefined' ? 'ansi' : 'css');\n  const withContext = opts.withContext ?? colorMode === 'css';\n  const {\n    logger = defaultLogger({ c: opts.console, colorMode, withContext }),\n  } = opts;\n\n  return () => {\n    return ({ op, next }) => {\n      return observable((observer) => {\n        // ->\n        if (enabled({ ...op, direction: 'up' })) {\n          logger({\n            ...op,\n            direction: 'up',\n          });\n        }\n        const requestStartTime = Date.now();\n        function logResult(\n          result:\n            | OperationResultEnvelope<unknown, TRPCClientError<TRouter>>\n            | TRPCClientError<TRouter>,\n        ) {\n          const elapsedMs = Date.now() - requestStartTime;\n\n          if (enabled({ ...op, direction: 'down', result })) {\n            logger({\n              ...op,\n              direction: 'down',\n              elapsedMs,\n              result,\n            });\n          }\n        }\n        return next(op)\n          .pipe(\n            tap({\n              next(result) {\n                logResult(result);\n              },\n              error(result) {\n                logResult(result);\n              },\n            }),\n          )\n          .subscribe(observer);\n      });\n    };\n  };\n}\n"],"names":["value: unknown","opts: LoggerLinkFnOptions<any> & {\n    colorMode: ColorMode;\n    withContext?: boolean;\n  }","parts: string[]","args: any[]","fn: 'error' | 'log'","opts: LoggerLinkOptions<TRouter>","result:\n            | OperationResultEnvelope<unknown, TRPCClientError<TRouter>>\n            | TRPCClientError<TRouter>"],"mappings":";;;;;;;;;;AA+EA,SAAS,WAAWA,KAAAA,EAAmC;IACrD,IAAA,OAAW,aAAa,YAEtB,CAAA,OAAO;IAET,OAAO,iBAAiB;AACzB;AAED,MAAM,WAAW;IACf,KAAK;QACH,OAAO;YAAC;YAAU,QAAS;SAAA;QAC3B,UAAU;YAAC;YAAU,QAAS;SAAA;QAC9B,cAAc;YAAC;YAAU,QAAS;SAAA;IACnC;IACD,MAAM;QACJ,SAAS;YAEP,OAAO;gBAAC;gBAAe,aAAc;aAAA;YAErC,UAAU;gBAAC;gBAAe,aAAc;aAAA;YAExC,cAAc;gBAAC;gBAAe,aAAc;aAAA;QAC7C;QACD,MAAM;YACJ,OAAO;gBAAC;gBAAiB,eAAgB;aAAA;YACzC,UAAU;gBAAC;gBAAiB,eAAgB;aAAA;YAC5C,cAAc;gBAAC;gBAAiB,eAAgB;aAAA;QACjD;IACF;AACF;AAED,SAAS,sBACPC,IAAAA,EAIA;IACA,MAAM,EAAE,SAAA,EAAW,IAAA,EAAM,WAAA,EAAa,IAAA,EAAM,EAAA,EAAI,KAAA,EAAO,GAAG;IAE1D,MAAMC,QAAkB,CAAE,CAAA;IAC1B,MAAMC,OAAc,CAAE,CAAA;IAEtB,IAAI,KAAK,SAAA,KAAc,OACrB,CAAA,MAAM,IAAA,CAAK,cAAc,OAAO,OAAO,MAAM,MAAA,CAAO,CAAA,EAAG,GAAG,CAAA,EAAG,KAAK;aACzD,KAAK,SAAA,KAAc,QAAQ;QACpC,MAAM,CAAC,cAAc,YAAY,GAAG,SAAS,IAAA,CAAK,OAAA,CAAQ,KAAA;QAC1D,MAAM,CAAC,WAAW,SAAS,GAAG,SAAS,IAAA,CAAK,IAAA,CAAK,KAAA;QACjD,MAAM,QAAQ;QAEd,MAAM,IAAA,CACJ,cAAc,OAAO,eAAe,aACpC,cAAc,OAAO,OAAO,MAC5B,MACA,cAAc,OAAO,YAAY,UAAA,CAChC,CAAA,EAAG,GAAG,CAAA,EACP,MACA,MACD;IACF,OAAM;QAEL,MAAM,CAAC,OAAO,KAAK,GAAG,SAAS,GAAA,CAAI,KAAA;QACnC,MAAM,MAAA,CAAO;yBACQ,cAAc,OAAO,QAAQ,KAAK;aAC9C,cAAc,OAAO,UAAU,QAAQ;;;QAIhD,MAAM,IAAA,CACJ,MACA,cAAc,OAAO,OAAO,MAC5B,MAAA,CACC,CAAA,EAAG,GAAG,CAAA,EAAA,CACN,EAAA,EAAI,KAAK,EAAA,CAAA,EACV,KACD;QACD,KAAK,IAAA,CACH,KAAA,CACC,EAAE,IAAI,oBAAA,CAAA,EAAA,CACN,EAAE,IAAI,sBAAA,CAAA,CACR;IACF;IAED,IAAI,cAAc,KAChB,CAAA,KAAK,IAAA,CAAK,cAAc;QAAE;QAAO,SAAS,KAAK,OAAA;IAAS,IAAG;QAAE;IAAO,EAAC;SAErE,KAAK,IAAA,CAAA,CAAA,GAAA,qBAAA,OAAA,EAAA;QACH;QACA,QAAQ,KAAK,MAAA;QACb,WAAW,KAAK,SAAA;OACZ,eAAe;QAAE,SAAS,KAAK,OAAA;IAAS,GAC5C;IAGJ,OAAO;QAAE;QAAO;IAAM;AACvB;AAGD,MAAM,gBACJ,CAA4B,EAC1B,IAAI,OAAA,EACJ,YAAY,KAAA,EACZ,WAAA,EAKD,GACD,CAAC,UAAU;QACT,MAAM,WAAW,MAAM,KAAA;QACvB,MAAM,QAAQ,WAAW,SAAS,GAC9B,OAAO,WAAA,CAAY,SAAS,GAC5B;QAEJ,MAAM,EAAE,KAAA,EAAO,IAAA,EAAM,GAAG,sBAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GACnB,QAAA,CAAA,GAAA;YACH;YACA;YACA;WACA;QAEF,MAAMC,KACJ,MAAM,SAAA,KAAc,UACpB,MAAM,MAAA,IAAA,CACL,MAAM,MAAA,YAAkB,SACtB,WAAW,MAAM,MAAA,CAAO,MAAA,IAAU,MAAM,MAAA,CAAO,MAAA,CAAO,KAAA,IACrD,UACA;QAEN,CAAA,CAAE,GAAA,CAAI,KAAA,CAAM,MAAM;YAAC,MAAM,IAAA,CAAK,IAAI,AAAC;SAAA,CAAC,MAAA,CAAO,KAAK,CAAC;IAClD;;;GAKH,SAAgB,WACdC,OAAmC,CAAE,CAAA,EAClB;;IACnB,MAAM,EAAE,UAAU,IAAM,IAAA,EAAM,GAAG;IAEjC,MAAM,YAAA,CAAA,kBACJ,KAAK,SAAA,MAAA,QAAA,oBAAA,KAAA,IAAA,kBAAA,OAAqB,WAAW,cAAc,SAAS;IAC9D,MAAM,cAAA,CAAA,oBAAc,KAAK,WAAA,MAAA,QAAA,sBAAA,KAAA,IAAA,oBAAe,cAAc;IACtD,MAAM,EACJ,SAAS,cAAc;QAAE,GAAG,KAAK,OAAA;QAAS;QAAW;IAAa,EAAC,EACpE,GAAG;IAEJ,OAAO,MAAM;QACX,OAAO,CAAC,EAAE,EAAA,EAAI,IAAA,EAAM,KAAK;YACvB,kLAAO,aAAA,EAAW,CAAC,aAAa;gBAE9B,IAAI,QAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAa,KAAA,CAAA,GAAA;oBAAI,WAAW;gBAAA,GAAO,CACrC,CAAA,OAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GACK,KAAA,CAAA,GAAA;oBACH,WAAW;gBAAA,GACX;gBAEJ,MAAM,mBAAmB,KAAK,GAAA,EAAK;gBACnC,SAAS,UACPC,MAAAA,EAGA;oBACA,MAAM,YAAY,KAAK,GAAA,EAAK,GAAG;oBAE/B,IAAI,QAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAa,KAAA,CAAA,GAAA;wBAAI,WAAW;wBAAQ;uBAAS,CAC/C,CAAA,OAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GACK,KAAA,CAAA,GAAA;wBACH,WAAW;wBACX;wBACA;uBACA;gBAEL;gBACD,OAAO,KAAK,GAAG,CACZ,IAAA,6KACC,MAAA,EAAI;oBACF,MAAK,MAAA,EAAQ;wBACX,UAAU,OAAO;oBAClB;oBACD,OAAM,MAAA,EAAQ;wBACZ,UAAU,OAAO;oBAClB;gBACF,EAAC,CACH,CACA,SAAA,CAAU,SAAS;YACvB,EAAC;QACH;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2429, "column": 0}, "map": {"version":3,"file":"wsLink-H5IjZfJW.mjs","sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/client/src/links/wsLink/wsClient/options.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/client/src/links/internals/urlWithConnectionParams.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/client/src/links/wsLink/wsClient/utils.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/client/src/links/wsLink/wsClient/requestManager.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/client/src/links/wsLink/wsClient/wsConnection.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/client/src/links/wsLink/wsClient/wsClient.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/client/src/links/wsLink/createWsClient.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/client/src/links/wsLink/wsLink.ts"],"sourcesContent":["import type { UrlOptionsWithConnectionParams } from '../../internals/urlWithConnectionParams';\n\nexport interface WebSocketClientOptions extends UrlOptionsWithConnectionParams {\n  /**\n   * Ponyfill which WebSocket implementation to use\n   */\n  WebSocket?: typeof WebSocket;\n  /**\n   * The number of milliseconds before a reconnect is attempted.\n   * @default {@link exponentialBackoff}\n   */\n  retryDelayMs?: (attemptIndex: number) => number;\n  /**\n   * Triggered when a WebSocket connection is established\n   */\n  onOpen?: () => void;\n  /**\n   * Triggered when a WebSocket connection encounters an error\n   */\n  onError?: (evt?: Event) => void;\n  /**\n   * Triggered when a WebSocket connection is closed\n   */\n  onClose?: (cause?: { code?: number }) => void;\n  /**\n   * Lazy mode will close the WebSocket automatically after a period of inactivity (no messages sent or received and no pending requests)\n   */\n  lazy?: {\n    /**\n     * Enable lazy mode\n     * @default false\n     */\n    enabled: boolean;\n    /**\n     * Close the WebSocket after this many milliseconds\n     * @default 0\n     */\n    closeMs: number;\n  };\n  /**\n   * Send ping messages to the server and kill the connection if no pong message is returned\n   */\n  keepAlive?: {\n    /**\n     * @default false\n     */\n    enabled: boolean;\n    /**\n     * Send a ping message every this many milliseconds\n     * @default 5_000\n     */\n    intervalMs?: number;\n    /**\n     * Close the WebSocket after this many milliseconds if the server does not respond\n     * @default 1_000\n     */\n    pongTimeoutMs?: number;\n  };\n}\n\n/**\n * Default options for lazy WebSocket connections.\n * Determines whether the connection should be established lazily and defines the delay before closure.\n */\nexport type LazyOptions = Required<NonNullable<WebSocketClientOptions['lazy']>>;\nexport const lazyDefaults: LazyOptions = {\n  enabled: false,\n  closeMs: 0,\n};\n\n/**\n * Default options for the WebSocket keep-alive mechanism.\n * Configures whether keep-alive is enabled and specifies the timeout and interval for ping-pong messages.\n */\nexport type KeepAliveOptions = Required<\n  NonNullable<WebSocketClientOptions['keepAlive']>\n>;\nexport const keepAliveDefaults: KeepAliveOptions = {\n  enabled: false,\n  pongTimeoutMs: 1_000,\n  intervalMs: 5_000,\n};\n\n/**\n * Calculates a delay for exponential backoff based on the retry attempt index.\n * The delay starts at 0 for the first attempt and doubles for each subsequent attempt,\n * capped at 30 seconds.\n */\nexport const exponentialBackoff = (attemptIndex: number) => {\n  return attemptIndex === 0 ? 0 : Math.min(1000 * 2 ** attemptIndex, 30000);\n};\n","import { type TRPCRequestInfo } from '@trpc/server/http';\n\n/**\n * Get the result of a value or function that returns a value\n * It also optionally accepts typesafe arguments for the function\n */\nexport const resultOf = <T, TArgs extends any[]>(\n  value: T | ((...args: TArgs) => T),\n  ...args: TArgs\n): T => {\n  return typeof value === 'function'\n    ? (value as (...args: TArgs) => T)(...args)\n    : value;\n};\n\n/**\n * A value that can be wrapped in callback\n */\nexport type CallbackOrValue<T> = T | (() => T | Promise<T>);\n\nexport interface UrlOptionsWithConnectionParams {\n  /**\n   * The URL to connect to (can be a function that returns a URL)\n   */\n  url: CallbackOrValue<string>;\n\n  /**\n   * Connection params that are available in `createContext()`\n   * - For `wsLink`/`wsClient`, these are sent as the first message\n   * - For `httpSubscriptionLink`, these are serialized as part of the URL under the `connectionParams` query\n   */\n  connectionParams?: CallbackOrValue<TRPCRequestInfo['connectionParams']>;\n}\n","import type {\n  TRPCConnectionParamsMessage,\n  TRPCRequestInfo,\n} from '@trpc/server/unstable-core-do-not-import';\nimport type {\n  CallbackOrValue,\n  UrlOptionsWithConnectionParams,\n} from '../../internals/urlWithConnectionParams';\nimport { resultOf } from '../../internals/urlWithConnectionParams';\n\nexport class TRPCWebSocketClosedError extends Error {\n  constructor(opts: { message: string; cause?: unknown }) {\n    super(opts.message, {\n      cause: opts.cause,\n    });\n    this.name = 'TRPCWebSocketClosedError';\n    Object.setPrototypeOf(this, TRPCWebSocketClosedError.prototype);\n  }\n}\n\n/**\n * Utility class for managing a timeout that can be started, stopped, and reset.\n * Useful for scenarios where the timeout duration is reset dynamically based on events.\n */\nexport class ResettableTimeout {\n  private timeout: ReturnType<typeof setTimeout> | undefined;\n\n  constructor(\n    private readonly onTimeout: () => void,\n    private readonly timeoutMs: number,\n  ) {}\n\n  /**\n   * Resets the current timeout, restarting it with the same duration.\n   * Does nothing if no timeout is active.\n   */\n  public reset() {\n    if (!this.timeout) return;\n\n    clearTimeout(this.timeout);\n    this.timeout = setTimeout(this.onTimeout, this.timeoutMs);\n  }\n\n  public start() {\n    clearTimeout(this.timeout);\n    this.timeout = setTimeout(this.onTimeout, this.timeoutMs);\n  }\n\n  public stop() {\n    clearTimeout(this.timeout);\n    this.timeout = undefined;\n  }\n}\n\n// Ponyfill for Promise.withResolvers https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/withResolvers\nexport function withResolvers<T>() {\n  let resolve: (value: T | PromiseLike<T>) => void;\n  let reject: (reason?: any) => void;\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  return { promise, resolve: resolve!, reject: reject! };\n}\n\n/**\n * Resolves a WebSocket URL and optionally appends connection parameters.\n *\n * If connectionParams are provided, appends 'connectionParams=1' query parameter.\n */\nexport async function prepareUrl(urlOptions: UrlOptionsWithConnectionParams) {\n  const url = await resultOf(urlOptions.url);\n\n  if (!urlOptions.connectionParams) return url;\n\n  // append `?connectionParams=1` when connection params are used\n  const prefix = url.includes('?') ? '&' : '?';\n  const connectionParams = `${prefix}connectionParams=1`;\n\n  return url + connectionParams;\n}\n\nexport async function buildConnectionMessage(\n  connectionParams: CallbackOrValue<TRPCRequestInfo['connectionParams']>,\n) {\n  const message: TRPCConnectionParamsMessage = {\n    method: 'connectionParams',\n    data: await resultOf(connectionParams),\n  };\n\n  return JSON.stringify(message);\n}\n","import type { AnyTRPCRouter, inferRouterError } from '@trpc/server';\nimport type { Observer } from '@trpc/server/observable';\nimport type {\n  TRPCClientOutgoingMessage,\n  TRPCResponseMessage,\n} from '@trpc/server/unstable-core-do-not-import';\nimport type { TRPCClientError } from '../../../TRPCClientError';\nimport { withResolvers } from './utils';\n\nexport type TCallbacks = Observer<\n  TRPCResponseMessage<unknown, inferRouterError<AnyTRPCRouter>>,\n  TRPCClientError<AnyTRPCRouter>\n>;\n\ntype MessageId = string;\ntype MessageIdLike = string | number | null;\n\n/**\n * Represents a WebSocket request managed by the RequestManager.\n * Combines the network message, a utility promise (`end`) that mirrors the lifecycle\n * handled by `callbacks`, and a set of state monitoring callbacks.\n */\ninterface Request {\n  message: TRPCClientOutgoingMessage;\n  end: Promise<void>;\n  callbacks: TCallbacks;\n}\n\n/**\n * Manages WebSocket requests, tracking their lifecycle and providing utility methods\n * for handling outgoing and pending requests.\n *\n * - **Outgoing requests**: Requests that are queued and waiting to be sent.\n * - **Pending requests**: Requests that have been sent and are in flight awaiting a response.\n *   For subscriptions, multiple responses may be received until the subscription is closed.\n */\nexport class RequestManager {\n  /**\n   * Stores requests that are outgoing, meaning they are registered but not yet sent over the WebSocket.\n   */\n  private outgoingRequests = new Array<Request & { id: MessageId }>();\n\n  /**\n   * Stores requests that are pending (in flight), meaning they have been sent over the WebSocket\n   * and are awaiting responses. For subscriptions, this includes requests\n   * that may receive multiple responses.\n   */\n  private pendingRequests: Record<MessageId, Request> = {};\n\n  /**\n   * Registers a new request by adding it to the outgoing queue and setting up\n   * callbacks for lifecycle events such as completion or error.\n   *\n   * @param message - The outgoing message to be sent.\n   * @param callbacks - Callback functions to observe the request's state.\n   * @returns A cleanup function to manually remove the request.\n   */\n  public register(message: TRPCClientOutgoingMessage, callbacks: TCallbacks) {\n    const { promise: end, resolve } = withResolvers<void>();\n\n    this.outgoingRequests.push({\n      id: String(message.id),\n      message,\n      end,\n      callbacks: {\n        next: callbacks.next,\n        complete: () => {\n          callbacks.complete();\n          resolve();\n        },\n        error: (e) => {\n          callbacks.error(e);\n          resolve();\n        },\n      },\n    });\n\n    return () => {\n      this.delete(message.id);\n      callbacks.complete();\n      resolve();\n    };\n  }\n\n  /**\n   * Deletes a request from both the outgoing and pending collections, if it exists.\n   */\n  public delete(messageId: MessageIdLike) {\n    if (messageId === null) return;\n\n    this.outgoingRequests = this.outgoingRequests.filter(\n      ({ id }) => id !== String(messageId),\n    );\n    delete this.pendingRequests[String(messageId)];\n  }\n\n  /**\n   * Moves all outgoing requests to the pending state and clears the outgoing queue.\n   *\n   * The caller is expected to handle the actual sending of the requests\n   * (e.g., sending them over the network) after this method is called.\n   *\n   * @returns The list of requests that were transitioned to the pending state.\n   */\n  public flush() {\n    const requests = this.outgoingRequests;\n    this.outgoingRequests = [];\n\n    for (const request of requests) {\n      this.pendingRequests[request.id] = request;\n    }\n    return requests;\n  }\n\n  /**\n   * Retrieves all currently pending requests, which are in flight awaiting responses\n   * or handling ongoing subscriptions.\n   */\n  public getPendingRequests() {\n    return Object.values(this.pendingRequests);\n  }\n\n  /**\n   * Retrieves a specific pending request by its message ID.\n   */\n  public getPendingRequest(messageId: MessageIdLike) {\n    if (messageId === null) return null;\n\n    return this.pendingRequests[String(messageId)];\n  }\n\n  /**\n   * Retrieves all outgoing requests, which are waiting to be sent.\n   */\n  public getOutgoingRequests() {\n    return this.outgoingRequests;\n  }\n\n  /**\n   * Retrieves all requests, both outgoing and pending, with their respective states.\n   *\n   * @returns An array of all requests with their state (\"outgoing\" or \"pending\").\n   */\n  public getRequests() {\n    return [\n      ...this.getOutgoingRequests().map((request) => ({\n        state: 'outgoing' as const,\n        message: request.message,\n        end: request.end,\n        callbacks: request.callbacks,\n      })),\n      ...this.getPendingRequests().map((request) => ({\n        state: 'pending' as const,\n        message: request.message,\n        end: request.end,\n        callbacks: request.callbacks,\n      })),\n    ];\n  }\n\n  /**\n   * Checks if there are any pending requests, including ongoing subscriptions.\n   */\n  public hasPendingRequests() {\n    return this.getPendingRequests().length > 0;\n  }\n\n  /**\n   * Checks if there are any pending subscriptions\n   */\n  public hasPendingSubscriptions() {\n    return this.getPendingRequests().some(\n      (request) => request.message.method === 'subscription',\n    );\n  }\n\n  /**\n   * Checks if there are any outgoing requests waiting to be sent.\n   */\n  public hasOutgoingRequests() {\n    return this.outgoingRequests.length > 0;\n  }\n}\n","import { behaviorSubject } from '@trpc/server/observable';\nimport type { UrlOptionsWithConnectionParams } from '../../internals/urlWithConnectionParams';\nimport { buildConnectionMessage, prepareUrl, withResolvers } from './utils';\n\n/**\n * Opens a WebSocket connection asynchronously and returns a promise\n * that resolves when the connection is successfully established.\n * The promise rejects if an error occurs during the connection attempt.\n */\nfunction asyncWsOpen(ws: WebSocket) {\n  const { promise, resolve, reject } = withResolvers<void>();\n\n  ws.addEventListener('open', () => {\n    ws.removeEventListener('error', reject);\n    resolve();\n  });\n  ws.addEventListener('error', reject);\n\n  return promise;\n}\n\ninterface PingPongOptions {\n  /**\n   * The interval (in milliseconds) between \"PING\" messages.\n   */\n  intervalMs: number;\n\n  /**\n   * The timeout (in milliseconds) to wait for a \"PONG\" response before closing the connection.\n   */\n  pongTimeoutMs: number;\n}\n\n/**\n * Sets up a periodic ping-pong mechanism to keep the WebSocket connection alive.\n *\n * - Sends \"PING\" messages at regular intervals defined by `intervalMs`.\n * - If a \"PONG\" response is not received within the `pongTimeoutMs`, the WebSocket is closed.\n * - The ping timer resets upon receiving any message to maintain activity.\n * - Automatically starts the ping process when the WebSocket connection is opened.\n * - Cleans up timers when the WebSocket is closed.\n *\n * @param ws - The WebSocket instance to manage.\n * @param options - Configuration options for ping-pong intervals and timeouts.\n */\nfunction setupPingInterval(\n  ws: WebSocket,\n  { intervalMs, pongTimeoutMs }: PingPongOptions,\n) {\n  let pingTimeout: ReturnType<typeof setTimeout> | undefined;\n  let pongTimeout: ReturnType<typeof setTimeout> | undefined;\n\n  function start() {\n    pingTimeout = setTimeout(() => {\n      ws.send('PING');\n      pongTimeout = setTimeout(() => {\n        ws.close();\n      }, pongTimeoutMs);\n    }, intervalMs);\n  }\n\n  function reset() {\n    clearTimeout(pingTimeout);\n    start();\n  }\n\n  function pong() {\n    clearTimeout(pongTimeout);\n    reset();\n  }\n\n  ws.addEventListener('open', start);\n  ws.addEventListener('message', ({ data }) => {\n    clearTimeout(pingTimeout);\n    start();\n\n    if (data === 'PONG') {\n      pong();\n    }\n  });\n  ws.addEventListener('close', () => {\n    clearTimeout(pingTimeout);\n    clearTimeout(pongTimeout);\n  });\n}\n\nexport interface WebSocketConnectionOptions {\n  WebSocketPonyfill?: typeof WebSocket;\n  urlOptions: UrlOptionsWithConnectionParams;\n  keepAlive: PingPongOptions & {\n    enabled: boolean;\n  };\n}\n\n/**\n * Manages a WebSocket connection with support for reconnection, keep-alive mechanisms,\n * and observable state tracking.\n */\nexport class WsConnection {\n  static connectCount = 0;\n  public id = ++WsConnection.connectCount;\n\n  private readonly WebSocketPonyfill: typeof WebSocket;\n  private readonly urlOptions: UrlOptionsWithConnectionParams;\n  private readonly keepAliveOpts: WebSocketConnectionOptions['keepAlive'];\n  public readonly wsObservable = behaviorSubject<WebSocket | null>(null);\n\n  constructor(opts: WebSocketConnectionOptions) {\n    this.WebSocketPonyfill = opts.WebSocketPonyfill ?? WebSocket;\n    if (!this.WebSocketPonyfill) {\n      throw new Error(\n        \"No WebSocket implementation found - you probably don't want to use this on the server, but if you do you need to pass a `WebSocket`-ponyfill\",\n      );\n    }\n\n    this.urlOptions = opts.urlOptions;\n    this.keepAliveOpts = opts.keepAlive;\n  }\n\n  public get ws() {\n    return this.wsObservable.get();\n  }\n\n  private set ws(ws) {\n    this.wsObservable.next(ws);\n  }\n\n  /**\n   * Checks if the WebSocket connection is open and ready to communicate.\n   */\n  public isOpen(): this is { ws: WebSocket } {\n    return (\n      !!this.ws &&\n      this.ws.readyState === this.WebSocketPonyfill.OPEN &&\n      !this.openPromise\n    );\n  }\n\n  /**\n   * Checks if the WebSocket connection is closed or in the process of closing.\n   */\n  public isClosed(): this is { ws: WebSocket } {\n    return (\n      !!this.ws &&\n      (this.ws.readyState === this.WebSocketPonyfill.CLOSING ||\n        this.ws.readyState === this.WebSocketPonyfill.CLOSED)\n    );\n  }\n\n  /**\n   * Manages the WebSocket opening process, ensuring that only one open operation\n   * occurs at a time. Tracks the ongoing operation with `openPromise` to avoid\n   * redundant calls and ensure proper synchronization.\n   *\n   * Sets up the keep-alive mechanism and necessary event listeners for the connection.\n   *\n   * @returns A promise that resolves once the WebSocket connection is successfully opened.\n   */\n  private openPromise: Promise<void> | null = null;\n  public async open() {\n    if (this.openPromise) return this.openPromise;\n\n    this.id = ++WsConnection.connectCount;\n    const wsPromise = prepareUrl(this.urlOptions).then(\n      (url) => new this.WebSocketPonyfill(url),\n    );\n    this.openPromise = wsPromise.then(async (ws) => {\n      this.ws = ws;\n\n      // Setup ping listener\n      ws.addEventListener('message', function ({ data }) {\n        if (data === 'PING') {\n          this.send('PONG');\n        }\n      });\n\n      if (this.keepAliveOpts.enabled) {\n        setupPingInterval(ws, this.keepAliveOpts);\n      }\n\n      ws.addEventListener('close', () => {\n        if (this.ws === ws) {\n          this.ws = null;\n        }\n      });\n\n      await asyncWsOpen(ws);\n\n      if (this.urlOptions.connectionParams) {\n        ws.send(await buildConnectionMessage(this.urlOptions.connectionParams));\n      }\n    });\n\n    try {\n      await this.openPromise;\n    } finally {\n      this.openPromise = null;\n    }\n  }\n\n  /**\n   * Closes the WebSocket connection gracefully.\n   * Waits for any ongoing open operation to complete before closing.\n   */\n  public async close() {\n    try {\n      await this.openPromise;\n    } finally {\n      this.ws?.close();\n    }\n  }\n}\n\n/**\n * Provides a backward-compatible representation of the connection state.\n */\nexport function backwardCompatibility(connection: WsConnection) {\n  if (connection.isOpen()) {\n    return {\n      id: connection.id,\n      state: 'open',\n      ws: connection.ws,\n    } as const;\n  }\n\n  if (connection.isClosed()) {\n    return {\n      id: connection.id,\n      state: 'closed',\n      ws: connection.ws,\n    } as const;\n  }\n\n  if (!connection.ws) {\n    return null;\n  }\n\n  return {\n    id: connection.id,\n    state: 'connecting',\n    ws: connection.ws,\n  } as const;\n}\n","import type { AnyTRPCRouter } from '@trpc/server';\nimport type { BehaviorSubject } from '@trpc/server/observable';\nimport { behaviorSubject, observable } from '@trpc/server/observable';\nimport type {\n  CombinedDataTransformer,\n  TRPCClientIncomingMessage,\n  TRPCClientIncomingRequest,\n  TRPCClientOutgoingMessage,\n  TRPCResponseMessage,\n} from '@trpc/server/unstable-core-do-not-import';\nimport {\n  run,\n  sleep,\n  transformResult,\n} from '@trpc/server/unstable-core-do-not-import';\nimport { TRPCClientError } from '../../../TRPCClientError';\nimport type { TRPCConnectionState } from '../../internals/subscriptions';\nimport type { Operation, OperationResultEnvelope } from '../../types';\nimport type { WebSocketClientOptions } from './options';\nimport { exponentialBackoff, keepAliveDefaults, lazyDefaults } from './options';\nimport type { TCallbacks } from './requestManager';\nimport { RequestManager } from './requestManager';\nimport { ResettableTimeout, TRPCWebSocketClosedError } from './utils';\nimport { backwardCompatibility, WsConnection } from './wsConnection';\n\n/**\n * A WebSocket client for managing TRPC operations, supporting lazy initialization,\n * reconnection, keep-alive, and request management.\n */\nexport class WsClient {\n  /**\n   * Observable tracking the current connection state, including errors.\n   */\n  public readonly connectionState: BehaviorSubject<\n    TRPCConnectionState<TRPCClientError<AnyTRPCRouter>>\n  >;\n\n  private allowReconnect = false;\n  private requestManager = new RequestManager();\n  private readonly activeConnection: WsConnection;\n  private readonly reconnectRetryDelay: (attemptIndex: number) => number;\n  private inactivityTimeout: ResettableTimeout;\n  private readonly callbacks: Pick<\n    WebSocketClientOptions,\n    'onOpen' | 'onClose' | 'onError'\n  >;\n  private readonly lazyMode: boolean;\n\n  constructor(opts: WebSocketClientOptions) {\n    // Initialize callbacks, connection parameters, and options.\n    this.callbacks = {\n      onOpen: opts.onOpen,\n      onClose: opts.onClose,\n      onError: opts.onError,\n    };\n\n    const lazyOptions = {\n      ...lazyDefaults,\n      ...opts.lazy,\n    };\n\n    // Set up inactivity timeout for lazy connections.\n    this.inactivityTimeout = new ResettableTimeout(() => {\n      if (\n        this.requestManager.hasOutgoingRequests() ||\n        this.requestManager.hasPendingRequests()\n      ) {\n        this.inactivityTimeout.reset();\n        return;\n      }\n\n      this.close().catch(() => null);\n    }, lazyOptions.closeMs);\n\n    // Initialize the WebSocket connection.\n    this.activeConnection = new WsConnection({\n      WebSocketPonyfill: opts.WebSocket,\n      urlOptions: opts,\n      keepAlive: {\n        ...keepAliveDefaults,\n        ...opts.keepAlive,\n      },\n    });\n    this.activeConnection.wsObservable.subscribe({\n      next: (ws) => {\n        if (!ws) return;\n        this.setupWebSocketListeners(ws);\n      },\n    });\n    this.reconnectRetryDelay = opts.retryDelayMs ?? exponentialBackoff;\n\n    this.lazyMode = lazyOptions.enabled;\n\n    this.connectionState = behaviorSubject<\n      TRPCConnectionState<TRPCClientError<AnyTRPCRouter>>\n    >({\n      type: 'state',\n      state: lazyOptions.enabled ? 'idle' : 'connecting',\n      error: null,\n    });\n\n    // Automatically open the connection if lazy mode is disabled.\n    if (!this.lazyMode) {\n      this.open().catch(() => null);\n    }\n  }\n\n  /**\n   * Opens the WebSocket connection. Handles reconnection attempts and updates\n   * the connection state accordingly.\n   */\n  private async open() {\n    this.allowReconnect = true;\n    if (this.connectionState.get().state !== 'connecting') {\n      this.connectionState.next({\n        type: 'state',\n        state: 'connecting',\n        error: null,\n      });\n    }\n\n    try {\n      await this.activeConnection.open();\n    } catch (error) {\n      this.reconnect(\n        new TRPCWebSocketClosedError({\n          message: 'Initialization error',\n          cause: error,\n        }),\n      );\n      return this.reconnecting;\n    }\n  }\n\n  /**\n   * Closes the WebSocket connection and stops managing requests.\n   * Ensures all outgoing and pending requests are properly finalized.\n   */\n  public async close() {\n    this.allowReconnect = false;\n    this.inactivityTimeout.stop();\n\n    const requestsToAwait: Promise<void>[] = [];\n    for (const request of this.requestManager.getRequests()) {\n      if (request.message.method === 'subscription') {\n        request.callbacks.complete();\n      } else if (request.state === 'outgoing') {\n        request.callbacks.error(\n          TRPCClientError.from(\n            new TRPCWebSocketClosedError({\n              message: 'Closed before connection was established',\n            }),\n          ),\n        );\n      } else {\n        requestsToAwait.push(request.end);\n      }\n    }\n\n    await Promise.all(requestsToAwait).catch(() => null);\n    await this.activeConnection.close().catch(() => null);\n\n    this.connectionState.next({\n      type: 'state',\n      state: 'idle',\n      error: null,\n    });\n  }\n\n  /**\n   * Method to request the server.\n   * Handles data transformation, batching of requests, and subscription lifecycle.\n   *\n   * @param op - The operation details including id, type, path, input and signal\n   * @param transformer - Data transformer for serializing requests and deserializing responses\n   * @param lastEventId - Optional ID of the last received event for subscriptions\n   *\n   * @returns An observable that emits operation results and handles cleanup\n   */\n  public request({\n    op: { id, type, path, input, signal },\n    transformer,\n    lastEventId,\n  }: {\n    op: Pick<Operation, 'id' | 'type' | 'path' | 'input' | 'signal'>;\n    transformer: CombinedDataTransformer;\n    lastEventId?: string;\n  }) {\n    return observable<\n      OperationResultEnvelope<unknown, TRPCClientError<AnyTRPCRouter>>,\n      TRPCClientError<AnyTRPCRouter>\n    >((observer) => {\n      const abort = this.batchSend(\n        {\n          id,\n          method: type,\n          params: {\n            input: transformer.input.serialize(input),\n            path,\n            lastEventId,\n          },\n        },\n        {\n          ...observer,\n          next(event) {\n            const transformed = transformResult(event, transformer.output);\n\n            if (!transformed.ok) {\n              observer.error(TRPCClientError.from(transformed.error));\n              return;\n            }\n\n            observer.next({\n              result: transformed.result,\n            });\n          },\n        },\n      );\n\n      return () => {\n        abort();\n\n        if (type === 'subscription' && this.activeConnection.isOpen()) {\n          this.send({\n            id,\n            method: 'subscription.stop',\n          });\n        }\n\n        signal?.removeEventListener('abort', abort);\n      };\n    });\n  }\n\n  public get connection() {\n    return backwardCompatibility(this.activeConnection);\n  }\n\n  /**\n   * Manages the reconnection process for the WebSocket using retry logic.\n   * Ensures that only one reconnection attempt is active at a time by tracking the current\n   * reconnection state in the `reconnecting` promise.\n   */\n  private reconnecting: Promise<void> | null = null;\n  private reconnect(closedError: TRPCWebSocketClosedError) {\n    this.connectionState.next({\n      type: 'state',\n      state: 'connecting',\n      error: TRPCClientError.from(closedError),\n    });\n    if (this.reconnecting) return;\n\n    const tryReconnect = async (attemptIndex: number) => {\n      try {\n        await sleep(this.reconnectRetryDelay(attemptIndex));\n        if (this.allowReconnect) {\n          await this.activeConnection.close();\n          await this.activeConnection.open();\n\n          if (this.requestManager.hasPendingRequests()) {\n            this.send(\n              this.requestManager\n                .getPendingRequests()\n                .map(({ message }) => message),\n            );\n          }\n        }\n        this.reconnecting = null;\n      } catch {\n        await tryReconnect(attemptIndex + 1);\n      }\n    };\n\n    this.reconnecting = tryReconnect(0);\n  }\n\n  private setupWebSocketListeners(ws: WebSocket) {\n    const handleCloseOrError = (cause: unknown) => {\n      const reqs = this.requestManager.getPendingRequests();\n      for (const { message, callbacks } of reqs) {\n        if (message.method === 'subscription') continue;\n\n        callbacks.error(\n          TRPCClientError.from(\n            cause ??\n              new TRPCWebSocketClosedError({\n                message: 'WebSocket closed',\n                cause,\n              }),\n          ),\n        );\n        this.requestManager.delete(message.id);\n      }\n    };\n\n    ws.addEventListener('open', () => {\n      run(async () => {\n        if (this.lazyMode) {\n          this.inactivityTimeout.start();\n        }\n\n        this.callbacks.onOpen?.();\n\n        this.connectionState.next({\n          type: 'state',\n          state: 'pending',\n          error: null,\n        });\n      }).catch((error) => {\n        ws.close(3000);\n        handleCloseOrError(error);\n      });\n    });\n\n    ws.addEventListener('message', ({ data }) => {\n      this.inactivityTimeout.reset();\n\n      if (typeof data !== 'string' || ['PING', 'PONG'].includes(data)) return;\n\n      const incomingMessage = JSON.parse(data) as TRPCClientIncomingMessage;\n      if ('method' in incomingMessage) {\n        this.handleIncomingRequest(incomingMessage);\n        return;\n      }\n\n      this.handleResponseMessage(incomingMessage);\n    });\n\n    ws.addEventListener('close', (event) => {\n      handleCloseOrError(event);\n      this.callbacks.onClose?.(event);\n\n      if (!this.lazyMode || this.requestManager.hasPendingSubscriptions()) {\n        this.reconnect(\n          new TRPCWebSocketClosedError({\n            message: 'WebSocket closed',\n            cause: event,\n          }),\n        );\n      }\n    });\n\n    ws.addEventListener('error', (event) => {\n      handleCloseOrError(event);\n      this.callbacks.onError?.(event);\n\n      this.reconnect(\n        new TRPCWebSocketClosedError({\n          message: 'WebSocket closed',\n          cause: event,\n        }),\n      );\n    });\n  }\n\n  private handleResponseMessage(message: TRPCResponseMessage) {\n    const request = this.requestManager.getPendingRequest(message.id);\n    if (!request) return;\n\n    request.callbacks.next(message);\n\n    let completed = true;\n    if ('result' in message && request.message.method === 'subscription') {\n      if (message.result.type === 'data') {\n        request.message.params.lastEventId = message.result.id;\n      }\n\n      if (message.result.type !== 'stopped') {\n        completed = false;\n      }\n    }\n\n    if (completed) {\n      request.callbacks.complete();\n      this.requestManager.delete(message.id);\n    }\n  }\n\n  private handleIncomingRequest(message: TRPCClientIncomingRequest) {\n    if (message.method === 'reconnect') {\n      this.reconnect(\n        new TRPCWebSocketClosedError({\n          message: 'Server requested reconnect',\n        }),\n      );\n    }\n  }\n\n  /**\n   * Sends a message or batch of messages directly to the server.\n   */\n  private send(\n    messageOrMessages: TRPCClientOutgoingMessage | TRPCClientOutgoingMessage[],\n  ) {\n    if (!this.activeConnection.isOpen()) {\n      throw new Error('Active connection is not open');\n    }\n\n    const messages =\n      messageOrMessages instanceof Array\n        ? messageOrMessages\n        : [messageOrMessages];\n    this.activeConnection.ws.send(\n      JSON.stringify(messages.length === 1 ? messages[0] : messages),\n    );\n  }\n\n  /**\n   * Groups requests for batch sending.\n   *\n   * @returns A function to abort the batched request.\n   */\n  private batchSend(message: TRPCClientOutgoingMessage, callbacks: TCallbacks) {\n    this.inactivityTimeout.reset();\n\n    run(async () => {\n      if (!this.activeConnection.isOpen()) {\n        await this.open();\n      }\n      await sleep(0);\n\n      if (!this.requestManager.hasOutgoingRequests()) return;\n\n      this.send(this.requestManager.flush().map(({ message }) => message));\n    }).catch((err) => {\n      this.requestManager.delete(message.id);\n      callbacks.error(TRPCClientError.from(err));\n    });\n\n    return this.requestManager.register(message, callbacks);\n  }\n}\n","import type { WebSocketClientOptions } from './wsClient/options';\nimport { WsClient } from './wsClient/wsClient';\n\nexport function createWSClient(opts: WebSocketClientOptions) {\n  return new WsClient(opts);\n}\n\nexport type TRPCWebSocketClient = ReturnType<typeof createWSClient>;\n\nexport { WebSocketClientOptions };\n","import { observable } from '@trpc/server/observable';\nimport type {\n  AnyRouter,\n  inferClientTypes,\n} from '@trpc/server/unstable-core-do-not-import';\nimport type { TransformerOptions } from '../../unstable-internals';\nimport { getTransformer } from '../../unstable-internals';\nimport type { TRPCLink } from '../types';\nimport type {\n  TRPCWebSocketClient,\n  WebSocketClientOptions,\n} from './createWsClient';\nimport { createWSClient } from './createWsClient';\n\nexport type WebSocketLinkOptions<TRouter extends AnyRouter> = {\n  client: TRPCWebSocketClient;\n} & TransformerOptions<inferClientTypes<TRouter>>;\n\nexport function wsLink<TRouter extends AnyRouter>(\n  opts: WebSocketLinkOptions<TRouter>,\n): TRPCLink<TRouter> {\n  const { client } = opts;\n  const transformer = getTransformer(opts.transformer);\n  return () => {\n    return ({ op }) => {\n      return observable((observer) => {\n        const connStateSubscription =\n          op.type === 'subscription'\n            ? client.connectionState.subscribe({\n                next(result) {\n                  observer.next({\n                    result,\n                    context: op.context,\n                  });\n                },\n              })\n            : null;\n\n        const requestSubscription = client\n          .request({\n            op,\n            transformer,\n          })\n          .subscribe(observer);\n\n        return () => {\n          requestSubscription.unsubscribe();\n          connStateSubscription?.unsubscribe();\n        };\n      });\n    };\n  };\n}\n\nexport { TRPCWebSocketClient, WebSocketClientOptions, createWSClient };\n"],"names":["lazyDefaults: LazyOptions","keepAliveDefaults: KeepAliveOptions","attemptIndex: number","value: T | ((...args: TArgs) => T)","opts: { message: string; cause?: unknown }","onTimeout: () => void","timeoutMs: number","resolve: (value: T | PromiseLike<T>) => void","reject: (reason?: any) => void","urlOptions: UrlOptionsWithConnectionParams","connectionParams: CallbackOrValue<TRPCRequestInfo['connectionParams']>","message: TRPCConnectionParamsMessage","message: TRPCClientOutgoingMessage","callbacks: TCallbacks","messageId: MessageIdLike","ws: WebSocket","pingTimeout: ReturnType<typeof setTimeout> | undefined","pongTimeout: ReturnType<typeof setTimeout> | undefined","opts: WebSocketConnectionOptions","this","connection: WsConnection","opts: WebSocketClientOptions","this","requestsToAwait: Promise<void>[]","closedError: TRPCWebSocketClosedError","attemptIndex: number","ws: WebSocket","cause: unknown","message: TRPCResponseMessage","message: TRPCClientIncomingRequest","messageOrMessages: TRPCClientOutgoingMessage | TRPCClientOutgoingMessage[]","message: TRPCClientOutgoingMessage","callbacks: TCallbacks","message","opts: WebSocketClientOptions","opts: WebSocketLinkOptions<TRouter>"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7],"debugId":null}},
    {"offset": {"line": 3115, "column": 0}, "map": {"version":3,"file":"resolveResponse-CzlbRpCI.mjs","sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/server/src/unstable-core-do-not-import/http/parseConnectionParams.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/server/src/unstable-core-do-not-import/http/contentType.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/server/src/unstable-core-do-not-import/http/abortError.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/server/src/vendor/unpromise/unpromise.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/server/src/unstable-core-do-not-import/stream/utils/disposable.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/server/src/unstable-core-do-not-import/stream/utils/timerResource.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/usingCtx.js","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/OverloadYield.js","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/awaitAsyncGenerator.js","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/wrapAsyncGenerator.js","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/server/src/unstable-core-do-not-import/stream/utils/asyncIterable.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/server/src/unstable-core-do-not-import/stream/utils/createDeferred.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/server/src/unstable-core-do-not-import/stream/utils/mergeAsyncIterables.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/server/src/unstable-core-do-not-import/stream/utils/readableStreamFrom.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/server/src/unstable-core-do-not-import/stream/utils/withPing.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/asyncIterator.js","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/server/src/unstable-core-do-not-import/stream/jsonl.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/asyncGeneratorDelegate.js","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/server/src/unstable-core-do-not-import/stream/sse.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/server/src/unstable-core-do-not-import/http/resolveResponse.ts"],"sourcesContent":["import { TRPCError } from '../error/TRPCError';\nimport { isObject } from '../utils';\nimport type { TRPCRequestInfo } from './types';\n\nexport function parseConnectionParamsFromUnknown(\n  parsed: unknown,\n): TRPCRequestInfo['connectionParams'] {\n  try {\n    if (parsed === null) {\n      return null;\n    }\n    if (!isObject(parsed)) {\n      throw new Error('Expected object');\n    }\n    const nonStringValues = Object.entries(parsed).filter(\n      ([_key, value]) => typeof value !== 'string',\n    );\n\n    if (nonStringValues.length > 0) {\n      throw new Error(\n        `Expected connectionParams to be string values. Got ${nonStringValues\n          .map(([key, value]) => `${key}: ${typeof value}`)\n          .join(', ')}`,\n      );\n    }\n    return parsed as Record<string, string>;\n  } catch (cause) {\n    throw new TRPCError({\n      code: 'PARSE_ERROR',\n      message: 'Invalid connection params shape',\n      cause,\n    });\n  }\n}\nexport function parseConnectionParamsFromString(\n  str: string,\n): TRPCRequestInfo['connectionParams'] {\n  let parsed: unknown;\n  try {\n    parsed = JSON.parse(str);\n  } catch (cause) {\n    throw new TRPCError({\n      code: 'PARSE_ERROR',\n      message: 'Not JSON-parsable query params',\n      cause,\n    });\n  }\n  return parseConnectionParamsFromUnknown(parsed);\n}\n","import { TRPCError } from '../error/TRPCError';\nimport type { ProcedureType } from '../procedure';\nimport { getProcedureAtPath, type AnyRouter } from '../router';\nimport { isObject } from '../utils';\nimport { parseConnectionParamsFromString } from './parseConnectionParams';\nimport type { TRPCAcceptHeader, TRPCRequestInfo } from './types';\n\ntype GetRequestInfoOptions = {\n  path: string;\n  req: Request;\n  url: URL | null;\n  searchParams: URLSearchParams;\n  headers: Headers;\n  router: AnyRouter;\n};\n\ntype ContentTypeHandler = {\n  isMatch: (opts: Request) => boolean;\n  parse: (opts: GetRequestInfoOptions) => Promise<TRPCRequestInfo>;\n};\n\n/**\n * Memoize a function that takes no arguments\n * @internal\n */\nfunction memo<TReturn>(fn: () => Promise<TReturn>) {\n  let promise: Promise<TReturn> | null = null;\n  const sym = Symbol.for('@trpc/server/http/memo');\n  let value: TReturn | typeof sym = sym;\n  return {\n    /**\n     * Lazily read the value\n     */\n    read: async (): Promise<TReturn> => {\n      if (value !== sym) {\n        return value;\n      }\n\n      // dedupes promises and catches errors\n      promise ??= fn().catch((cause) => {\n        if (cause instanceof TRPCError) {\n          throw cause;\n        }\n        throw new TRPCError({\n          code: 'BAD_REQUEST',\n          message: cause instanceof Error ? cause.message : 'Invalid input',\n          cause,\n        });\n      });\n\n      value = await promise;\n      promise = null;\n\n      return value;\n    },\n    /**\n     * Get an already stored result\n     */\n    result: (): TReturn | undefined => {\n      return value !== sym ? value : undefined;\n    },\n  };\n}\n\nconst jsonContentTypeHandler: ContentTypeHandler = {\n  isMatch(req) {\n    return !!req.headers.get('content-type')?.startsWith('application/json');\n  },\n  async parse(opts) {\n    const { req } = opts;\n    const isBatchCall = opts.searchParams.get('batch') === '1';\n    const paths = isBatchCall ? opts.path.split(',') : [opts.path];\n\n    type InputRecord = Record<number, unknown>;\n    const getInputs = memo(async (): Promise<InputRecord> => {\n      let inputs: unknown = undefined;\n      if (req.method === 'GET') {\n        const queryInput = opts.searchParams.get('input');\n        if (queryInput) {\n          inputs = JSON.parse(queryInput);\n        }\n      } else {\n        inputs = await req.json();\n      }\n      if (inputs === undefined) {\n        return {};\n      }\n\n      if (!isBatchCall) {\n        return {\n          0: opts.router._def._config.transformer.input.deserialize(inputs),\n        };\n      }\n\n      if (!isObject(inputs)) {\n        throw new TRPCError({\n          code: 'BAD_REQUEST',\n          message: '\"input\" needs to be an object when doing a batch call',\n        });\n      }\n      const acc: InputRecord = {};\n      for (const index of paths.keys()) {\n        const input = inputs[index];\n        if (input !== undefined) {\n          acc[index] =\n            opts.router._def._config.transformer.input.deserialize(input);\n        }\n      }\n\n      return acc;\n    });\n\n    const calls = await Promise.all(\n      paths.map(\n        async (path, index): Promise<TRPCRequestInfo['calls'][number]> => {\n          const procedure = await getProcedureAtPath(opts.router, path);\n          return {\n            path,\n            procedure,\n            getRawInput: async () => {\n              const inputs = await getInputs.read();\n              let input = inputs[index];\n\n              if (procedure?._def.type === 'subscription') {\n                const lastEventId =\n                  opts.headers.get('last-event-id') ??\n                  opts.searchParams.get('lastEventId') ??\n                  opts.searchParams.get('Last-Event-Id');\n\n                if (lastEventId) {\n                  if (isObject(input)) {\n                    input = {\n                      ...input,\n                      lastEventId: lastEventId,\n                    };\n                  } else {\n                    input ??= {\n                      lastEventId: lastEventId,\n                    };\n                  }\n                }\n              }\n              return input;\n            },\n            result: () => {\n              return getInputs.result()?.[index];\n            },\n          };\n        },\n      ),\n    );\n\n    const types = new Set(\n      calls.map((call) => call.procedure?._def.type).filter(Boolean),\n    );\n\n    /* istanbul ignore if -- @preserve */\n    if (types.size > 1) {\n      throw new TRPCError({\n        code: 'BAD_REQUEST',\n        message: `Cannot mix procedure types in call: ${Array.from(types).join(\n          ', ',\n        )}`,\n      });\n    }\n    const type: ProcedureType | 'unknown' =\n      types.values().next().value ?? 'unknown';\n\n    const connectionParamsStr = opts.searchParams.get('connectionParams');\n\n    const info: TRPCRequestInfo = {\n      isBatchCall,\n      accept: req.headers.get('trpc-accept') as TRPCAcceptHeader | null,\n      calls,\n      type,\n      connectionParams:\n        connectionParamsStr === null\n          ? null\n          : parseConnectionParamsFromString(connectionParamsStr),\n      signal: req.signal,\n      url: opts.url,\n    };\n    return info;\n  },\n};\n\nconst formDataContentTypeHandler: ContentTypeHandler = {\n  isMatch(req) {\n    return !!req.headers.get('content-type')?.startsWith('multipart/form-data');\n  },\n  async parse(opts) {\n    const { req } = opts;\n    if (req.method !== 'POST') {\n      throw new TRPCError({\n        code: 'METHOD_NOT_SUPPORTED',\n        message:\n          'Only POST requests are supported for multipart/form-data requests',\n      });\n    }\n    const getInputs = memo(async () => {\n      const fd = await req.formData();\n      return fd;\n    });\n    const procedure = await getProcedureAtPath(opts.router, opts.path);\n    return {\n      accept: null,\n      calls: [\n        {\n          path: opts.path,\n          getRawInput: getInputs.read,\n          result: getInputs.result,\n          procedure,\n        },\n      ],\n      isBatchCall: false,\n      type: 'mutation',\n      connectionParams: null,\n      signal: req.signal,\n      url: opts.url,\n    };\n  },\n};\n\nconst octetStreamContentTypeHandler: ContentTypeHandler = {\n  isMatch(req) {\n    return !!req.headers\n      .get('content-type')\n      ?.startsWith('application/octet-stream');\n  },\n  async parse(opts) {\n    const { req } = opts;\n    if (req.method !== 'POST') {\n      throw new TRPCError({\n        code: 'METHOD_NOT_SUPPORTED',\n        message:\n          'Only POST requests are supported for application/octet-stream requests',\n      });\n    }\n    const getInputs = memo(async () => {\n      return req.body;\n    });\n    return {\n      calls: [\n        {\n          path: opts.path,\n          getRawInput: getInputs.read,\n          result: getInputs.result,\n          procedure: await getProcedureAtPath(opts.router, opts.path),\n        },\n      ],\n      isBatchCall: false,\n      accept: null,\n      type: 'mutation',\n      connectionParams: null,\n      signal: req.signal,\n      url: opts.url,\n    };\n  },\n};\n\nconst handlers = [\n  jsonContentTypeHandler,\n  formDataContentTypeHandler,\n  octetStreamContentTypeHandler,\n];\n\nfunction getContentTypeHandler(req: Request): ContentTypeHandler {\n  const handler = handlers.find((handler) => handler.isMatch(req));\n  if (handler) {\n    return handler;\n  }\n\n  if (!handler && req.method === 'GET') {\n    // fallback to JSON for get requests so GET-requests can be opened in browser easily\n    return jsonContentTypeHandler;\n  }\n\n  throw new TRPCError({\n    code: 'UNSUPPORTED_MEDIA_TYPE',\n    message: req.headers.has('content-type')\n      ? `Unsupported content-type \"${req.headers.get('content-type')}`\n      : 'Missing content-type header',\n  });\n}\n\nexport async function getRequestInfo(\n  opts: GetRequestInfoOptions,\n): Promise<TRPCRequestInfo> {\n  const handler = getContentTypeHandler(opts.req);\n  return await handler.parse(opts);\n}\n","import { isObject } from '../utils';\n\nexport function isAbortError(\n  error: unknown,\n): error is DOMException | Error | { name: 'AbortError' } {\n  return isObject(error) && error['name'] === 'AbortError';\n}\n\nexport function throwAbortError(message = 'AbortError'): never {\n  throw new DOMException(message, 'AbortError');\n}\n","/* eslint-disable @typescript-eslint/unbound-method */\n \n \n\nimport type {\n  PromiseExecutor,\n  PromiseWithResolvers,\n  ProxyPromise,\n  SubscribedPromise,\n} from \"./types\";\n\n/** Memory safe (weakmapped) cache of the ProxyPromise for each Promise,\n * which is retained for the lifetime of the original Promise.\n */\nconst subscribableCache = new WeakMap<\n  PromiseLike<unknown>,\n  ProxyPromise<unknown>\n>();\n\n/** A NOOP function allowing a consistent interface for settled\n * SubscribedPromises (settled promises are not subscribed - they resolve\n * immediately). */\nconst NOOP = () => {\n  // noop\n};\n\n/**\n * Every `Promise<T>` can be shadowed by a single `ProxyPromise<T>`. It is\n * created once, cached and reused throughout the lifetime of the Promise. Get a\n * Promise's ProxyPromise using `Unpromise.proxy(promise)`.\n *\n * The `ProxyPromise<T>` attaches handlers to the original `Promise<T>`\n * `.then()` and `.catch()` just once. Promises derived from it use a\n * subscription- (and unsubscription-) based mechanism that monitors these\n * handlers.\n *\n * Every time you call `.subscribe()`, `.then()` `.catch()` or `.finally()` on a\n * `ProxyPromise<T>` it returns a `SubscribedPromise<T>` having an additional\n * `unsubscribe()` method. Calling `unsubscribe()` detaches reference chains\n * from the original, potentially long-lived Promise, eliminating memory leaks.\n *\n * This approach can eliminate the memory leaks that otherwise come about from\n * repeated `race()` or `any()` calls invoking `.then()` and `.catch()` multiple\n * times on the same long-lived native Promise (subscriptions which can never be\n * cleaned up).\n *\n * `Unpromise.race(promises)` is a reference implementation of `Promise.race`\n * avoiding memory leaks when using long-lived unsettled Promises.\n *\n * `Unpromise.any(promises)` is a reference implementation of `Promise.any`\n * avoiding memory leaks when using long-lived unsettled Promises.\n *\n * `Unpromise.resolve(promise)` returns an ephemeral `SubscribedPromise<T>` for\n * any given `Promise<T>` facilitating arbitrary async/await patterns. Behind\n * the scenes, `resolve` is implemented simply as\n * `Unpromise.proxy(promise).subscribe()`. Don't forget to call `.unsubscribe()`\n * to tidy up!\n *\n */\nexport class Unpromise<T> implements ProxyPromise<T> {\n  /** INSTANCE IMPLEMENTATION */\n\n  /** The promise shadowed by this Unpromise<T>  */\n  protected readonly promise: Promise<T> | PromiseLike<T>;\n\n  /** Promises expecting eventual settlement (unless unsubscribed first). This list is deleted\n   * after the original promise settles - no further notifications will be issued. */\n  protected subscribers: ReadonlyArray<PromiseWithResolvers<T>> | null = [];\n\n  /** The Promise's settlement (recorded when it fulfils or rejects). This is consulted when\n   * calling .subscribe() .then() .catch() .finally() to see if an immediately-resolving Promise\n   * can be returned, and therefore subscription can be bypassed. */\n  protected settlement: PromiseSettledResult<T> | null = null;\n\n  /** Constructor accepts a normal Promise executor function like `new\n   * Unpromise((resolve, reject) => {...})` or accepts a pre-existing Promise\n   * like `new Unpromise(existingPromise)`. Adds `.then()` and `.catch()`\n   * handlers to the Promise. These handlers pass fulfilment and rejection\n   * notifications to downstream subscribers and maintains records of value\n   * or error if the Promise ever settles. */\n  protected constructor(promise: Promise<T>);\n  protected constructor(promise: PromiseLike<T>);\n  protected constructor(executor: PromiseExecutor<T>);\n  protected constructor(arg: Promise<T> | PromiseLike<T> | PromiseExecutor<T>) {\n    // handle either a Promise or a Promise executor function\n    if (typeof arg === \"function\") {\n      this.promise = new Promise(arg);\n    } else {\n      this.promise = arg;\n    }\n\n    // subscribe for eventual fulfilment and rejection\n\n    // handle PromiseLike objects (that at least have .then)\n    const thenReturn = this.promise.then((value) => {\n      // atomically record fulfilment and detach subscriber list\n      const { subscribers } = this;\n      this.subscribers = null;\n      this.settlement = {\n        status: \"fulfilled\",\n        value,\n      };\n      // notify fulfilment to subscriber list\n      subscribers?.forEach(({ resolve }) => {\n        resolve(value);\n      });\n    });\n\n    // handle Promise (that also have a .catch behaviour)\n    if (\"catch\" in thenReturn) {\n      thenReturn.catch((reason) => {\n        // atomically record rejection and detach subscriber list\n        const { subscribers } = this;\n        this.subscribers = null;\n        this.settlement = {\n          status: \"rejected\",\n          reason,\n        };\n        // notify rejection to subscriber list\n        subscribers?.forEach(({ reject }) => {\n          reject(reason);\n        });\n      });\n    }\n  }\n\n  /** Create a promise that mitigates uncontrolled subscription to a long-lived\n   * Promise via .then() and .catch() - otherwise a source of memory leaks.\n   *\n   * The returned promise has an `unsubscribe()` method which can be called when\n   * the Promise is no longer being tracked by application logic, and which\n   * ensures that there is no reference chain from the original promise to the\n   * new one, and therefore no memory leak.\n   *\n   * If original promise has not yet settled, this adds a new unique promise\n   * that listens to then/catch events, along with an `unsubscribe()` method to\n   * detach it.\n   *\n   * If original promise has settled, then creates a new Promise.resolve() or\n   * Promise.reject() and provided unsubscribe is a noop.\n   *\n   * If you call `unsubscribe()` before the returned Promise has settled, it\n   * will never settle.\n   */\n  subscribe(): SubscribedPromise<T> {\n    // in all cases we will combine some promise with its unsubscribe function\n    let promise: Promise<T>;\n    let unsubscribe: () => void;\n\n    const { settlement } = this;\n    if (settlement === null) {\n      // not yet settled - subscribe new promise. Expect eventual settlement\n      if (this.subscribers === null) {\n        // invariant - it is not settled, so it must have subscribers\n        throw new Error(\"Unpromise settled but still has subscribers\");\n      }\n      const subscriber = withResolvers<T>();\n      this.subscribers = listWithMember(this.subscribers, subscriber);\n      promise = subscriber.promise;\n      unsubscribe = () => {\n        if (this.subscribers !== null) {\n          this.subscribers = listWithoutMember(this.subscribers, subscriber);\n        }\n      };\n    } else {\n      // settled - don't create subscribed promise. Just resolve or reject\n      const { status } = settlement;\n      if (status === \"fulfilled\") {\n        promise = Promise.resolve(settlement.value);\n      } else {\n        promise = Promise.reject(settlement.reason);\n      }\n      unsubscribe = NOOP;\n    }\n\n    // extend promise signature with the extra method\n    return Object.assign(promise, { unsubscribe });\n  }\n\n  /** STANDARD PROMISE METHODS (but returning a SubscribedPromise) */\n\n  then<TResult1 = T, TResult2 = never>(\n    onfulfilled?:\n      | ((value: T) => TResult1 | PromiseLike<TResult1>)\n      | null\n       ,\n    onrejected?:\n      | ((reason: any) => TResult2 | PromiseLike<TResult2>)\n      | null\n       \n  ): SubscribedPromise<TResult1 | TResult2> {\n    const subscribed = this.subscribe();\n    const { unsubscribe } = subscribed;\n    return Object.assign(subscribed.then(onfulfilled, onrejected), {\n      unsubscribe,\n    });\n  }\n\n  catch<TResult = never>(\n    onrejected?:\n      | ((reason: any) => TResult | PromiseLike<TResult>)\n      | null\n       \n  ): SubscribedPromise<T | TResult> {\n    const subscribed = this.subscribe();\n    const { unsubscribe } = subscribed;\n    return Object.assign(subscribed.catch(onrejected), {\n      unsubscribe,\n    });\n  }\n\n  finally(onfinally?: (() => void) | null  ): SubscribedPromise<T> {\n    const subscribed = this.subscribe();\n    const { unsubscribe } = subscribed;\n    return Object.assign(subscribed.finally(onfinally), {\n      unsubscribe,\n    });\n  }\n\n  /** TOSTRING SUPPORT */\n\n  readonly [Symbol.toStringTag] = \"Unpromise\";\n\n  /** Unpromise STATIC METHODS */\n\n  /** Create or Retrieve the proxy Unpromise (a re-used Unpromise for the VM lifetime\n   * of the provided Promise reference) */\n  static proxy<T>(promise: PromiseLike<T>): ProxyPromise<T> {\n    const cached = Unpromise.getSubscribablePromise(promise);\n    return typeof cached !== \"undefined\"\n      ? cached\n      : Unpromise.createSubscribablePromise(promise);\n  }\n\n  /** Create and store an Unpromise keyed by an original Promise. */\n  protected static createSubscribablePromise<T>(promise: PromiseLike<T>) {\n    const created = new Unpromise<T>(promise);\n    subscribableCache.set(promise, created as Unpromise<unknown>); // resolve promise to unpromise\n    subscribableCache.set(created, created as Unpromise<unknown>); // resolve the unpromise to itself\n    return created;\n  }\n\n  /** Retrieve a previously-created Unpromise keyed by an original Promise. */\n  protected static getSubscribablePromise<T>(promise: PromiseLike<T>) {\n    return subscribableCache.get(promise) as ProxyPromise<T> | undefined;\n  }\n\n  /** Promise STATIC METHODS */\n\n  /** Lookup the Unpromise for this promise, and derive a SubscribedPromise from\n   * it (that can be later unsubscribed to eliminate Memory leaks) */\n  static resolve<T>(value: T | PromiseLike<T>) {\n    const promise: PromiseLike<T> =\n      typeof value === \"object\" &&\n      value !== null &&\n      \"then\" in value &&\n      typeof value.then === \"function\"\n        ? value\n        : Promise.resolve(value);\n    return Unpromise.proxy(promise).subscribe() as SubscribedPromise<\n      Awaited<T>\n    >;\n  }\n\n  /** Perform Promise.any() via SubscribedPromises, then unsubscribe them.\n   * Equivalent to Promise.any but eliminates memory leaks from long-lived\n   * promises accumulating .then() and .catch() subscribers. */\n  static async any<T extends readonly unknown[] | []>(\n    values: T\n  ): Promise<Awaited<T[number]>>;\n  static async any<T>(\n    values: Iterable<T | PromiseLike<T>>\n  ): Promise<Awaited<T>> {\n    const valuesArray = Array.isArray(values) ? values : [...values];\n    const subscribedPromises = valuesArray.map(Unpromise.resolve);\n    try {\n      return await Promise.any(subscribedPromises);\n    } finally {\n      subscribedPromises.forEach(({ unsubscribe }) => {\n        unsubscribe();\n      });\n    }\n  }\n\n  /** Perform Promise.race via SubscribedPromises, then unsubscribe them.\n   * Equivalent to Promise.race but eliminates memory leaks from long-lived\n   * promises accumulating .then() and .catch() subscribers. */\n  static async race<T extends readonly unknown[] | []>(\n    values: T\n  ): Promise<Awaited<T[number]>>;\n  static async race<T>(\n    values: Iterable<T | PromiseLike<T>>\n  ): Promise<Awaited<T>> {\n    const valuesArray = Array.isArray(values) ? values : [...values];\n    const subscribedPromises = valuesArray.map(Unpromise.resolve);\n    try {\n      return await Promise.race(subscribedPromises);\n    } finally {\n      subscribedPromises.forEach(({ unsubscribe }) => {\n        unsubscribe();\n      });\n    }\n  }\n\n  /** Create a race of SubscribedPromises that will fulfil to a single winning\n   * Promise (in a 1-Tuple). Eliminates memory leaks from long-lived promises\n   * accumulating .then() and .catch() subscribers. Allows simple logic to\n   * consume the result, like...\n   * ```ts\n   * const [ winner ] = await Unpromise.race([ promiseA, promiseB ]);\n   * if(winner === promiseB){\n   *   const result = await promiseB;\n   *   // do the thing\n   * }\n   * ```\n   * */\n  static async raceReferences<TPromise extends Promise<unknown>>(\n    promises: readonly TPromise[]\n  ) {\n    // map each promise to an eventual 1-tuple containing itself\n    const selfPromises = promises.map(resolveSelfTuple);\n\n    // now race them. They will fulfil to a readonly [P] or reject.\n    try {\n      return await Promise.race(selfPromises);\n    } finally {\n      for (const promise of selfPromises) {\n        // unsubscribe proxy promises when the race is over to mitigate memory leaks\n        promise.unsubscribe();\n      }\n    }\n  }\n}\n\n/** Promises a 1-tuple containing the original promise when it resolves. Allows\n * awaiting the eventual Promise ***reference*** (easy to destructure and\n * exactly compare with ===). Avoids resolving to the Promise ***value*** (which\n * may be ambiguous and therefore hard to identify as the winner of a race).\n * You can call unsubscribe on the Promise to mitigate memory leaks.\n * */\nexport function resolveSelfTuple<TPromise extends Promise<unknown>>(\n  promise: TPromise\n): SubscribedPromise<readonly [TPromise]> {\n  return Unpromise.proxy(promise).then(() => [promise] as const);\n}\n\n/** VENDORED (Future) PROMISE UTILITIES */\n\n/** Reference implementation of https://github.com/tc39/proposal-promise-with-resolvers */\nfunction withResolvers<T>(): PromiseWithResolvers<T> {\n  let resolve!: PromiseWithResolvers<T>[\"resolve\"];\n  let reject!: PromiseWithResolvers<T>[\"reject\"];\n  const promise = new Promise<T>((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n  });\n  return {\n    promise,\n    resolve,\n    reject,\n  };\n}\n\n/** IMMUTABLE LIST OPERATIONS */\n\nfunction listWithMember<T>(arr: readonly T[], member: T): readonly T[] {\n  return [...arr, member];\n}\n\nfunction listWithoutIndex<T>(arr: readonly T[], index: number) {\n  return [...arr.slice(0, index), ...arr.slice(index + 1)];\n}\n\nfunction listWithoutMember<T>(arr: readonly T[], member: unknown) {\n  const index = arr.indexOf(member as T);\n  if (index !== -1) {\n    return listWithoutIndex(arr, index);\n  }\n  return arr;\n}\n","// @ts-expect-error - polyfilling symbol\n// eslint-disable-next-line no-restricted-syntax\nSymbol.dispose ??= Symbol();\n\n// @ts-expect-error - polyfilling symbol\n// eslint-disable-next-line no-restricted-syntax\nSymbol.asyncDispose ??= Symbol();\n\n/**\n * Takes a value and a dispose function and returns a new object that implements the Disposable interface.\n * The returned object is the original value augmented with a Symbol.dispose method.\n * @param thing The value to make disposable\n * @param dispose Function to call when disposing the resource\n * @returns The original value with Symbol.dispose method added\n */\nexport function makeResource<T>(thing: T, dispose: () => void): T & Disposable {\n  const it = thing as T & Partial<Disposable>;\n\n  // eslint-disable-next-line no-restricted-syntax\n  const existing = it[Symbol.dispose];\n\n  // eslint-disable-next-line no-restricted-syntax\n  it[Symbol.dispose] = () => {\n    dispose();\n    existing?.();\n  };\n\n  return it as T & Disposable;\n}\n\n/**\n * Takes a value and an async dispose function and returns a new object that implements the AsyncDisposable interface.\n * The returned object is the original value augmented with a Symbol.asyncDispose method.\n * @param thing The value to make async disposable\n * @param dispose Async function to call when disposing the resource\n * @returns The original value with Symbol.asyncDispose method added\n */\nexport function makeAsyncResource<T>(\n  thing: T,\n  dispose: () => Promise<void>,\n): T & AsyncDisposable {\n  const it = thing as T & Partial<AsyncDisposable>;\n\n  // eslint-disable-next-line no-restricted-syntax\n  const existing = it[Symbol.asyncDispose];\n\n  // eslint-disable-next-line no-restricted-syntax\n  it[Symbol.asyncDispose] = async () => {\n    await dispose();\n    await existing?.();\n  };\n\n  return it as T & AsyncDisposable;\n}\n","import { makeResource } from './disposable';\n\nexport const disposablePromiseTimerResult = Symbol();\n\nexport function timerResource(ms: number) {\n  let timer: ReturnType<typeof setTimeout> | null = null;\n\n  return makeResource(\n    {\n      start() {\n        if (timer) {\n          throw new Error('Timer already started');\n        }\n\n        const promise = new Promise<typeof disposablePromiseTimerResult>(\n          (resolve) => {\n            timer = setTimeout(() => resolve(disposablePromiseTimerResult), ms);\n          },\n        );\n        return promise;\n      },\n    },\n    () => {\n      if (timer) {\n        clearTimeout(timer);\n      }\n    },\n  );\n}\n","function _usingCtx() {\n  var r = \"function\" == typeof SuppressedError ? SuppressedError : function (r, e) {\n      var n = Error();\n      return n.name = \"SuppressedError\", n.error = r, n.suppressed = e, n;\n    },\n    e = {},\n    n = [];\n  function using(r, e) {\n    if (null != e) {\n      if (Object(e) !== e) throw new TypeError(\"using declarations can only be used with objects, functions, null, or undefined.\");\n      if (r) var o = e[Symbol.asyncDispose || Symbol[\"for\"](\"Symbol.asyncDispose\")];\n      if (void 0 === o && (o = e[Symbol.dispose || Symbol[\"for\"](\"Symbol.dispose\")], r)) var t = o;\n      if (\"function\" != typeof o) throw new TypeError(\"Object is not disposable.\");\n      t && (o = function o() {\n        try {\n          t.call(e);\n        } catch (r) {\n          return Promise.reject(r);\n        }\n      }), n.push({\n        v: e,\n        d: o,\n        a: r\n      });\n    } else r && n.push({\n      d: e,\n      a: r\n    });\n    return e;\n  }\n  return {\n    e: e,\n    u: using.bind(null, !1),\n    a: using.bind(null, !0),\n    d: function d() {\n      var o,\n        t = this.e,\n        s = 0;\n      function next() {\n        for (; o = n.pop();) try {\n          if (!o.a && 1 === s) return s = 0, n.push(o), Promise.resolve().then(next);\n          if (o.d) {\n            var r = o.d.call(o.v);\n            if (o.a) return s |= 2, Promise.resolve(r).then(next, err);\n          } else s |= 1;\n        } catch (r) {\n          return err(r);\n        }\n        if (1 === s) return t !== e ? Promise.reject(t) : Promise.resolve();\n        if (t !== e) throw t;\n      }\n      function err(n) {\n        return t = t !== e ? new r(n, t) : n, next();\n      }\n      return next();\n    }\n  };\n}\nmodule.exports = _usingCtx, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _OverloadYield(e, d) {\n  this.v = e, this.k = d;\n}\nmodule.exports = _OverloadYield, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var OverloadYield = require(\"./OverloadYield.js\");\nfunction _awaitAsyncGenerator(e) {\n  return new OverloadYield(e, 0);\n}\nmodule.exports = _awaitAsyncGenerator, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var OverloadYield = require(\"./OverloadYield.js\");\nfunction _wrapAsyncGenerator(e) {\n  return function () {\n    return new AsyncGenerator(e.apply(this, arguments));\n  };\n}\nfunction AsyncGenerator(e) {\n  var r, t;\n  function resume(r, t) {\n    try {\n      var n = e[r](t),\n        o = n.value,\n        u = o instanceof OverloadYield;\n      Promise.resolve(u ? o.v : o).then(function (t) {\n        if (u) {\n          var i = \"return\" === r ? \"return\" : \"next\";\n          if (!o.k || t.done) return resume(i, t);\n          t = e[i](t).value;\n        }\n        settle(n.done ? \"return\" : \"normal\", t);\n      }, function (e) {\n        resume(\"throw\", e);\n      });\n    } catch (e) {\n      settle(\"throw\", e);\n    }\n  }\n  function settle(e, n) {\n    switch (e) {\n      case \"return\":\n        r.resolve({\n          value: n,\n          done: !0\n        });\n        break;\n      case \"throw\":\n        r.reject(n);\n        break;\n      default:\n        r.resolve({\n          value: n,\n          done: !1\n        });\n    }\n    (r = r.next) ? resume(r.key, r.arg) : t = null;\n  }\n  this._invoke = function (e, n) {\n    return new Promise(function (o, u) {\n      var i = {\n        key: e,\n        arg: n,\n        resolve: o,\n        reject: u,\n        next: null\n      };\n      t ? t = t.next = i : (r = t = i, resume(e, n));\n    });\n  }, \"function\" != typeof e[\"return\"] && (this[\"return\"] = void 0);\n}\nAsyncGenerator.prototype[\"function\" == typeof Symbol && Symbol.asyncIterator || \"@@asyncIterator\"] = function () {\n  return this;\n}, AsyncGenerator.prototype.next = function (e) {\n  return this._invoke(\"next\", e);\n}, AsyncGenerator.prototype[\"throw\"] = function (e) {\n  return this._invoke(\"throw\", e);\n}, AsyncGenerator.prototype[\"return\"] = function (e) {\n  return this._invoke(\"return\", e);\n};\nmodule.exports = _wrapAsyncGenerator, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","import { Unpromise } from '../../../vendor/unpromise';\nimport { throwAbortError } from '../../http/abortError';\nimport { makeAsyncResource } from './disposable';\nimport { disposablePromiseTimerResult, timerResource } from './timerResource';\n\nexport function iteratorResource<TYield, TReturn, TNext>(\n  iterable: AsyncIterable<TYield, TReturn, TNext>,\n): AsyncIterator<TYield, TReturn, TNext> & AsyncDisposable {\n  const iterator = iterable[Symbol.asyncIterator]();\n\n  // @ts-expect-error - this is added in node 24 which we don't officially support yet\n  // eslint-disable-next-line no-restricted-syntax\n  if (iterator[Symbol.asyncDispose]) {\n    return iterator as AsyncIterator<TYield, TReturn, TNext> & AsyncDisposable;\n  }\n\n  return makeAsyncResource(iterator, async () => {\n    await iterator.return?.();\n  });\n}\n/**\n * Derives a new {@link AsyncGenerator} based on {@link iterable}, that automatically aborts after the specified duration.\n */\nexport async function* withMaxDuration<T>(\n  iterable: AsyncIterable<T>,\n  opts: { maxDurationMs: number },\n): AsyncGenerator<T> {\n  await using iterator = iteratorResource(iterable);\n\n  using timer = timerResource(opts.maxDurationMs);\n\n  const timerPromise = timer.start();\n\n  // declaration outside the loop for garbage collection reasons\n  let result: null | IteratorResult<T> | typeof disposablePromiseTimerResult;\n\n  while (true) {\n    result = await Unpromise.race([iterator.next(), timerPromise]);\n    if (result === disposablePromiseTimerResult) {\n      // cancelled due to timeout\n      throwAbortError();\n    }\n    if (result.done) {\n      return result;\n    }\n    yield result.value;\n    // free up reference for garbage collection\n    result = null;\n  }\n}\n\n/**\n * Derives a new {@link AsyncGenerator} based of {@link iterable}, that yields its first\n * {@link count} values. Then, a grace period of {@link gracePeriodMs} is started in which further\n * values may still come through. After this period, the generator aborts.\n */\nexport async function* takeWithGrace<T>(\n  iterable: AsyncIterable<T>,\n  opts: {\n    count: number;\n    gracePeriodMs: number;\n  },\n): AsyncGenerator<T> {\n  await using iterator = iteratorResource(iterable);\n\n  // declaration outside the loop for garbage collection reasons\n  let result: null | IteratorResult<T> | typeof disposablePromiseTimerResult;\n\n  using timer = timerResource(opts.gracePeriodMs);\n\n  let count = opts.count;\n\n  let timerPromise = new Promise<typeof disposablePromiseTimerResult>(() => {\n    // never resolves\n  });\n\n  while (true) {\n    result = await Unpromise.race([iterator.next(), timerPromise]);\n    if (result === disposablePromiseTimerResult) {\n      throwAbortError();\n    }\n    if (result.done) {\n      return result.value;\n    }\n    yield result.value;\n    if (--count === 0) {\n      timerPromise = timer.start();\n    }\n    // free up reference for garbage collection\n    result = null;\n  }\n}\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nexport function createDeferred<TValue = void>() {\n  let resolve: (value: TValue) => void;\n  let reject: (error: unknown) => void;\n  const promise = new Promise<TValue>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return { promise, resolve: resolve!, reject: reject! };\n}\nexport type Deferred<TValue> = ReturnType<typeof createDeferred<TValue>>;\n","import { createDeferred } from './createDeferred';\nimport { makeAsyncResource } from './disposable';\n\ntype ManagedIteratorResult<TYield, TReturn> =\n  | { status: 'yield'; value: TYield }\n  | { status: 'return'; value: TReturn }\n  | { status: 'error'; error: unknown };\nfunction createManagedIterator<TYield, TReturn>(\n  iterable: AsyncIterable<TYield, TReturn>,\n  onResult: (result: ManagedIteratorResult<TYield, TReturn>) => void,\n) {\n  const iterator = iterable[Symbol.asyncIterator]();\n  let state: 'idle' | 'pending' | 'done' = 'idle';\n\n  function cleanup() {\n    state = 'done';\n    onResult = () => {\n      // noop\n    };\n  }\n\n  function pull() {\n    if (state !== 'idle') {\n      return;\n    }\n    state = 'pending';\n\n    const next = iterator.next();\n    next\n      .then((result) => {\n        if (result.done) {\n          state = 'done';\n          onResult({ status: 'return', value: result.value });\n          cleanup();\n          return;\n        }\n        state = 'idle';\n        onResult({ status: 'yield', value: result.value });\n      })\n      .catch((cause) => {\n        onResult({ status: 'error', error: cause });\n        cleanup();\n      });\n  }\n\n  return {\n    pull,\n    destroy: async () => {\n      cleanup();\n      await iterator.return?.();\n    },\n  };\n}\ntype ManagedIterator<TYield, TReturn> = ReturnType<\n  typeof createManagedIterator<TYield, TReturn>\n>;\n\ninterface MergedAsyncIterables<TYield>\n  extends AsyncIterable<TYield, void, unknown> {\n  add(iterable: AsyncIterable<TYield>): void;\n}\n\n/**\n * Creates a new async iterable that merges multiple async iterables into a single stream.\n * Values from the input iterables are yielded in the order they resolve, similar to Promise.race().\n *\n * New iterables can be added dynamically using the returned {@link MergedAsyncIterables.add} method, even after iteration has started.\n *\n * If any of the input iterables throws an error, that error will be propagated through the merged stream.\n * Other iterables will not continue to be processed.\n *\n * @template TYield The type of values yielded by the input iterables\n */\nexport function mergeAsyncIterables<TYield>(): MergedAsyncIterables<TYield> {\n  let state: 'idle' | 'pending' | 'done' = 'idle';\n  let flushSignal = createDeferred();\n\n  /**\n   * used while {@link state} is `idle`\n   */\n  const iterables: AsyncIterable<TYield, void, unknown>[] = [];\n  /**\n   * used while {@link state} is `pending`\n   */\n  const iterators = new Set<ManagedIterator<TYield, void>>();\n\n  const buffer: Array<\n    [\n      iterator: ManagedIterator<TYield, void>,\n      result: Exclude<\n        ManagedIteratorResult<TYield, void>,\n        { status: 'return' }\n      >,\n    ]\n  > = [];\n\n  function initIterable(iterable: AsyncIterable<TYield, void, unknown>) {\n    if (state !== 'pending') {\n      // shouldn't happen\n      return;\n    }\n    const iterator = createManagedIterator(iterable, (result) => {\n      if (state !== 'pending') {\n        // shouldn't happen\n        return;\n      }\n      switch (result.status) {\n        case 'yield':\n          buffer.push([iterator, result]);\n          break;\n        case 'return':\n          iterators.delete(iterator);\n          break;\n        case 'error':\n          buffer.push([iterator, result]);\n          iterators.delete(iterator);\n          break;\n      }\n      flushSignal.resolve();\n    });\n    iterators.add(iterator);\n    iterator.pull();\n  }\n\n  return {\n    add(iterable: AsyncIterable<TYield, void, unknown>) {\n      switch (state) {\n        case 'idle':\n          iterables.push(iterable);\n          break;\n        case 'pending':\n          initIterable(iterable);\n          break;\n        case 'done': {\n          // shouldn't happen\n          break;\n        }\n      }\n    },\n    async *[Symbol.asyncIterator]() {\n      if (state !== 'idle') {\n        throw new Error('Cannot iterate twice');\n      }\n      state = 'pending';\n\n      await using _finally = makeAsyncResource({}, async () => {\n        state = 'done';\n\n        const errors: unknown[] = [];\n        await Promise.all(\n          Array.from(iterators.values()).map(async (it) => {\n            try {\n              await it.destroy();\n            } catch (cause) {\n              errors.push(cause);\n            }\n          }),\n        );\n        buffer.length = 0;\n        iterators.clear();\n        flushSignal.resolve();\n\n        if (errors.length > 0) {\n          throw new AggregateError(errors);\n        }\n      });\n\n      while (iterables.length > 0) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        initIterable(iterables.shift()!);\n      }\n\n      while (iterators.size > 0) {\n        await flushSignal.promise;\n\n        while (buffer.length > 0) {\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          const [iterator, result] = buffer.shift()!;\n\n          switch (result.status) {\n            case 'yield':\n              yield result.value;\n              iterator.pull();\n              break;\n            case 'error':\n              throw result.error;\n          }\n        }\n        flushSignal = createDeferred();\n      }\n    },\n  };\n}\n","/**\n * Creates a ReadableStream from an AsyncIterable.\n *\n * @param iterable - The source AsyncIterable to stream from\n * @returns A ReadableStream that yields values from the AsyncIterable\n */\nexport function readableStreamFrom<TYield>(\n  iterable: AsyncIterable<TYield, void>,\n): ReadableStream<TYield> {\n  const iterator = iterable[Symbol.asyncIterator]();\n\n  return new ReadableStream({\n    async cancel() {\n      await iterator.return?.();\n    },\n\n    async pull(controller) {\n      const result = await iterator.next();\n\n      if (result.done) {\n        controller.close();\n        return;\n      }\n\n      controller.enqueue(result.value);\n    },\n  });\n}\n","import { Unpromise } from '../../../vendor/unpromise';\nimport { iteratorResource } from './asyncIterable';\nimport { disposablePromiseTimerResult, timerResource } from './timerResource';\n\nexport const PING_SYM = Symbol('ping');\n\n/**\n * Derives a new {@link AsyncGenerator} based of {@link iterable}, that yields {@link PING_SYM}\n * whenever no value has been yielded for {@link pingIntervalMs}.\n */\nexport async function* withPing<TValue>(\n  iterable: AsyncIterable<TValue>,\n  pingIntervalMs: number,\n): AsyncGenerator<TValue | typeof PING_SYM> {\n  await using iterator = iteratorResource(iterable);\n\n  // declaration outside the loop for garbage collection reasons\n  let result:\n    | null\n    | IteratorResult<TValue>\n    | typeof disposablePromiseTimerResult;\n\n  let nextPromise = iterator.next();\n\n  while (true) {\n    using pingPromise = timerResource(pingIntervalMs);\n\n    result = await Unpromise.race([nextPromise, pingPromise.start()]);\n\n    if (result === disposablePromiseTimerResult) {\n      // cancelled\n\n      yield PING_SYM;\n      continue;\n    }\n\n    if (result.done) {\n      return result.value;\n    }\n\n    nextPromise = iterator.next();\n    yield result.value;\n\n    // free up reference for garbage collection\n    result = null;\n  }\n}\n","function _asyncIterator(r) {\n  var n,\n    t,\n    o,\n    e = 2;\n  for (\"undefined\" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;) {\n    if (t && null != (n = r[t])) return n.call(r);\n    if (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r));\n    t = \"@@asyncIterator\", o = \"@@iterator\";\n  }\n  throw new TypeError(\"Object is not async iterable\");\n}\nfunction AsyncFromSyncIterator(r) {\n  function AsyncFromSyncIteratorContinuation(r) {\n    if (Object(r) !== r) return Promise.reject(new TypeError(r + \" is not an object.\"));\n    var n = r.done;\n    return Promise.resolve(r.value).then(function (r) {\n      return {\n        value: r,\n        done: n\n      };\n    });\n  }\n  return AsyncFromSyncIterator = function AsyncFromSyncIterator(r) {\n    this.s = r, this.n = r.next;\n  }, AsyncFromSyncIterator.prototype = {\n    s: null,\n    n: null,\n    next: function next() {\n      return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));\n    },\n    \"return\": function _return(r) {\n      var n = this.s[\"return\"];\n      return void 0 === n ? Promise.resolve({\n        value: r,\n        done: !0\n      }) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));\n    },\n    \"throw\": function _throw(r) {\n      var n = this.s[\"return\"];\n      return void 0 === n ? Promise.reject(r) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));\n    }\n  }, new AsyncFromSyncIterator(r);\n}\nmodule.exports = _asyncIterator, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","import { isAsyncIterable, isFunction, isObject, run } from '../utils';\nimport { iteratorResource } from './utils/asyncIterable';\nimport type { Deferred } from './utils/createDeferred';\nimport { createDeferred } from './utils/createDeferred';\nimport { makeResource } from './utils/disposable';\nimport { mergeAsyncIterables } from './utils/mergeAsyncIterables';\nimport { readableStreamFrom } from './utils/readableStreamFrom';\nimport { PING_SYM, withPing } from './utils/withPing';\n\n/**\n * A subset of the standard ReadableStream properties needed by tRPC internally.\n * @see ReadableStream from lib.dom.d.ts\n */\nexport type WebReadableStreamEsque = {\n  getReader: () => ReadableStreamDefaultReader<Uint8Array>;\n};\n\nexport type NodeJSReadableStreamEsque = {\n  on(\n    eventName: string | symbol,\n    listener: (...args: any[]) => void,\n  ): NodeJSReadableStreamEsque;\n};\n\nfunction isPlainObject(value: unknown): value is Record<string, unknown> {\n  return Object.prototype.toString.call(value) === '[object Object]';\n}\n\n// ---------- types\nconst CHUNK_VALUE_TYPE_PROMISE = 0;\ntype CHUNK_VALUE_TYPE_PROMISE = typeof CHUNK_VALUE_TYPE_PROMISE;\nconst CHUNK_VALUE_TYPE_ASYNC_ITERABLE = 1;\ntype CHUNK_VALUE_TYPE_ASYNC_ITERABLE = typeof CHUNK_VALUE_TYPE_ASYNC_ITERABLE;\n\nconst PROMISE_STATUS_FULFILLED = 0;\ntype PROMISE_STATUS_FULFILLED = typeof PROMISE_STATUS_FULFILLED;\nconst PROMISE_STATUS_REJECTED = 1;\ntype PROMISE_STATUS_REJECTED = typeof PROMISE_STATUS_REJECTED;\n\nconst ASYNC_ITERABLE_STATUS_RETURN = 0;\ntype ASYNC_ITERABLE_STATUS_RETURN = typeof ASYNC_ITERABLE_STATUS_RETURN;\nconst ASYNC_ITERABLE_STATUS_YIELD = 1;\ntype ASYNC_ITERABLE_STATUS_YIELD = typeof ASYNC_ITERABLE_STATUS_YIELD;\nconst ASYNC_ITERABLE_STATUS_ERROR = 2;\ntype ASYNC_ITERABLE_STATUS_ERROR = typeof ASYNC_ITERABLE_STATUS_ERROR;\n\ntype ChunkDefinitionKey =\n  // root should be replaced\n  | null\n  // at array path\n  | number\n  // at key path\n  | string;\n\ntype ChunkIndex = number & { __chunkIndex: true };\ntype ChunkValueType =\n  | CHUNK_VALUE_TYPE_PROMISE\n  | CHUNK_VALUE_TYPE_ASYNC_ITERABLE;\ntype ChunkDefinition = [\n  key: ChunkDefinitionKey,\n  type: ChunkValueType,\n  chunkId: ChunkIndex,\n];\ntype EncodedValue = [\n  // data\n  [unknown] | [],\n  // chunk descriptions\n  ...ChunkDefinition[],\n];\n\ntype Head = Record<string, EncodedValue>;\ntype PromiseChunk =\n  | [\n      chunkIndex: ChunkIndex,\n      status: PROMISE_STATUS_FULFILLED,\n      value: EncodedValue,\n    ]\n  | [chunkIndex: ChunkIndex, status: PROMISE_STATUS_REJECTED, error: unknown];\ntype IterableChunk =\n  | [\n      chunkIndex: ChunkIndex,\n      status: ASYNC_ITERABLE_STATUS_RETURN,\n      value: EncodedValue,\n    ]\n  | [\n      chunkIndex: ChunkIndex,\n      status: ASYNC_ITERABLE_STATUS_YIELD,\n      value: EncodedValue,\n    ]\n  | [\n      chunkIndex: ChunkIndex,\n      status: ASYNC_ITERABLE_STATUS_ERROR,\n      error: unknown,\n    ];\ntype ChunkData = PromiseChunk | IterableChunk;\ntype PlaceholderValue = 0 & { __placeholder: true };\nexport function isPromise(value: unknown): value is Promise<unknown> {\n  return (\n    (isObject(value) || isFunction(value)) &&\n    typeof value?.['then'] === 'function' &&\n    typeof value?.['catch'] === 'function'\n  );\n}\n\ntype Serialize = (value: any) => any;\ntype Deserialize = (value: any) => any;\n\ntype PathArray = readonly (string | number)[];\nexport type ProducerOnError = (opts: {\n  error: unknown;\n  path: PathArray;\n}) => void;\nexport interface JSONLProducerOptions {\n  serialize?: Serialize;\n  data: Record<string, unknown> | unknown[];\n  onError?: ProducerOnError;\n  formatError?: (opts: { error: unknown; path: PathArray }) => unknown;\n  maxDepth?: number;\n  /**\n   * Interval in milliseconds to send a ping to the client to keep the connection alive\n   * This will be sent as a whitespace character\n   * @default undefined\n   */\n  pingMs?: number;\n}\n\nclass MaxDepthError extends Error {\n  constructor(public path: (string | number)[]) {\n    super('Max depth reached at path: ' + path.join('.'));\n  }\n}\n\nasync function* createBatchStreamProducer(\n  opts: JSONLProducerOptions,\n): AsyncIterable<Head | ChunkData | typeof PING_SYM, void> {\n  const { data } = opts;\n  let counter = 0 as ChunkIndex;\n  const placeholder = 0 as PlaceholderValue;\n\n  const mergedIterables = mergeAsyncIterables<ChunkData>();\n  function registerAsync(\n    callback: (idx: ChunkIndex) => AsyncIterable<ChunkData, void>,\n  ) {\n    const idx = counter++ as ChunkIndex;\n\n    const iterable = callback(idx);\n    mergedIterables.add(iterable);\n\n    return idx;\n  }\n\n  function encodePromise(promise: Promise<unknown>, path: (string | number)[]) {\n    return registerAsync(async function* (idx) {\n      const error = checkMaxDepth(path);\n      if (error) {\n        // Catch any errors from the original promise to ensure they're reported\n        promise.catch((cause) => {\n          opts.onError?.({ error: cause, path });\n        });\n        // Replace the promise with a rejected one containing the max depth error\n        promise = Promise.reject(error);\n      }\n      try {\n        const next = await promise;\n        yield [idx, PROMISE_STATUS_FULFILLED, encode(next, path)];\n      } catch (cause) {\n        opts.onError?.({ error: cause, path });\n        yield [\n          idx,\n          PROMISE_STATUS_REJECTED,\n          opts.formatError?.({ error: cause, path }),\n        ];\n      }\n    });\n  }\n  function encodeAsyncIterable(\n    iterable: AsyncIterable<unknown>,\n    path: (string | number)[],\n  ) {\n    return registerAsync(async function* (idx) {\n      const error = checkMaxDepth(path);\n      if (error) {\n        throw error;\n      }\n      await using iterator = iteratorResource(iterable);\n\n      try {\n        while (true) {\n          const next = await iterator.next();\n          if (next.done) {\n            yield [idx, ASYNC_ITERABLE_STATUS_RETURN, encode(next.value, path)];\n            break;\n          }\n          yield [idx, ASYNC_ITERABLE_STATUS_YIELD, encode(next.value, path)];\n        }\n      } catch (cause) {\n        opts.onError?.({ error: cause, path });\n\n        yield [\n          idx,\n          ASYNC_ITERABLE_STATUS_ERROR,\n          opts.formatError?.({ error: cause, path }),\n        ];\n      }\n    });\n  }\n  function checkMaxDepth(path: (string | number)[]) {\n    if (opts.maxDepth && path.length > opts.maxDepth) {\n      return new MaxDepthError(path);\n    }\n    return null;\n  }\n  function encodeAsync(\n    value: unknown,\n    path: (string | number)[],\n  ): null | [type: ChunkValueType, chunkId: ChunkIndex] {\n    if (isPromise(value)) {\n      return [CHUNK_VALUE_TYPE_PROMISE, encodePromise(value, path)];\n    }\n    if (isAsyncIterable(value)) {\n      if (opts.maxDepth && path.length >= opts.maxDepth) {\n        throw new Error('Max depth reached');\n      }\n      return [\n        CHUNK_VALUE_TYPE_ASYNC_ITERABLE,\n        encodeAsyncIterable(value, path),\n      ];\n    }\n    return null;\n  }\n  function encode(value: unknown, path: (string | number)[]): EncodedValue {\n    if (value === undefined) {\n      return [[]];\n    }\n    const reg = encodeAsync(value, path);\n    if (reg) {\n      return [[placeholder], [null, ...reg]];\n    }\n\n    if (!isPlainObject(value)) {\n      return [[value]];\n    }\n\n    const newObj: Record<string, unknown> = {};\n    const asyncValues: ChunkDefinition[] = [];\n    for (const [key, item] of Object.entries(value)) {\n      const transformed = encodeAsync(item, [...path, key]);\n      if (!transformed) {\n        newObj[key] = item;\n        continue;\n      }\n      newObj[key] = placeholder;\n      asyncValues.push([key, ...transformed]);\n    }\n    return [[newObj], ...asyncValues];\n  }\n\n  const newHead: Head = {};\n  for (const [key, item] of Object.entries(data)) {\n    newHead[key] = encode(item, [key]);\n  }\n\n  yield newHead;\n\n  let iterable: AsyncIterable<ChunkData | typeof PING_SYM, void> =\n    mergedIterables;\n  if (opts.pingMs) {\n    iterable = withPing(mergedIterables, opts.pingMs);\n  }\n\n  for await (const value of iterable) {\n    yield value;\n  }\n}\n/**\n * JSON Lines stream producer\n * @see https://jsonlines.org/\n */\nexport function jsonlStreamProducer(opts: JSONLProducerOptions) {\n  let stream = readableStreamFrom(createBatchStreamProducer(opts));\n\n  const { serialize } = opts;\n  if (serialize) {\n    stream = stream.pipeThrough(\n      new TransformStream({\n        transform(chunk, controller) {\n          if (chunk === PING_SYM) {\n            controller.enqueue(PING_SYM);\n          } else {\n            controller.enqueue(serialize(chunk));\n          }\n        },\n      }),\n    );\n  }\n\n  return stream\n    .pipeThrough(\n      new TransformStream({\n        transform(chunk, controller) {\n          if (chunk === PING_SYM) {\n            controller.enqueue(' ');\n          } else {\n            controller.enqueue(JSON.stringify(chunk) + '\\n');\n          }\n        },\n      }),\n    )\n    .pipeThrough(new TextEncoderStream());\n}\n\nclass AsyncError extends Error {\n  constructor(public readonly data: unknown) {\n    super('Received error from server');\n  }\n}\nexport type ConsumerOnError = (opts: { error: unknown }) => void;\n\nconst nodeJsStreamToReaderEsque = (source: NodeJSReadableStreamEsque) => {\n  return {\n    getReader() {\n      const stream = new ReadableStream<Uint8Array>({\n        start(controller) {\n          source.on('data', (chunk) => {\n            controller.enqueue(chunk);\n          });\n          source.on('end', () => {\n            controller.close();\n          });\n          source.on('error', (error) => {\n            controller.error(error);\n          });\n        },\n      });\n      return stream.getReader();\n    },\n  };\n};\n\nfunction createLineAccumulator(\n  from: NodeJSReadableStreamEsque | WebReadableStreamEsque,\n) {\n  const reader =\n    'getReader' in from\n      ? from.getReader()\n      : nodeJsStreamToReaderEsque(from).getReader();\n\n  let lineAggregate = '';\n\n  return new ReadableStream({\n    async pull(controller) {\n      const { done, value } = await reader.read();\n\n      if (done) {\n        controller.close();\n      } else {\n        controller.enqueue(value);\n      }\n    },\n    cancel() {\n      return reader.cancel();\n    },\n  })\n    .pipeThrough(new TextDecoderStream())\n    .pipeThrough(\n      new TransformStream<string, string>({\n        transform(chunk, controller) {\n          lineAggregate += chunk;\n          const parts = lineAggregate.split('\\n');\n          lineAggregate = parts.pop() ?? '';\n          for (const part of parts) {\n            controller.enqueue(part);\n          }\n        },\n      }),\n    );\n}\nfunction createConsumerStream<THead>(\n  from: NodeJSReadableStreamEsque | WebReadableStreamEsque,\n) {\n  const stream = createLineAccumulator(from);\n\n  let sentHead = false;\n  return stream.pipeThrough(\n    new TransformStream<string, ChunkData | THead>({\n      transform(line, controller) {\n        if (!sentHead) {\n          const head = JSON.parse(line);\n          controller.enqueue(head as THead);\n          sentHead = true;\n        } else {\n          const chunk: ChunkData = JSON.parse(line);\n          controller.enqueue(chunk);\n        }\n      },\n    }),\n  );\n}\n\n/**\n * Creates a handler for managing stream controllers and their lifecycle\n */\nfunction createStreamsManager(abortController: AbortController) {\n  const controllerMap = new Map<\n    ChunkIndex,\n    ReturnType<typeof createStreamController>\n  >();\n\n  /**\n   * Checks if there are no pending controllers or deferred promises\n   */\n  function isEmpty() {\n    return Array.from(controllerMap.values()).every((c) => c.closed);\n  }\n\n  /**\n   * Creates a stream controller\n   */\n  function createStreamController() {\n    let originalController: ReadableStreamDefaultController<ChunkData>;\n    const stream = new ReadableStream<ChunkData>({\n      start(controller) {\n        originalController = controller;\n      },\n    });\n\n    const streamController = {\n      enqueue: (v: ChunkData) => originalController.enqueue(v),\n      close: () => {\n        originalController.close();\n\n        clear();\n\n        if (isEmpty()) {\n          abortController.abort();\n        }\n      },\n      closed: false,\n      getReaderResource: () => {\n        const reader = stream.getReader();\n\n        return makeResource(reader, () => {\n          reader.releaseLock();\n          streamController.close();\n        });\n      },\n      error: (reason: unknown) => {\n        originalController.error(reason);\n        clear();\n      },\n    };\n    function clear() {\n      Object.assign(streamController, {\n        closed: true,\n        close: () => {\n          // noop\n        },\n        enqueue: () => {\n          // noop\n        },\n        getReaderResource: null,\n        error: () => {\n          // noop\n        },\n      });\n    }\n\n    return streamController;\n  }\n\n  /**\n   * Gets or creates a stream controller\n   */\n  function getOrCreate(chunkId: ChunkIndex) {\n    let c = controllerMap.get(chunkId);\n    if (!c) {\n      c = createStreamController();\n      controllerMap.set(chunkId, c);\n    }\n    return c;\n  }\n\n  /**\n   * Cancels all pending controllers and rejects deferred promises\n   */\n  function cancelAll(reason: unknown) {\n    for (const controller of controllerMap.values()) {\n      controller.error(reason);\n    }\n  }\n\n  return {\n    getOrCreate,\n    isEmpty,\n    cancelAll,\n  };\n}\n\n/**\n * JSON Lines stream consumer\n * @see https://jsonlines.org/\n */\nexport async function jsonlStreamConsumer<THead>(opts: {\n  from: NodeJSReadableStreamEsque | WebReadableStreamEsque;\n  deserialize?: Deserialize;\n  onError?: ConsumerOnError;\n  formatError?: (opts: { error: unknown }) => Error;\n  /**\n   * This `AbortController` will be triggered when there are no more listeners to the stream.\n   */\n  abortController: AbortController;\n}) {\n  const { deserialize = (v) => v } = opts;\n\n  let source = createConsumerStream<Head>(opts.from);\n  if (deserialize) {\n    source = source.pipeThrough(\n      new TransformStream({\n        transform(chunk, controller) {\n          controller.enqueue(deserialize(chunk));\n        },\n      }),\n    );\n  }\n  let headDeferred: null | Deferred<THead> = createDeferred();\n\n  const streamManager = createStreamsManager(opts.abortController);\n\n  function decodeChunkDefinition(value: ChunkDefinition) {\n    const [_path, type, chunkId] = value;\n\n    const controller = streamManager.getOrCreate(chunkId);\n\n    switch (type) {\n      case CHUNK_VALUE_TYPE_PROMISE: {\n        return run(async () => {\n          using reader = controller.getReaderResource();\n\n          const { value } = await reader.read();\n          const [_chunkId, status, data] = value as PromiseChunk;\n          switch (status) {\n            case PROMISE_STATUS_FULFILLED:\n              return decode(data);\n            case PROMISE_STATUS_REJECTED:\n              throw opts.formatError?.({ error: data }) ?? new AsyncError(data);\n          }\n        });\n      }\n      case CHUNK_VALUE_TYPE_ASYNC_ITERABLE: {\n        return run(async function* () {\n          using reader = controller.getReaderResource();\n\n          while (true) {\n            const { value } = await reader.read();\n\n            const [_chunkId, status, data] = value as IterableChunk;\n\n            switch (status) {\n              case ASYNC_ITERABLE_STATUS_YIELD:\n                yield decode(data);\n                break;\n              case ASYNC_ITERABLE_STATUS_RETURN:\n                return decode(data);\n              case ASYNC_ITERABLE_STATUS_ERROR:\n                throw (\n                  opts.formatError?.({ error: data }) ?? new AsyncError(data)\n                );\n            }\n          }\n        });\n      }\n    }\n  }\n\n  function decode(value: EncodedValue): unknown {\n    const [[data], ...asyncProps] = value;\n\n    for (const value of asyncProps) {\n      const [key] = value;\n      const decoded = decodeChunkDefinition(value);\n\n      if (key === null) {\n        return decoded;\n      }\n\n      (data as any)[key] = decoded;\n    }\n    return data;\n  }\n\n  const closeOrAbort = (reason: unknown) => {\n    headDeferred?.reject(reason);\n    streamManager.cancelAll(reason);\n  };\n  source\n    .pipeTo(\n      new WritableStream({\n        write(chunkOrHead) {\n          if (headDeferred) {\n            const head = chunkOrHead as Record<number | string, unknown>;\n\n            for (const [key, value] of Object.entries(chunkOrHead)) {\n              const parsed = decode(value as any);\n              head[key] = parsed;\n            }\n            headDeferred.resolve(head as THead);\n            headDeferred = null;\n\n            return;\n          }\n          const chunk = chunkOrHead as ChunkData;\n          const [idx] = chunk;\n\n          const controller = streamManager.getOrCreate(idx);\n          controller.enqueue(chunk);\n        },\n        close: () => closeOrAbort(new Error('Stream closed')),\n        abort: closeOrAbort,\n      }),\n      {\n        signal: opts.abortController.signal,\n      },\n    )\n    .catch((error) => {\n      opts.onError?.({ error });\n      closeOrAbort(error);\n    });\n\n  return [await headDeferred.promise, streamManager] as const;\n}\n","var OverloadYield = require(\"./OverloadYield.js\");\nfunction _asyncGeneratorDelegate(t) {\n  var e = {},\n    n = !1;\n  function pump(e, r) {\n    return n = !0, r = new Promise(function (n) {\n      n(t[e](r));\n    }), {\n      done: !1,\n      value: new OverloadYield(r, 1)\n    };\n  }\n  return e[\"undefined\" != typeof Symbol && Symbol.iterator || \"@@iterator\"] = function () {\n    return this;\n  }, e.next = function (t) {\n    return n ? (n = !1, t) : pump(\"next\", t);\n  }, \"function\" == typeof t[\"throw\"] && (e[\"throw\"] = function (t) {\n    if (n) throw n = !1, t;\n    return pump(\"throw\", t);\n  }), \"function\" == typeof t[\"return\"] && (e[\"return\"] = function (t) {\n    return n ? (n = !1, t) : pump(\"return\", t);\n  }), e;\n}\nmodule.exports = _asyncGeneratorDelegate, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","import { Unpromise } from '../../vendor/unpromise';\nimport { getTRPCErrorFromUnknown } from '../error/TRPCError';\nimport { isAbortError } from '../http/abortError';\nimport type { MaybePromise } from '../types';\nimport { identity, run } from '../utils';\nimport type { EventSourceLike } from './sse.types';\nimport type { inferTrackedOutput } from './tracked';\nimport { isTrackedEnvelope } from './tracked';\nimport { takeWithGrace, withMaxDuration } from './utils/asyncIterable';\nimport { makeAsyncResource } from './utils/disposable';\nimport { readableStreamFrom } from './utils/readableStreamFrom';\nimport {\n  disposablePromiseTimerResult,\n  timerResource,\n} from './utils/timerResource';\nimport { PING_SYM, withPing } from './utils/withPing';\n\ntype Serialize = (value: any) => any;\ntype Deserialize = (value: any) => any;\n\n/**\n * @internal\n */\nexport interface SSEPingOptions {\n  /**\n   * Enable ping comments sent from the server\n   * @default false\n   */\n  enabled: boolean;\n  /**\n   * Interval in milliseconds\n   * @default 1000\n   */\n  intervalMs?: number;\n}\n\nexport interface SSEClientOptions {\n  /**\n   * Timeout and reconnect after inactivity in milliseconds\n   * @default undefined\n   */\n  reconnectAfterInactivityMs?: number;\n}\n\nexport interface SSEStreamProducerOptions<TValue = unknown> {\n  serialize?: Serialize;\n  data: AsyncIterable<TValue>;\n\n  maxDepth?: number;\n  ping?: SSEPingOptions;\n  /**\n   * Maximum duration in milliseconds for the request before ending the stream\n   * @default undefined\n   */\n  maxDurationMs?: number;\n  /**\n   * End the request immediately after data is sent\n   * Only useful for serverless runtimes that do not support streaming responses\n   * @default false\n   */\n  emitAndEndImmediately?: boolean;\n  formatError?: (opts: { error: unknown }) => unknown;\n  /**\n   * Client-specific options - these will be sent to the client as part of the first message\n   * @default {}\n   */\n  client?: SSEClientOptions;\n}\n\nconst PING_EVENT = 'ping';\nconst SERIALIZED_ERROR_EVENT = 'serialized-error';\nconst CONNECTED_EVENT = 'connected';\nconst RETURN_EVENT = 'return';\n\ninterface SSEvent {\n  id?: string;\n  data: unknown;\n  comment?: string;\n  event?: string;\n}\n/**\n *\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n */\nexport function sseStreamProducer<TValue = unknown>(\n  opts: SSEStreamProducerOptions<TValue>,\n) {\n  const { serialize = identity } = opts;\n\n  const ping: Required<SSEPingOptions> = {\n    enabled: opts.ping?.enabled ?? false,\n    intervalMs: opts.ping?.intervalMs ?? 1000,\n  };\n  const client: SSEClientOptions = opts.client ?? {};\n\n  if (\n    ping.enabled &&\n    client.reconnectAfterInactivityMs &&\n    ping.intervalMs > client.reconnectAfterInactivityMs\n  ) {\n    throw new Error(\n      `Ping interval must be less than client reconnect interval to prevent unnecessary reconnection - ping.intervalMs: ${ping.intervalMs} client.reconnectAfterInactivityMs: ${client.reconnectAfterInactivityMs}`,\n    );\n  }\n\n  async function* generator(): AsyncIterable<SSEvent, void> {\n    yield {\n      event: CONNECTED_EVENT,\n      data: JSON.stringify(client),\n    };\n\n    type TIteratorValue = Awaited<TValue> | typeof PING_SYM;\n\n    let iterable: AsyncIterable<TValue | typeof PING_SYM> = opts.data;\n\n    if (opts.emitAndEndImmediately) {\n      iterable = takeWithGrace(iterable, {\n        count: 1,\n        gracePeriodMs: 1,\n      });\n    }\n\n    if (\n      opts.maxDurationMs &&\n      opts.maxDurationMs > 0 &&\n      opts.maxDurationMs !== Infinity\n    ) {\n      iterable = withMaxDuration(iterable, {\n        maxDurationMs: opts.maxDurationMs,\n      });\n    }\n\n    if (ping.enabled && ping.intervalMs !== Infinity && ping.intervalMs > 0) {\n      iterable = withPing(iterable, ping.intervalMs);\n    }\n\n    // We need those declarations outside the loop for garbage collection reasons. If they were\n    // declared inside, they would not be freed until the next value is present.\n    let value: null | TIteratorValue;\n    let chunk: null | SSEvent;\n\n    for await (value of iterable) {\n      if (value === PING_SYM) {\n        yield { event: PING_EVENT, data: '' };\n        continue;\n      }\n\n      chunk = isTrackedEnvelope(value)\n        ? { id: value[0], data: value[1] }\n        : { data: value };\n\n      chunk.data = JSON.stringify(serialize(chunk.data));\n\n      yield chunk;\n\n      // free up references for garbage collection\n      value = null;\n      chunk = null;\n    }\n  }\n\n  async function* generatorWithErrorHandling(): AsyncIterable<SSEvent, void> {\n    try {\n      yield* generator();\n\n      yield {\n        event: RETURN_EVENT,\n        data: '',\n      };\n    } catch (cause) {\n      if (isAbortError(cause)) {\n        // ignore abort errors, send any other errors\n        return;\n      }\n      // `err` must be caused by `opts.data`, `JSON.stringify` or `serialize`.\n      // So, a user error in any case.\n      const error = getTRPCErrorFromUnknown(cause);\n      const data = opts.formatError?.({ error }) ?? null;\n      yield {\n        event: SERIALIZED_ERROR_EVENT,\n        data: JSON.stringify(serialize(data)),\n      };\n    }\n  }\n\n  const stream = readableStreamFrom(generatorWithErrorHandling());\n\n  return stream\n    .pipeThrough(\n      new TransformStream({\n        transform(chunk, controller: TransformStreamDefaultController<string>) {\n          if ('event' in chunk) {\n            controller.enqueue(`event: ${chunk.event}\\n`);\n          }\n          if ('data' in chunk) {\n            controller.enqueue(`data: ${chunk.data}\\n`);\n          }\n          if ('id' in chunk) {\n            controller.enqueue(`id: ${chunk.id}\\n`);\n          }\n          if ('comment' in chunk) {\n            controller.enqueue(`: ${chunk.comment}\\n`);\n          }\n          controller.enqueue('\\n\\n');\n        },\n      }),\n    )\n    .pipeThrough(new TextEncoderStream());\n}\n\ninterface ConsumerStreamResultBase<TConfig extends ConsumerConfig> {\n  eventSource: InstanceType<TConfig['EventSource']> | null;\n}\n\ninterface ConsumerStreamResultData<TConfig extends ConsumerConfig>\n  extends ConsumerStreamResultBase<TConfig> {\n  type: 'data';\n  data: inferTrackedOutput<TConfig['data']>;\n}\n\ninterface ConsumerStreamResultError<TConfig extends ConsumerConfig>\n  extends ConsumerStreamResultBase<TConfig> {\n  type: 'serialized-error';\n  error: TConfig['error'];\n}\n\ninterface ConsumerStreamResultConnecting<TConfig extends ConsumerConfig>\n  extends ConsumerStreamResultBase<TConfig> {\n  type: 'connecting';\n  event: EventSourceLike.EventOf<TConfig['EventSource']> | null;\n}\ninterface ConsumerStreamResultTimeout<TConfig extends ConsumerConfig>\n  extends ConsumerStreamResultBase<TConfig> {\n  type: 'timeout';\n  ms: number;\n}\ninterface ConsumerStreamResultPing<TConfig extends ConsumerConfig>\n  extends ConsumerStreamResultBase<TConfig> {\n  type: 'ping';\n}\n\ninterface ConsumerStreamResultConnected<TConfig extends ConsumerConfig>\n  extends ConsumerStreamResultBase<TConfig> {\n  type: 'connected';\n  options: SSEClientOptions;\n}\n\ntype ConsumerStreamResult<TConfig extends ConsumerConfig> =\n  | ConsumerStreamResultData<TConfig>\n  | ConsumerStreamResultError<TConfig>\n  | ConsumerStreamResultConnecting<TConfig>\n  | ConsumerStreamResultTimeout<TConfig>\n  | ConsumerStreamResultPing<TConfig>\n  | ConsumerStreamResultConnected<TConfig>;\n\nexport interface SSEStreamConsumerOptions<TConfig extends ConsumerConfig> {\n  url: () => MaybePromise<string>;\n  init: () =>\n    | MaybePromise<EventSourceLike.InitDictOf<TConfig['EventSource']>>\n    | undefined;\n  signal: AbortSignal;\n  deserialize?: Deserialize;\n  EventSource: TConfig['EventSource'];\n}\n\ninterface ConsumerConfig {\n  data: unknown;\n  error: unknown;\n  EventSource: EventSourceLike.AnyConstructor;\n}\n\nasync function withTimeout<T>(opts: {\n  promise: Promise<T>;\n  timeoutMs: number;\n  onTimeout: () => Promise<NoInfer<T>>;\n}): Promise<T> {\n  using timeoutPromise = timerResource(opts.timeoutMs);\n  const res = await Unpromise.race([opts.promise, timeoutPromise.start()]);\n\n  if (res === disposablePromiseTimerResult) {\n    return await opts.onTimeout();\n  }\n  return res;\n}\n\n/**\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n */\nexport function sseStreamConsumer<TConfig extends ConsumerConfig>(\n  opts: SSEStreamConsumerOptions<TConfig>,\n): AsyncIterable<ConsumerStreamResult<TConfig>> {\n  const { deserialize = (v) => v } = opts;\n\n  let clientOptions: SSEClientOptions = {};\n\n  const signal = opts.signal;\n\n  let _es: InstanceType<TConfig['EventSource']> | null = null;\n\n  const createStream = () =>\n    new ReadableStream<ConsumerStreamResult<TConfig>>({\n      async start(controller) {\n        const [url, init] = await Promise.all([opts.url(), opts.init()]);\n        const eventSource = (_es = new opts.EventSource(\n          url,\n          init,\n        ) as InstanceType<TConfig['EventSource']>);\n\n        controller.enqueue({\n          type: 'connecting',\n          eventSource: _es,\n          event: null,\n        });\n\n        eventSource.addEventListener(CONNECTED_EVENT, (_msg) => {\n          const msg = _msg as EventSourceLike.MessageEvent;\n\n          const options: SSEClientOptions = JSON.parse(msg.data);\n\n          clientOptions = options;\n          controller.enqueue({\n            type: 'connected',\n            options,\n            eventSource,\n          });\n        });\n\n        eventSource.addEventListener(SERIALIZED_ERROR_EVENT, (_msg) => {\n          const msg = _msg as EventSourceLike.MessageEvent;\n\n          controller.enqueue({\n            type: 'serialized-error',\n            error: deserialize(JSON.parse(msg.data)),\n            eventSource,\n          });\n        });\n        eventSource.addEventListener(PING_EVENT, () => {\n          controller.enqueue({\n            type: 'ping',\n            eventSource,\n          });\n        });\n        eventSource.addEventListener(RETURN_EVENT, () => {\n          eventSource.close();\n          controller.close();\n          _es = null;\n        });\n        eventSource.addEventListener('error', (event) => {\n          if (eventSource.readyState === eventSource.CLOSED) {\n            controller.error(event);\n          } else {\n            controller.enqueue({\n              type: 'connecting',\n              eventSource,\n              event,\n            });\n          }\n        });\n        eventSource.addEventListener('message', (_msg) => {\n          const msg = _msg as EventSourceLike.MessageEvent;\n\n          const chunk = deserialize(JSON.parse(msg.data));\n\n          const def: SSEvent = {\n            data: chunk,\n          };\n          if (msg.lastEventId) {\n            def.id = msg.lastEventId;\n          }\n          controller.enqueue({\n            type: 'data',\n            data: def as inferTrackedOutput<TConfig['data']>,\n            eventSource,\n          });\n        });\n\n        const onAbort = () => {\n          try {\n            eventSource.close();\n            controller.close();\n          } catch {\n            // ignore errors in case the controller is already closed\n          }\n        };\n        if (signal.aborted) {\n          onAbort();\n        } else {\n          signal.addEventListener('abort', onAbort);\n        }\n      },\n      cancel() {\n        _es?.close();\n      },\n    });\n\n  const getStreamResource = () => {\n    let stream = createStream();\n    let reader = stream.getReader();\n\n    async function dispose() {\n      await reader.cancel();\n      _es = null;\n    }\n\n    return makeAsyncResource(\n      {\n        read() {\n          return reader.read();\n        },\n        async recreate() {\n          await dispose();\n\n          stream = createStream();\n          reader = stream.getReader();\n        },\n      },\n      dispose,\n    );\n  };\n\n  return run(async function* () {\n    await using stream = getStreamResource();\n\n    while (true) {\n      let promise = stream.read();\n\n      const timeoutMs = clientOptions.reconnectAfterInactivityMs;\n      if (timeoutMs) {\n        promise = withTimeout({\n          promise,\n          timeoutMs,\n          onTimeout: async () => {\n            const res: Awaited<typeof promise> = {\n              value: {\n                type: 'timeout',\n                ms: timeoutMs,\n                eventSource: _es,\n              },\n              done: false,\n            };\n            // Close and release old reader\n            await stream.recreate();\n\n            return res;\n          },\n        });\n      }\n\n      const result = await promise;\n\n      if (result.done) {\n        return result.value;\n      }\n      yield result.value;\n    }\n  });\n}\n\nexport const sseHeaders = {\n  'Content-Type': 'text/event-stream',\n  'Cache-Control': 'no-cache, no-transform',\n  'X-Accel-Buffering': 'no',\n  Connection: 'keep-alive',\n} as const;\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport {\n  isObservable,\n  observableToAsyncIterable,\n} from '../../observable/observable';\nimport { getErrorShape } from '../error/getErrorShape';\nimport { getTRPCErrorFromUnknown, TRPCError } from '../error/TRPCError';\nimport type { ProcedureType } from '../procedure';\nimport {\n  type AnyRouter,\n  type inferRouterContext,\n  type inferRouterError,\n} from '../router';\nimport type { TRPCResponse } from '../rpc';\nimport { isPromise, jsonlStreamProducer } from '../stream/jsonl';\nimport { sseHeaders, sseStreamProducer } from '../stream/sse';\nimport { transformTRPCResponse } from '../transformer';\nimport { isAsyncIterable, isObject, run } from '../utils';\nimport { getRequestInfo } from './contentType';\nimport { getHTTPStatusCode } from './getHTTPStatusCode';\nimport type {\n  HTTPBaseHandlerOptions,\n  ResolveHTTPRequestOptionsContextFn,\n  TRPCRequestInfo,\n} from './types';\n\nfunction errorToAsyncIterable(err: TRPCError): AsyncIterable<never> {\n  return run(async function* () {\n    throw err;\n  });\n}\ntype HTTPMethods =\n  | 'GET'\n  | 'POST'\n  | 'HEAD'\n  | 'OPTIONS'\n  | 'PUT'\n  | 'DELETE'\n  | 'PATCH';\n\nconst TYPE_ACCEPTED_METHOD_MAP: Record<ProcedureType, HTTPMethods[]> = {\n  mutation: ['POST'],\n  query: ['GET'],\n  subscription: ['GET'],\n};\nconst TYPE_ACCEPTED_METHOD_MAP_WITH_METHOD_OVERRIDE: Record<\n  ProcedureType,\n  HTTPMethods[]\n> = {\n  // never allow GET to do a mutation\n  mutation: ['POST'],\n  query: ['GET', 'POST'],\n  subscription: ['GET', 'POST'],\n};\n\ninterface ResolveHTTPRequestOptions<TRouter extends AnyRouter>\n  extends HTTPBaseHandlerOptions<TRouter, Request> {\n  createContext: ResolveHTTPRequestOptionsContextFn<TRouter>;\n  req: Request;\n  path: string;\n  /**\n   * If the request had an issue before reaching the handler\n   */\n  error: TRPCError | null;\n}\n\nfunction initResponse<TRouter extends AnyRouter, TRequest>(initOpts: {\n  ctx: inferRouterContext<TRouter> | undefined;\n  info: TRPCRequestInfo | undefined;\n  responseMeta?: HTTPBaseHandlerOptions<TRouter, TRequest>['responseMeta'];\n  untransformedJSON:\n    | TRPCResponse<unknown, inferRouterError<TRouter>>\n    | TRPCResponse<unknown, inferRouterError<TRouter>>[]\n    | null;\n  errors: TRPCError[];\n  headers: Headers;\n}) {\n  const {\n    ctx,\n    info,\n    responseMeta,\n    untransformedJSON,\n    errors = [],\n    headers,\n  } = initOpts;\n\n  let status = untransformedJSON ? getHTTPStatusCode(untransformedJSON) : 200;\n\n  const eagerGeneration = !untransformedJSON;\n  const data = eagerGeneration\n    ? []\n    : Array.isArray(untransformedJSON)\n      ? untransformedJSON\n      : [untransformedJSON];\n\n  const meta =\n    responseMeta?.({\n      ctx,\n      info,\n      paths: info?.calls.map((call) => call.path),\n      data,\n      errors,\n      eagerGeneration,\n      type:\n        info?.calls.find((call) => call.procedure?._def.type)?.procedure?._def\n          .type ?? 'unknown',\n    }) ?? {};\n\n  if (meta.headers) {\n    if (meta.headers instanceof Headers) {\n      for (const [key, value] of meta.headers.entries()) {\n        headers.append(key, value);\n      }\n    } else {\n      /**\n       * @deprecated, delete in v12\n       */\n      for (const [key, value] of Object.entries(meta.headers)) {\n        if (Array.isArray(value)) {\n          for (const v of value) {\n            headers.append(key, v);\n          }\n        } else if (typeof value === 'string') {\n          headers.set(key, value);\n        }\n      }\n    }\n  }\n  if (meta.status) {\n    status = meta.status;\n  }\n\n  return {\n    status,\n  };\n}\n\nfunction caughtErrorToData<TRouter extends AnyRouter>(\n  cause: unknown,\n  errorOpts: {\n    opts: Pick<\n      ResolveHTTPRequestOptions<TRouter>,\n      'onError' | 'req' | 'router'\n    >;\n    ctx: inferRouterContext<TRouter> | undefined;\n    type: ProcedureType | 'unknown';\n    path?: string;\n    input?: unknown;\n  },\n) {\n  const { router, req, onError } = errorOpts.opts;\n  const error = getTRPCErrorFromUnknown(cause);\n  onError?.({\n    error,\n    path: errorOpts.path,\n    input: errorOpts.input,\n    ctx: errorOpts.ctx,\n    type: errorOpts.type,\n    req,\n  });\n  const untransformedJSON = {\n    error: getErrorShape({\n      config: router._def._config,\n      error,\n      type: errorOpts.type,\n      path: errorOpts.path,\n      input: errorOpts.input,\n      ctx: errorOpts.ctx,\n    }),\n  };\n  const transformedJSON = transformTRPCResponse(\n    router._def._config,\n    untransformedJSON,\n  );\n  const body = JSON.stringify(transformedJSON);\n  return {\n    error,\n    untransformedJSON,\n    body,\n  };\n}\n\n/**\n * Check if a value is a stream-like object\n * - if it's an async iterable\n * - if it's an object with async iterables or promises\n */\nfunction isDataStream(v: unknown) {\n  if (!isObject(v)) {\n    return false;\n  }\n\n  if (isAsyncIterable(v)) {\n    return true;\n  }\n\n  return (\n    Object.values(v).some(isPromise) || Object.values(v).some(isAsyncIterable)\n  );\n}\n\ntype ResultTuple<T> = [undefined, T] | [TRPCError, undefined];\n\nexport async function resolveResponse<TRouter extends AnyRouter>(\n  opts: ResolveHTTPRequestOptions<TRouter>,\n): Promise<Response> {\n  const { router, req } = opts;\n  const headers = new Headers([['vary', 'trpc-accept']]);\n  const config = router._def._config;\n\n  const url = new URL(req.url);\n\n  if (req.method === 'HEAD') {\n    // can be used for lambda warmup\n    return new Response(null, {\n      status: 204,\n    });\n  }\n\n  const allowBatching = opts.allowBatching ?? opts.batching?.enabled ?? true;\n  const allowMethodOverride =\n    (opts.allowMethodOverride ?? false) && req.method === 'POST';\n\n  type $Context = inferRouterContext<TRouter>;\n\n  const infoTuple: ResultTuple<TRPCRequestInfo> = await run(async () => {\n    try {\n      return [\n        undefined,\n        await getRequestInfo({\n          req,\n          path: decodeURIComponent(opts.path),\n          router,\n          searchParams: url.searchParams,\n          headers: opts.req.headers,\n          url,\n        }),\n      ];\n    } catch (cause) {\n      return [getTRPCErrorFromUnknown(cause), undefined];\n    }\n  });\n\n  interface ContextManager {\n    valueOrUndefined: () => $Context | undefined;\n    value: () => $Context;\n    create: (info: TRPCRequestInfo) => Promise<void>;\n  }\n  const ctxManager: ContextManager = run(() => {\n    let result: ResultTuple<$Context> | undefined = undefined;\n    return {\n      valueOrUndefined: () => {\n        if (!result) {\n          return undefined;\n        }\n        return result[1];\n      },\n      value: () => {\n        const [err, ctx] = result!;\n        if (err) {\n          throw err;\n        }\n        return ctx;\n      },\n      create: async (info) => {\n        if (result) {\n          throw new Error(\n            'This should only be called once - report a bug in tRPC',\n          );\n        }\n        try {\n          const ctx = await opts.createContext({\n            info,\n          });\n          result = [undefined, ctx];\n        } catch (cause) {\n          result = [getTRPCErrorFromUnknown(cause), undefined];\n        }\n      },\n    };\n  });\n\n  const methodMapper = allowMethodOverride\n    ? TYPE_ACCEPTED_METHOD_MAP_WITH_METHOD_OVERRIDE\n    : TYPE_ACCEPTED_METHOD_MAP;\n\n  /**\n   * @deprecated\n   */\n  const isStreamCall = req.headers.get('trpc-accept') === 'application/jsonl';\n\n  const experimentalSSE = config.sse?.enabled ?? true;\n  try {\n    const [infoError, info] = infoTuple;\n    if (infoError) {\n      throw infoError;\n    }\n    if (info.isBatchCall && !allowBatching) {\n      throw new TRPCError({\n        code: 'BAD_REQUEST',\n        message: `Batching is not enabled on the server`,\n      });\n    }\n    /* istanbul ignore if -- @preserve */\n    if (isStreamCall && !info.isBatchCall) {\n      throw new TRPCError({\n        message: `Streaming requests must be batched (you can do a batch of 1)`,\n        code: 'BAD_REQUEST',\n      });\n    }\n    await ctxManager.create(info);\n\n    interface RPCResultOk {\n      data: unknown;\n    }\n    type RPCResult = ResultTuple<RPCResultOk>;\n    const rpcCalls = info.calls.map(async (call): Promise<RPCResult> => {\n      const proc = call.procedure;\n      try {\n        if (opts.error) {\n          throw opts.error;\n        }\n\n        if (!proc) {\n          throw new TRPCError({\n            code: 'NOT_FOUND',\n            message: `No procedure found on path \"${call.path}\"`,\n          });\n        }\n\n        if (!methodMapper[proc._def.type].includes(req.method as HTTPMethods)) {\n          throw new TRPCError({\n            code: 'METHOD_NOT_SUPPORTED',\n            message: `Unsupported ${req.method}-request to ${proc._def.type} procedure at path \"${call.path}\"`,\n          });\n        }\n\n        if (proc._def.type === 'subscription') {\n          /* istanbul ignore if -- @preserve */\n          if (info.isBatchCall) {\n            throw new TRPCError({\n              code: 'BAD_REQUEST',\n              message: `Cannot batch subscription calls`,\n            });\n          }\n        }\n        const data: unknown = await proc({\n          path: call.path,\n          getRawInput: call.getRawInput,\n          ctx: ctxManager.value(),\n          type: proc._def.type,\n          signal: opts.req.signal,\n        });\n        return [undefined, { data }];\n      } catch (cause) {\n        const error = getTRPCErrorFromUnknown(cause);\n        const input = call.result();\n\n        opts.onError?.({\n          error,\n          path: call.path,\n          input,\n          ctx: ctxManager.valueOrUndefined(),\n          type: call.procedure?._def.type ?? 'unknown',\n          req: opts.req,\n        });\n\n        return [error, undefined];\n      }\n    });\n\n    // ----------- response handlers -----------\n    if (!info.isBatchCall) {\n      const [call] = info.calls;\n      const [error, result] = await rpcCalls[0]!;\n\n      switch (info.type) {\n        case 'unknown':\n        case 'mutation':\n        case 'query': {\n          // httpLink\n          headers.set('content-type', 'application/json');\n\n          if (isDataStream(result?.data)) {\n            throw new TRPCError({\n              code: 'UNSUPPORTED_MEDIA_TYPE',\n              message:\n                'Cannot use stream-like response in non-streaming request - use httpBatchStreamLink',\n            });\n          }\n          const res: TRPCResponse<unknown, inferRouterError<TRouter>> = error\n            ? {\n                error: getErrorShape({\n                  config,\n                  ctx: ctxManager.valueOrUndefined(),\n                  error,\n                  input: call!.result(),\n                  path: call!.path,\n                  type: info.type,\n                }),\n              }\n            : { result: { data: result.data } };\n\n          const headResponse = initResponse({\n            ctx: ctxManager.valueOrUndefined(),\n            info,\n            responseMeta: opts.responseMeta,\n            errors: error ? [error] : [],\n            headers,\n            untransformedJSON: [res],\n          });\n          return new Response(\n            JSON.stringify(transformTRPCResponse(config, res)),\n            {\n              status: headResponse.status,\n              headers,\n            },\n          );\n        }\n        case 'subscription': {\n          // httpSubscriptionLink\n\n          const iterable: AsyncIterable<unknown> = run(() => {\n            if (error) {\n              return errorToAsyncIterable(error);\n            }\n            if (!experimentalSSE) {\n              return errorToAsyncIterable(\n                new TRPCError({\n                  code: 'METHOD_NOT_SUPPORTED',\n                  message: 'Missing experimental flag \"sseSubscriptions\"',\n                }),\n              );\n            }\n\n            if (!isObservable(result.data) && !isAsyncIterable(result.data)) {\n              return errorToAsyncIterable(\n                new TRPCError({\n                  message: `Subscription ${\n                    call!.path\n                  } did not return an observable or a AsyncGenerator`,\n                  code: 'INTERNAL_SERVER_ERROR',\n                }),\n              );\n            }\n            const dataAsIterable = isObservable(result.data)\n              ? observableToAsyncIterable(result.data, opts.req.signal)\n              : result.data;\n            return dataAsIterable;\n          });\n\n          const stream = sseStreamProducer({\n            ...config.sse,\n            data: iterable,\n            serialize: (v) => config.transformer.output.serialize(v),\n            formatError(errorOpts) {\n              const error = getTRPCErrorFromUnknown(errorOpts.error);\n              const input = call?.result();\n              const path = call?.path;\n              const type = call?.procedure?._def.type ?? 'unknown';\n\n              opts.onError?.({\n                error,\n                path,\n                input,\n                ctx: ctxManager.valueOrUndefined(),\n                req: opts.req,\n                type,\n              });\n\n              const shape = getErrorShape({\n                config,\n                ctx: ctxManager.valueOrUndefined(),\n                error,\n                input,\n                path,\n                type,\n              });\n\n              return shape;\n            },\n          });\n          for (const [key, value] of Object.entries(sseHeaders)) {\n            headers.set(key, value);\n          }\n\n          const headResponse = initResponse({\n            ctx: ctxManager.valueOrUndefined(),\n            info,\n            responseMeta: opts.responseMeta,\n            errors: [],\n            headers,\n            untransformedJSON: null,\n          });\n\n          return new Response(stream, {\n            headers,\n            status: headResponse.status,\n          });\n        }\n      }\n    }\n\n    // batch response handlers\n    if (info.accept === 'application/jsonl') {\n      // httpBatchStreamLink\n      headers.set('content-type', 'application/json');\n      headers.set('transfer-encoding', 'chunked');\n      const headResponse = initResponse({\n        ctx: ctxManager.valueOrUndefined(),\n        info,\n        responseMeta: opts.responseMeta,\n        errors: [],\n        headers,\n        untransformedJSON: null,\n      });\n      const stream = jsonlStreamProducer({\n        ...config.jsonl,\n        /**\n         * Example structure for `maxDepth: 4`:\n         * {\n         *   // 1\n         *   0: {\n         *     // 2\n         *     result: {\n         *       // 3\n         *       data: // 4\n         *     }\n         *   }\n         * }\n         */\n        maxDepth: Infinity,\n        data: rpcCalls.map(async (res) => {\n          const [error, result] = await res;\n\n          const call = info.calls[0];\n\n          if (error) {\n            return {\n              error: getErrorShape({\n                config,\n                ctx: ctxManager.valueOrUndefined(),\n                error,\n                input: call!.result(),\n                path: call!.path,\n                type: call!.procedure?._def.type ?? 'unknown',\n              }),\n            };\n          }\n\n          /**\n           * Not very pretty, but we need to wrap nested data in promises\n           * Our stream producer will only resolve top-level async values or async values that are directly nested in another async value\n           */\n          const iterable = isObservable(result.data)\n            ? observableToAsyncIterable(result.data, opts.req.signal)\n            : Promise.resolve(result.data);\n          return {\n            result: Promise.resolve({\n              data: iterable,\n            }),\n          };\n        }),\n        serialize: config.transformer.output.serialize,\n        onError: (cause) => {\n          opts.onError?.({\n            error: getTRPCErrorFromUnknown(cause),\n            path: undefined,\n            input: undefined,\n            ctx: ctxManager.valueOrUndefined(),\n            req: opts.req,\n            type: info?.type ?? 'unknown',\n          });\n        },\n\n        formatError(errorOpts) {\n          const call = info?.calls[errorOpts.path[0] as any];\n\n          const error = getTRPCErrorFromUnknown(errorOpts.error);\n          const input = call?.result();\n          const path = call?.path;\n          const type = call?.procedure?._def.type ?? 'unknown';\n\n          // no need to call `onError` here as it will be propagated through the stream itself\n\n          const shape = getErrorShape({\n            config,\n            ctx: ctxManager.valueOrUndefined(),\n            error,\n            input,\n            path,\n            type,\n          });\n\n          return shape;\n        },\n      });\n\n      return new Response(stream, {\n        headers,\n        status: headResponse.status,\n      });\n    }\n\n    // httpBatchLink\n    /**\n     * Non-streaming response:\n     * - await all responses in parallel, blocking on the slowest one\n     * - create headers with known response body\n     * - return a complete HTTPResponse\n     */\n    headers.set('content-type', 'application/json');\n    const results: RPCResult[] = (await Promise.all(rpcCalls)).map(\n      (res): RPCResult => {\n        const [error, result] = res;\n        if (error) {\n          return res;\n        }\n\n        if (isDataStream(result.data)) {\n          return [\n            new TRPCError({\n              code: 'UNSUPPORTED_MEDIA_TYPE',\n              message:\n                'Cannot use stream-like response in non-streaming request - use httpBatchStreamLink',\n            }),\n            undefined,\n          ];\n        }\n        return res;\n      },\n    );\n    const resultAsRPCResponse = results.map(\n      (\n        [error, result],\n        index,\n      ): TRPCResponse<unknown, inferRouterError<TRouter>> => {\n        const call = info.calls[index]!;\n        if (error) {\n          return {\n            error: getErrorShape({\n              config,\n              ctx: ctxManager.valueOrUndefined(),\n              error,\n              input: call.result(),\n              path: call.path,\n              type: call.procedure?._def.type ?? 'unknown',\n            }),\n          };\n        }\n        return {\n          result: { data: result.data },\n        };\n      },\n    );\n\n    const errors = results\n      .map(([error]) => error)\n      .filter(Boolean) as TRPCError[];\n\n    const headResponse = initResponse({\n      ctx: ctxManager.valueOrUndefined(),\n      info,\n      responseMeta: opts.responseMeta,\n      untransformedJSON: resultAsRPCResponse,\n      errors,\n      headers,\n    });\n\n    return new Response(\n      JSON.stringify(transformTRPCResponse(config, resultAsRPCResponse)),\n      {\n        status: headResponse.status,\n        headers,\n      },\n    );\n  } catch (cause) {\n    const [_infoError, info] = infoTuple;\n    const ctx = ctxManager.valueOrUndefined();\n    // we get here if\n    // - batching is called when it's not enabled\n    // - `createContext()` throws\n    // - `router._def._config.transformer.output.serialize()` throws\n    // - post body is too large\n    // - input deserialization fails\n    // - `errorFormatter` return value is malformed\n    const { error, untransformedJSON, body } = caughtErrorToData(cause, {\n      opts,\n      ctx: ctxManager.valueOrUndefined(),\n      type: info?.type ?? 'unknown',\n    });\n\n    const headResponse = initResponse({\n      ctx,\n      info,\n      responseMeta: opts.responseMeta,\n      untransformedJSON,\n      errors: [error],\n      headers,\n    });\n\n    return new Response(body, {\n      status: headResponse.status,\n      headers,\n    });\n  }\n}\n"],"names":["parsed: unknown","str: string","fn: () => Promise<TReturn>","promise: Promise<TReturn> | null","value: TReturn | typeof sym","jsonContentTypeHandler: ContentTypeHandler","inputs: unknown","acc: InputRecord","type: ProcedureType | 'unknown'","info: TRPCRequestInfo","formDataContentTypeHandler: ContentTypeHandler","octetStreamContentTypeHandler: ContentTypeHandler","req: Request","handler","opts: GetRequestInfoOptions","error: unknown","arg: Promise<T> | PromiseLike<T> | PromiseExecutor<T>","promise: Promise<T>","unsubscribe: () => void","onfulfilled?:\n      | ((value: T) => TResult1 | PromiseLike<TResult1>)\n      | null","onrejected?:\n      | ((reason: any) => TResult2 | PromiseLike<TResult2>)\n      | null","onrejected?:\n      | ((reason: any) => TResult | PromiseLike<TResult>)\n      | null","onfinally?: (() => void) | null","promise: PromiseLike<T>","value: T | PromiseLike<T>","values: Iterable<T | PromiseLike<T>>","promises: readonly TPromise[]","promise: TPromise","resolve!: PromiseWithResolvers<T>[\"resolve\"]","reject!: PromiseWithResolvers<T>[\"reject\"]","arr: readonly T[]","member: T","index: number","member: unknown","thing: T","dispose: () => void","dispose: () => Promise<void>","ms: number","timer: ReturnType<typeof setTimeout> | null","r","e","n","o","OverloadYield","_awaitAsyncGenerator","OverloadYield","_wrapAsyncGenerator","r","t","e","iterable: AsyncIterable<TYield, TReturn, TNext>","iterable: AsyncIterable<T>","opts: { maxDurationMs: number }","result: null | IteratorResult<T> | typeof disposablePromiseTimerResult","opts: {\n    count: number;\n    gracePeriodMs: number;\n  }","resolve: (value: TValue) => void","reject: (error: unknown) => void","iterable: AsyncIterable<TYield, TReturn>","onResult: (result: ManagedIteratorResult<TYield, TReturn>) => void","state: 'idle' | 'pending' | 'done'","iterables: AsyncIterable<TYield, void, unknown>[]","buffer: Array<\n    [\n      iterator: ManagedIterator<TYield, void>,\n      result: Exclude<\n        ManagedIteratorResult<TYield, void>,\n        { status: 'return' }\n      >,\n    ]\n  >","iterable: AsyncIterable<TYield, void, unknown>","errors: unknown[]","iterable: AsyncIterable<TYield, void>","iterable: AsyncIterable<TValue>","pingIntervalMs: number","result:\n    | null\n    | IteratorResult<TValue>\n    | typeof disposablePromiseTimerResult","_asyncIterator","r","AsyncFromSyncIterator","value: unknown","path: (string | number)[]","opts: JSONLProducerOptions","callback: (idx: ChunkIndex) => AsyncIterable<ChunkData, void>","iterable","promise: Promise<unknown>","iterable: AsyncIterable<unknown>","newObj: Record<string, unknown>","asyncValues: ChunkDefinition[]","newHead: Head","iterable: AsyncIterable<ChunkData | typeof PING_SYM, void>","data: unknown","source: NodeJSReadableStreamEsque","from: NodeJSReadableStreamEsque | WebReadableStreamEsque","chunk: ChunkData","abortController: AbortController","originalController: ReadableStreamDefaultController<ChunkData>","v: ChunkData","reason: unknown","chunkId: ChunkIndex","opts: {\n  from: NodeJSReadableStreamEsque | WebReadableStreamEsque;\n  deserialize?: Deserialize;\n  onError?: ConsumerOnError;\n  formatError?: (opts: { error: unknown }) => Error;\n  /**\n   * This `AbortController` will be triggered when there are no more listeners to the stream.\n   */\n  abortController: AbortController;\n}","headDeferred: null | Deferred<THead>","value: ChunkDefinition","value","value: EncodedValue","_asyncGeneratorDelegate","e","n","t","opts: SSEStreamProducerOptions<TValue>","ping: Required<SSEPingOptions>","client: SSEClientOptions","iterable: AsyncIterable<TValue | typeof PING_SYM>","value: null | TIteratorValue","chunk: null | SSEvent","controller: TransformStreamDefaultController<string>","opts: {\n  promise: Promise<T>;\n  timeoutMs: number;\n  onTimeout: () => Promise<NoInfer<T>>;\n}","opts: SSEStreamConsumerOptions<TConfig>","clientOptions: SSEClientOptions","_es: InstanceType<TConfig['EventSource']> | null","options: SSEClientOptions","def: SSEvent","res: Awaited<typeof promise>","err: TRPCError","TYPE_ACCEPTED_METHOD_MAP: Record<ProcedureType, HTTPMethods[]>","TYPE_ACCEPTED_METHOD_MAP_WITH_METHOD_OVERRIDE: Record<\n  ProcedureType,\n  HTTPMethods[]\n>","initOpts: {\n  ctx: inferRouterContext<TRouter> | undefined;\n  info: TRPCRequestInfo | undefined;\n  responseMeta?: HTTPBaseHandlerOptions<TRouter, TRequest>['responseMeta'];\n  untransformedJSON:\n    | TRPCResponse<unknown, inferRouterError<TRouter>>\n    | TRPCResponse<unknown, inferRouterError<TRouter>>[]\n    | null;\n  errors: TRPCError[];\n  headers: Headers;\n}","cause: unknown","errorOpts: {\n    opts: Pick<\n      ResolveHTTPRequestOptions<TRouter>,\n      'onError' | 'req' | 'router'\n    >;\n    ctx: inferRouterContext<TRouter> | undefined;\n    type: ProcedureType | 'unknown';\n    path?: string;\n    input?: unknown;\n  }","v: unknown","opts: ResolveHTTPRequestOptions<TRouter>","infoTuple: ResultTuple<TRPCRequestInfo>","ctxManager: ContextManager","result: ResultTuple<$Context> | undefined","data: unknown","res: TRPCResponse<unknown, inferRouterError<TRouter>>","headResponse","iterable: AsyncIterable<unknown>","error","results: RPCResult[]"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19],"debugId":null}},
    {"offset": {"line": 5496, "column": 0}, "map": {"version":3,"file":"index.mjs","sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/client/src/internals/TRPCUntypedClient.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/client/src/createTRPCUntypedClient.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/client/src/createTRPCClient.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/client/src/links/httpBatchStreamLink.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/client/src/internals/inputWithTrackedEventId.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/asyncIterator.js","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/client/src/links/httpSubscriptionLink.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/client/src/links/retryLink.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/usingCtx.js","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/OverloadYield.js","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/awaitAsyncGenerator.js","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/wrapAsyncGenerator.js","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/client/src/links/localLink.ts"],"sourcesContent":["import type {\n  inferObservableValue,\n  Unsubscribable,\n} from '@trpc/server/observable';\nimport { observableToPromise, share } from '@trpc/server/observable';\nimport type {\n  AnyRouter,\n  inferAsyncIterableYield,\n  InferrableClientTypes,\n  Maybe,\n  TypeError,\n} from '@trpc/server/unstable-core-do-not-import';\nimport { createChain } from '../links/internals/createChain';\nimport type { TRPCConnectionState } from '../links/internals/subscriptions';\nimport type {\n  OperationContext,\n  OperationLink,\n  TRPCClientRuntime,\n  TRPCLink,\n} from '../links/types';\nimport { TRPCClientError } from '../TRPCClientError';\n\ntype TRPCType = 'mutation' | 'query' | 'subscription';\nexport interface TRPCRequestOptions {\n  /**\n   * Pass additional context to links\n   */\n  context?: OperationContext;\n  signal?: AbortSignal;\n}\n\nexport interface TRPCSubscriptionObserver<TValue, TError> {\n  onStarted: (opts: { context: OperationContext | undefined }) => void;\n  onData: (value: inferAsyncIterableYield<TValue>) => void;\n  onError: (err: TError) => void;\n  onStopped: () => void;\n  onComplete: () => void;\n  onConnectionStateChange: (state: TRPCConnectionState<TError>) => void;\n}\n\n/** @internal */\nexport type CreateTRPCClientOptions<TRouter extends InferrableClientTypes> = {\n  links: TRPCLink<TRouter>[];\n  transformer?: TypeError<'The transformer property has moved to httpLink/httpBatchLink/wsLink'>;\n};\n\nexport class TRPCUntypedClient<TInferrable extends InferrableClientTypes> {\n  private readonly links: OperationLink<TInferrable>[];\n  public readonly runtime: TRPCClientRuntime;\n  private requestId: number;\n\n  constructor(opts: CreateTRPCClientOptions<TInferrable>) {\n    this.requestId = 0;\n\n    this.runtime = {};\n\n    // Initialize the links\n    this.links = opts.links.map((link) => link(this.runtime));\n  }\n\n  private $request<TInput = unknown, TOutput = unknown>(opts: {\n    type: TRPCType;\n    input: TInput;\n    path: string;\n    context?: OperationContext;\n    signal: Maybe<AbortSignal>;\n  }) {\n    const chain$ = createChain<AnyRouter, TInput, TOutput>({\n      links: this.links as OperationLink<any, any, any>[],\n      op: {\n        ...opts,\n        context: opts.context ?? {},\n        id: ++this.requestId,\n      },\n    });\n    return chain$.pipe(share());\n  }\n\n  private async requestAsPromise<TInput = unknown, TOutput = unknown>(opts: {\n    type: TRPCType;\n    input: TInput;\n    path: string;\n    context?: OperationContext;\n    signal: Maybe<AbortSignal>;\n  }): Promise<TOutput> {\n    try {\n      const req$ = this.$request<TInput, TOutput>(opts);\n      type TValue = inferObservableValue<typeof req$>;\n\n      const envelope = await observableToPromise<TValue>(req$);\n      const data = (envelope.result as any).data;\n      return data;\n    } catch (err) {\n      throw TRPCClientError.from(err as Error);\n    }\n  }\n  public query(path: string, input?: unknown, opts?: TRPCRequestOptions) {\n    return this.requestAsPromise<unknown, unknown>({\n      type: 'query',\n      path,\n      input,\n      context: opts?.context,\n      signal: opts?.signal,\n    });\n  }\n  public mutation(path: string, input?: unknown, opts?: TRPCRequestOptions) {\n    return this.requestAsPromise<unknown, unknown>({\n      type: 'mutation',\n      path,\n      input,\n      context: opts?.context,\n      signal: opts?.signal,\n    });\n  }\n  public subscription(\n    path: string,\n    input: unknown,\n    opts: Partial<\n      TRPCSubscriptionObserver<unknown, TRPCClientError<AnyRouter>>\n    > &\n      TRPCRequestOptions,\n  ): Unsubscribable {\n    const observable$ = this.$request({\n      type: 'subscription',\n      path,\n      input,\n      context: opts.context,\n      signal: opts.signal,\n    });\n    return observable$.subscribe({\n      next(envelope) {\n        switch (envelope.result.type) {\n          case 'state': {\n            opts.onConnectionStateChange?.(envelope.result);\n            break;\n          }\n          case 'started': {\n            opts.onStarted?.({\n              context: envelope.context,\n            });\n            break;\n          }\n          case 'stopped': {\n            opts.onStopped?.();\n            break;\n          }\n          case 'data':\n          case undefined: {\n            opts.onData?.(envelope.result.data);\n            break;\n          }\n        }\n      },\n      error(err) {\n        opts.onError?.(err);\n      },\n      complete() {\n        opts.onComplete?.();\n      },\n    });\n  }\n}\n","import type { AnyRouter } from '@trpc/server/unstable-core-do-not-import';\nimport type { CreateTRPCClientOptions } from './internals/TRPCUntypedClient';\nimport { TRPCUntypedClient } from './internals/TRPCUntypedClient';\n\nexport function createTRPCUntypedClient<TRouter extends AnyRouter>(\n  opts: CreateTRPCClientOptions<TRouter>,\n): TRPCUntypedClient<TRouter> {\n  return new TRPCUntypedClient(opts);\n}\n\nexport type {\n  CreateTRPCClientOptions,\n  TRPCRequestOptions,\n} from './internals/TRPCUntypedClient';\nexport { TRPCUntypedClient } from './internals/TRPCUntypedClient';\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport type { Unsubscribable } from '@trpc/server/observable';\nimport type {\n  AnyProcedure,\n  AnyRouter,\n  inferClientTypes,\n  inferProcedureInput,\n  InferrableClientTypes,\n  inferTransformedProcedureOutput,\n  ProcedureType,\n  RouterRecord,\n} from '@trpc/server/unstable-core-do-not-import';\nimport {\n  createFlatProxy,\n  createRecursiveProxy,\n} from '@trpc/server/unstable-core-do-not-import';\nimport type { CreateTRPCClientOptions } from './createTRPCUntypedClient';\nimport type { TRPCSubscriptionObserver } from './internals/TRPCUntypedClient';\nimport { TRPCUntypedClient } from './internals/TRPCUntypedClient';\nimport type { TRPCProcedureOptions } from './internals/types';\nimport type { TRPCClientError } from './TRPCClientError';\n\n/**\n * @public\n * @deprecated use {@link TRPCClient} instead, will be removed in v12\n **/\nexport type inferRouterClient<TRouter extends AnyRouter> = TRPCClient<TRouter>;\n\n/**\n * @public\n * @deprecated use {@link TRPCClient} instead, will be removed in v12\n **/\nexport type CreateTRPCClient<TRouter extends AnyRouter> = TRPCClient<TRouter>;\n\nconst untypedClientSymbol = Symbol.for('trpc_untypedClient');\n\n/**\n * @public\n **/\nexport type TRPCClient<TRouter extends AnyRouter> = DecoratedProcedureRecord<\n  {\n    transformer: TRouter['_def']['_config']['$types']['transformer'];\n    errorShape: TRouter['_def']['_config']['$types']['errorShape'];\n  },\n  TRouter['_def']['record']\n> & {\n  [untypedClientSymbol]: TRPCUntypedClient<TRouter>;\n};\n\ntype ResolverDef = {\n  input: any;\n  output: any;\n  transformer: boolean;\n  errorShape: any;\n};\n\ntype coerceAsyncGeneratorToIterable<T> =\n  T extends AsyncGenerator<infer $T, infer $Return, infer $Next>\n    ? AsyncIterable<$T, $Return, $Next>\n    : T;\n\n/** @internal */\nexport type Resolver<TDef extends ResolverDef> = (\n  input: TDef['input'],\n  opts?: TRPCProcedureOptions,\n) => Promise<coerceAsyncGeneratorToIterable<TDef['output']>>;\n\ntype SubscriptionResolver<TDef extends ResolverDef> = (\n  input: TDef['input'],\n  opts: Partial<\n    TRPCSubscriptionObserver<TDef['output'], TRPCClientError<TDef>>\n  > &\n    TRPCProcedureOptions,\n) => Unsubscribable;\n\ntype DecorateProcedure<\n  TType extends ProcedureType,\n  TDef extends ResolverDef,\n> = TType extends 'query'\n  ? {\n      query: Resolver<TDef>;\n    }\n  : TType extends 'mutation'\n    ? {\n        mutate: Resolver<TDef>;\n      }\n    : TType extends 'subscription'\n      ? {\n          subscribe: SubscriptionResolver<TDef>;\n        }\n      : never;\n\n/**\n * @internal\n */\ntype DecoratedProcedureRecord<\n  TRoot extends InferrableClientTypes,\n  TRecord extends RouterRecord,\n> = {\n  [TKey in keyof TRecord]: TRecord[TKey] extends infer $Value\n    ? $Value extends AnyProcedure\n      ? DecorateProcedure<\n          $Value['_def']['type'],\n          {\n            input: inferProcedureInput<$Value>;\n            output: inferTransformedProcedureOutput<\n              inferClientTypes<TRoot>,\n              $Value\n            >;\n            errorShape: inferClientTypes<TRoot>['errorShape'];\n            transformer: inferClientTypes<TRoot>['transformer'];\n          }\n        >\n      : $Value extends RouterRecord\n        ? DecoratedProcedureRecord<TRoot, $Value>\n        : never\n    : never;\n};\n\nconst clientCallTypeMap: Record<\n  keyof DecorateProcedure<any, any>,\n  ProcedureType\n> = {\n  query: 'query',\n  mutate: 'mutation',\n  subscribe: 'subscription',\n};\n\n/** @internal */\nexport const clientCallTypeToProcedureType = (\n  clientCallType: string,\n): ProcedureType => {\n  return clientCallTypeMap[clientCallType as keyof typeof clientCallTypeMap];\n};\n\n/**\n * @internal\n */\nexport function createTRPCClientProxy<TRouter extends AnyRouter>(\n  client: TRPCUntypedClient<TRouter>,\n): TRPCClient<TRouter> {\n  const proxy = createRecursiveProxy<TRPCClient<TRouter>>(({ path, args }) => {\n    const pathCopy = [...path];\n    const procedureType = clientCallTypeToProcedureType(pathCopy.pop()!);\n\n    const fullPath = pathCopy.join('.');\n\n    return (client[procedureType] as any)(fullPath, ...(args as any));\n  });\n  return createFlatProxy<TRPCClient<TRouter>>((key) => {\n    if (key === untypedClientSymbol) {\n      return client;\n    }\n    return proxy[key];\n  });\n}\n\nexport function createTRPCClient<TRouter extends AnyRouter>(\n  opts: CreateTRPCClientOptions<TRouter>,\n): TRPCClient<TRouter> {\n  const client = new TRPCUntypedClient(opts);\n  const proxy = createTRPCClientProxy<TRouter>(client);\n  return proxy;\n}\n\n/**\n * Get an untyped client from a proxy client\n * @internal\n */\nexport function getUntypedClient<TRouter extends AnyRouter>(\n  client: TRPCClient<TRouter>,\n): TRPCUntypedClient<TRouter> {\n  return client[untypedClientSymbol];\n}\n","import type { AnyRouter, ProcedureType } from '@trpc/server';\nimport { observable } from '@trpc/server/observable';\nimport type { TRPCErrorShape, TRPCResponse } from '@trpc/server/rpc';\nimport { jsonlStreamConsumer } from '@trpc/server/unstable-core-do-not-import';\nimport type { BatchLoader } from '../internals/dataLoader';\nimport { dataLoader } from '../internals/dataLoader';\nimport { allAbortSignals, raceAbortSignals } from '../internals/signals';\nimport type { NonEmptyArray } from '../internals/types';\nimport { TRPCClientError } from '../TRPCClientError';\nimport type { HTTPBatchLinkOptions } from './HTTPBatchLinkOptions';\nimport type { HTTPResult } from './internals/httpUtils';\nimport {\n  fetchHTTPResponse,\n  getBody,\n  getUrl,\n  resolveHTTPLinkOptions,\n} from './internals/httpUtils';\nimport type { Operation, TRPCLink } from './types';\n\n/**\n * @see https://trpc.io/docs/client/links/httpBatchStreamLink\n */\nexport function httpBatchStreamLink<TRouter extends AnyRouter>(\n  opts: HTTPBatchLinkOptions<TRouter['_def']['_config']['$types']>,\n): TRPCLink<TRouter> {\n  const resolvedOpts = resolveHTTPLinkOptions(opts);\n  const maxURLLength = opts.maxURLLength ?? Infinity;\n  const maxItems = opts.maxItems ?? Infinity;\n\n  return () => {\n    const batchLoader = (\n      type: ProcedureType,\n    ): BatchLoader<Operation, HTTPResult> => {\n      return {\n        validate(batchOps) {\n          if (maxURLLength === Infinity && maxItems === Infinity) {\n            // escape hatch for quick calcs\n            return true;\n          }\n          if (batchOps.length > maxItems) {\n            return false;\n          }\n          const path = batchOps.map((op) => op.path).join(',');\n          const inputs = batchOps.map((op) => op.input);\n\n          const url = getUrl({\n            ...resolvedOpts,\n            type,\n            path,\n            inputs,\n            signal: null,\n          });\n\n          return url.length <= maxURLLength;\n        },\n        async fetch(batchOps) {\n          const path = batchOps.map((op) => op.path).join(',');\n          const inputs = batchOps.map((op) => op.input);\n\n          const batchSignals = allAbortSignals(\n            ...batchOps.map((op) => op.signal),\n          );\n          const abortController = new AbortController();\n\n          const responsePromise = fetchHTTPResponse({\n            ...resolvedOpts,\n            signal: raceAbortSignals(batchSignals, abortController.signal),\n            type,\n            contentTypeHeader: 'application/json',\n            trpcAcceptHeader: 'application/jsonl',\n            getUrl,\n            getBody,\n            inputs,\n            path,\n            headers() {\n              if (!opts.headers) {\n                return {};\n              }\n              if (typeof opts.headers === 'function') {\n                return opts.headers({\n                  opList: batchOps as NonEmptyArray<Operation>,\n                });\n              }\n              return opts.headers;\n            },\n          });\n\n          const res = await responsePromise;\n          const [head] = await jsonlStreamConsumer<\n            Record<string, Promise<any>>\n          >({\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            from: res.body!,\n            deserialize: resolvedOpts.transformer.output.deserialize,\n            // onError: console.error,\n            formatError(opts) {\n              const error = opts.error as TRPCErrorShape;\n              return TRPCClientError.from({\n                error,\n              });\n            },\n            abortController,\n          });\n          const promises = Object.keys(batchOps).map(\n            async (key): Promise<HTTPResult> => {\n              let json: TRPCResponse = await Promise.resolve(head[key]);\n\n              if ('result' in json) {\n                /**\n                 * Not very pretty, but we need to unwrap nested data as promises\n                 * Our stream producer will only resolve top-level async values or async values that are directly nested in another async value\n                 */\n                const result = await Promise.resolve(json.result);\n                json = {\n                  result: {\n                    data: await Promise.resolve(result.data),\n                  },\n                };\n              }\n\n              return {\n                json,\n                meta: {\n                  response: res,\n                },\n              };\n            },\n          );\n          return promises;\n        },\n      };\n    };\n\n    const query = dataLoader(batchLoader('query'));\n    const mutation = dataLoader(batchLoader('mutation'));\n\n    const loaders = { query, mutation };\n    return ({ op }) => {\n      return observable((observer) => {\n        /* istanbul ignore if -- @preserve */\n        if (op.type === 'subscription') {\n          throw new Error(\n            'Subscriptions are unsupported by `httpBatchStreamLink` - use `httpSubscriptionLink` or `wsLink`',\n          );\n        }\n        const loader = loaders[op.type];\n        const promise = loader.load(op);\n\n        let _res = undefined as HTTPResult | undefined;\n        promise\n          .then((res) => {\n            _res = res;\n            if ('error' in res.json) {\n              observer.error(\n                TRPCClientError.from(res.json, {\n                  meta: res.meta,\n                }),\n              );\n              return;\n            } else if ('result' in res.json) {\n              observer.next({\n                context: res.meta,\n                result: res.json.result,\n              });\n              observer.complete();\n              return;\n            }\n\n            observer.complete();\n          })\n          .catch((err) => {\n            observer.error(\n              TRPCClientError.from(err, {\n                meta: _res?.meta,\n              }),\n            );\n          });\n\n        return () => {\n          // noop\n        };\n      });\n    };\n  };\n}\n\n/**\n * @deprecated use {@link httpBatchStreamLink} instead\n */\nexport const unstable_httpBatchStreamLink = httpBatchStreamLink;\n","export function inputWithTrackedEventId(\n  input: unknown,\n  lastEventId: string | undefined,\n) {\n  if (!lastEventId) {\n    return input;\n  }\n  if (input != null && typeof input !== 'object') {\n    return input;\n  }\n  return {\n    ...(input ?? {}),\n    lastEventId,\n  };\n}\n","function _asyncIterator(r) {\n  var n,\n    t,\n    o,\n    e = 2;\n  for (\"undefined\" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;) {\n    if (t && null != (n = r[t])) return n.call(r);\n    if (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r));\n    t = \"@@asyncIterator\", o = \"@@iterator\";\n  }\n  throw new TypeError(\"Object is not async iterable\");\n}\nfunction AsyncFromSyncIterator(r) {\n  function AsyncFromSyncIteratorContinuation(r) {\n    if (Object(r) !== r) return Promise.reject(new TypeError(r + \" is not an object.\"));\n    var n = r.done;\n    return Promise.resolve(r.value).then(function (r) {\n      return {\n        value: r,\n        done: n\n      };\n    });\n  }\n  return AsyncFromSyncIterator = function AsyncFromSyncIterator(r) {\n    this.s = r, this.n = r.next;\n  }, AsyncFromSyncIterator.prototype = {\n    s: null,\n    n: null,\n    next: function next() {\n      return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));\n    },\n    \"return\": function _return(r) {\n      var n = this.s[\"return\"];\n      return void 0 === n ? Promise.resolve({\n        value: r,\n        done: !0\n      }) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));\n    },\n    \"throw\": function _throw(r) {\n      var n = this.s[\"return\"];\n      return void 0 === n ? Promise.reject(r) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));\n    }\n  }, new AsyncFromSyncIterator(r);\n}\nmodule.exports = _asyncIterator, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","import { behaviorSubject, observable } from '@trpc/server/observable';\nimport type { TRPCErrorShape, TRPCResult } from '@trpc/server/rpc';\nimport type {\n  AnyClientTypes,\n  EventSourceLike,\n  inferClientTypes,\n  InferrableClientTypes,\n} from '@trpc/server/unstable-core-do-not-import';\nimport {\n  retryableRpcCodes,\n  run,\n  sseStreamConsumer,\n} from '@trpc/server/unstable-core-do-not-import';\nimport { inputWithTrackedEventId } from '../internals/inputWithTrackedEventId';\nimport { raceAbortSignals } from '../internals/signals';\nimport { TRPCClientError } from '../TRPCClientError';\nimport type { TRPCConnectionState } from '../unstable-internals';\nimport { getTransformer, type TransformerOptions } from '../unstable-internals';\nimport { getUrl } from './internals/httpUtils';\nimport {\n  resultOf,\n  type UrlOptionsWithConnectionParams,\n} from './internals/urlWithConnectionParams';\nimport type { Operation, TRPCLink } from './types';\n\nasync function urlWithConnectionParams(\n  opts: UrlOptionsWithConnectionParams,\n): Promise<string> {\n  let url = await resultOf(opts.url);\n  if (opts.connectionParams) {\n    const params = await resultOf(opts.connectionParams);\n\n    const prefix = url.includes('?') ? '&' : '?';\n    url +=\n      prefix + 'connectionParams=' + encodeURIComponent(JSON.stringify(params));\n  }\n\n  return url;\n}\n\ntype HTTPSubscriptionLinkOptions<\n  TRoot extends AnyClientTypes,\n  TEventSource extends EventSourceLike.AnyConstructor = typeof EventSource,\n> = {\n  /**\n   * EventSource ponyfill\n   */\n  EventSource?: TEventSource;\n  /**\n   * EventSource options or a callback that returns them\n   */\n  eventSourceOptions?:\n    | EventSourceLike.InitDictOf<TEventSource>\n    | ((opts: {\n        op: Operation;\n      }) =>\n        | EventSourceLike.InitDictOf<TEventSource>\n        | Promise<EventSourceLike.InitDictOf<TEventSource>>);\n} & TransformerOptions<TRoot> &\n  UrlOptionsWithConnectionParams;\n\n/**\n * @see https://trpc.io/docs/client/links/httpSubscriptionLink\n */\nexport function httpSubscriptionLink<\n  TInferrable extends InferrableClientTypes,\n  TEventSource extends EventSourceLike.AnyConstructor,\n>(\n  opts: HTTPSubscriptionLinkOptions<\n    inferClientTypes<TInferrable>,\n    TEventSource\n  >,\n): TRPCLink<TInferrable> {\n  const transformer = getTransformer(opts.transformer);\n\n  return () => {\n    return ({ op }) => {\n      return observable((observer) => {\n        const { type, path, input } = op;\n\n        /* istanbul ignore if -- @preserve */\n        if (type !== 'subscription') {\n          throw new Error('httpSubscriptionLink only supports subscriptions');\n        }\n\n        let lastEventId: string | undefined = undefined;\n        const ac = new AbortController();\n        const signal = raceAbortSignals(op.signal, ac.signal);\n        const eventSourceStream = sseStreamConsumer<{\n          EventSource: TEventSource;\n          data: Partial<{\n            id?: string;\n            data: unknown;\n          }>;\n          error: TRPCErrorShape;\n        }>({\n          url: async () =>\n            getUrl({\n              transformer,\n              url: await urlWithConnectionParams(opts),\n              input: inputWithTrackedEventId(input, lastEventId),\n              path,\n              type,\n              signal: null,\n            }),\n          init: () => resultOf(opts.eventSourceOptions, { op }),\n          signal,\n          deserialize: transformer.output.deserialize,\n          EventSource:\n            opts.EventSource ??\n            (globalThis.EventSource as never as TEventSource),\n        });\n\n        const connectionState = behaviorSubject<\n          TRPCConnectionState<TRPCClientError<any>>\n        >({\n          type: 'state',\n          state: 'connecting',\n          error: null,\n        });\n\n        const connectionSub = connectionState.subscribe({\n          next(state) {\n            observer.next({\n              result: state,\n            });\n          },\n        });\n        run(async () => {\n          for await (const chunk of eventSourceStream) {\n            switch (chunk.type) {\n              case 'ping':\n                // do nothing\n                break;\n              case 'data':\n                const chunkData = chunk.data;\n\n                let result: TRPCResult<unknown>;\n                if (chunkData.id) {\n                  // if the `tracked()`-helper is used, we always have an `id` field\n                  lastEventId = chunkData.id;\n                  result = {\n                    id: chunkData.id,\n                    data: chunkData,\n                  };\n                } else {\n                  result = {\n                    data: chunkData.data,\n                  };\n                }\n\n                observer.next({\n                  result,\n                  context: {\n                    eventSource: chunk.eventSource,\n                  },\n                });\n                break;\n              case 'connected': {\n                observer.next({\n                  result: {\n                    type: 'started',\n                  },\n                  context: {\n                    eventSource: chunk.eventSource,\n                  },\n                });\n                connectionState.next({\n                  type: 'state',\n                  state: 'pending',\n                  error: null,\n                });\n                break;\n              }\n              case 'serialized-error': {\n                const error = TRPCClientError.from({ error: chunk.error });\n\n                if (retryableRpcCodes.includes(chunk.error.code)) {\n                  //\n                  connectionState.next({\n                    type: 'state',\n                    state: 'connecting',\n                    error,\n                  });\n                  break;\n                }\n                //\n                // non-retryable error, cancel the subscription\n                throw error;\n              }\n              case 'connecting': {\n                const lastState = connectionState.get();\n\n                const error = chunk.event && TRPCClientError.from(chunk.event);\n                if (!error && lastState.state === 'connecting') {\n                  break;\n                }\n\n                connectionState.next({\n                  type: 'state',\n                  state: 'connecting',\n                  error,\n                });\n                break;\n              }\n              case 'timeout': {\n                connectionState.next({\n                  type: 'state',\n                  state: 'connecting',\n                  error: new TRPCClientError(\n                    `Timeout of ${chunk.ms}ms reached while waiting for a response`,\n                  ),\n                });\n              }\n            }\n          }\n          observer.next({\n            result: {\n              type: 'stopped',\n            },\n          });\n          connectionState.next({\n            type: 'state',\n            state: 'idle',\n            error: null,\n          });\n          observer.complete();\n        }).catch((error) => {\n          observer.error(TRPCClientError.from(error));\n        });\n\n        return () => {\n          observer.complete();\n          ac.abort();\n          connectionSub.unsubscribe();\n        };\n      });\n    };\n  };\n}\n\n/**\n * @deprecated use {@link httpSubscriptionLink} instead\n */\nexport const unstable_httpSubscriptionLink = httpSubscriptionLink;\n","/* istanbul ignore file -- @preserve */\n// We're not actually exporting this link\nimport type { Unsubscribable } from '@trpc/server/observable';\nimport { observable } from '@trpc/server/observable';\nimport type { InferrableClientTypes } from '@trpc/server/unstable-core-do-not-import';\nimport { inputWithTrackedEventId } from '../internals/inputWithTrackedEventId';\nimport type { TRPCClientError } from '../TRPCClientError';\nimport type { Operation, TRPCLink } from './types';\n\ninterface RetryLinkOptions<TInferrable extends InferrableClientTypes> {\n  /**\n   * The retry function\n   */\n  retry: (opts: RetryFnOptions<TInferrable>) => boolean;\n  /**\n   * The delay between retries in ms (defaults to 0)\n   */\n  retryDelayMs?: (attempt: number) => number;\n}\n\ninterface RetryFnOptions<TInferrable extends InferrableClientTypes> {\n  /**\n   * The operation that failed\n   */\n  op: Operation;\n  /**\n   * The error that occurred\n   */\n  error: TRPCClientError<TInferrable>;\n  /**\n   * The number of attempts that have been made (including the first call)\n   */\n  attempts: number;\n}\n\n/**\n * @see https://trpc.io/docs/v11/client/links/retryLink\n */\nexport function retryLink<TInferrable extends InferrableClientTypes>(\n  opts: RetryLinkOptions<TInferrable>,\n): TRPCLink<TInferrable> {\n  // initialized config\n  return () => {\n    // initialized in app\n    return (callOpts) => {\n      // initialized for request\n      return observable((observer) => {\n        let next$: Unsubscribable;\n        let callNextTimeout: ReturnType<typeof setTimeout> | undefined =\n          undefined;\n\n        let lastEventId: string | undefined = undefined;\n\n        attempt(1);\n\n        function opWithLastEventId() {\n          const op = callOpts.op;\n          if (!lastEventId) {\n            return op;\n          }\n\n          return {\n            ...op,\n            input: inputWithTrackedEventId(op.input, lastEventId),\n          };\n        }\n\n        function attempt(attempts: number) {\n          const op = opWithLastEventId();\n\n          next$ = callOpts.next(op).subscribe({\n            error(error) {\n              const shouldRetry = opts.retry({\n                op,\n                attempts,\n                error,\n              });\n              if (!shouldRetry) {\n                observer.error(error);\n                return;\n              }\n              const delayMs = opts.retryDelayMs?.(attempts) ?? 0;\n\n              if (delayMs <= 0) {\n                attempt(attempts + 1);\n                return;\n              }\n              callNextTimeout = setTimeout(\n                () => attempt(attempts + 1),\n                delayMs,\n              );\n            },\n            next(envelope) {\n              //\n              if (\n                (!envelope.result.type || envelope.result.type === 'data') &&\n                envelope.result.id\n              ) {\n                //\n                lastEventId = envelope.result.id;\n              }\n\n              observer.next(envelope);\n            },\n            complete() {\n              observer.complete();\n            },\n          });\n        }\n        return () => {\n          next$.unsubscribe();\n          clearTimeout(callNextTimeout);\n        };\n      });\n    };\n  };\n}\n","function _usingCtx() {\n  var r = \"function\" == typeof SuppressedError ? SuppressedError : function (r, e) {\n      var n = Error();\n      return n.name = \"SuppressedError\", n.error = r, n.suppressed = e, n;\n    },\n    e = {},\n    n = [];\n  function using(r, e) {\n    if (null != e) {\n      if (Object(e) !== e) throw new TypeError(\"using declarations can only be used with objects, functions, null, or undefined.\");\n      if (r) var o = e[Symbol.asyncDispose || Symbol[\"for\"](\"Symbol.asyncDispose\")];\n      if (void 0 === o && (o = e[Symbol.dispose || Symbol[\"for\"](\"Symbol.dispose\")], r)) var t = o;\n      if (\"function\" != typeof o) throw new TypeError(\"Object is not disposable.\");\n      t && (o = function o() {\n        try {\n          t.call(e);\n        } catch (r) {\n          return Promise.reject(r);\n        }\n      }), n.push({\n        v: e,\n        d: o,\n        a: r\n      });\n    } else r && n.push({\n      d: e,\n      a: r\n    });\n    return e;\n  }\n  return {\n    e: e,\n    u: using.bind(null, !1),\n    a: using.bind(null, !0),\n    d: function d() {\n      var o,\n        t = this.e,\n        s = 0;\n      function next() {\n        for (; o = n.pop();) try {\n          if (!o.a && 1 === s) return s = 0, n.push(o), Promise.resolve().then(next);\n          if (o.d) {\n            var r = o.d.call(o.v);\n            if (o.a) return s |= 2, Promise.resolve(r).then(next, err);\n          } else s |= 1;\n        } catch (r) {\n          return err(r);\n        }\n        if (1 === s) return t !== e ? Promise.reject(t) : Promise.resolve();\n        if (t !== e) throw t;\n      }\n      function err(n) {\n        return t = t !== e ? new r(n, t) : n, next();\n      }\n      return next();\n    }\n  };\n}\nmodule.exports = _usingCtx, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _OverloadYield(e, d) {\n  this.v = e, this.k = d;\n}\nmodule.exports = _OverloadYield, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var OverloadYield = require(\"./OverloadYield.js\");\nfunction _awaitAsyncGenerator(e) {\n  return new OverloadYield(e, 0);\n}\nmodule.exports = _awaitAsyncGenerator, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var OverloadYield = require(\"./OverloadYield.js\");\nfunction _wrapAsyncGenerator(e) {\n  return function () {\n    return new AsyncGenerator(e.apply(this, arguments));\n  };\n}\nfunction AsyncGenerator(e) {\n  var r, t;\n  function resume(r, t) {\n    try {\n      var n = e[r](t),\n        o = n.value,\n        u = o instanceof OverloadYield;\n      Promise.resolve(u ? o.v : o).then(function (t) {\n        if (u) {\n          var i = \"return\" === r ? \"return\" : \"next\";\n          if (!o.k || t.done) return resume(i, t);\n          t = e[i](t).value;\n        }\n        settle(n.done ? \"return\" : \"normal\", t);\n      }, function (e) {\n        resume(\"throw\", e);\n      });\n    } catch (e) {\n      settle(\"throw\", e);\n    }\n  }\n  function settle(e, n) {\n    switch (e) {\n      case \"return\":\n        r.resolve({\n          value: n,\n          done: !0\n        });\n        break;\n      case \"throw\":\n        r.reject(n);\n        break;\n      default:\n        r.resolve({\n          value: n,\n          done: !1\n        });\n    }\n    (r = r.next) ? resume(r.key, r.arg) : t = null;\n  }\n  this._invoke = function (e, n) {\n    return new Promise(function (o, u) {\n      var i = {\n        key: e,\n        arg: n,\n        resolve: o,\n        reject: u,\n        next: null\n      };\n      t ? t = t.next = i : (r = t = i, resume(e, n));\n    });\n  }, \"function\" != typeof e[\"return\"] && (this[\"return\"] = void 0);\n}\nAsyncGenerator.prototype[\"function\" == typeof Symbol && Symbol.asyncIterator || \"@@asyncIterator\"] = function () {\n  return this;\n}, AsyncGenerator.prototype.next = function (e) {\n  return this._invoke(\"next\", e);\n}, AsyncGenerator.prototype[\"throw\"] = function (e) {\n  return this._invoke(\"throw\", e);\n}, AsyncGenerator.prototype[\"return\"] = function (e) {\n  return this._invoke(\"return\", e);\n};\nmodule.exports = _wrapAsyncGenerator, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","import {\n  getTRPCErrorFromUnknown,\n  getTRPCErrorShape,\n  isTrackedEnvelope,\n} from '@trpc/server';\nimport { behaviorSubject, observable } from '@trpc/server/observable';\nimport { TRPC_ERROR_CODES_BY_KEY, type TRPCResult } from '@trpc/server/rpc';\nimport {\n  callProcedure,\n  isAbortError,\n  isAsyncIterable,\n  iteratorResource,\n  makeResource,\n  retryableRpcCodes,\n  run,\n  type AnyRouter,\n  type ErrorHandlerOptions,\n  type inferClientTypes,\n  type inferRouterContext,\n} from '@trpc/server/unstable-core-do-not-import';\nimport { inputWithTrackedEventId } from '../internals/inputWithTrackedEventId';\nimport { abortSignalToPromise, raceAbortSignals } from '../internals/signals';\nimport { getTransformer } from '../internals/transformer';\nimport type { TransformerOptions } from '../internals/transformer';\nimport { isTRPCClientError, TRPCClientError } from '../TRPCClientError';\nimport type { TRPCConnectionState } from './internals/subscriptions';\nimport type { TRPCLink } from './types';\n\nexport type LocalLinkOptions<TRouter extends AnyRouter> = {\n  router: TRouter;\n  createContext: () => Promise<inferRouterContext<TRouter>>;\n  onError?: (opts: ErrorHandlerOptions<inferRouterContext<TRouter>>) => void;\n} & TransformerOptions<inferClientTypes<TRouter>>;\n\n/**\n * localLink is a terminating link that allows you to make tRPC procedure calls directly in your application without going through HTTP.\n *\n * @see https://trpc.io/docs/links/localLink\n */\nexport function unstable_localLink<TRouter extends AnyRouter>(\n  opts: LocalLinkOptions<TRouter>,\n): TRPCLink<TRouter> {\n  const transformer = getTransformer(opts.transformer);\n\n  const transformChunk = (chunk: unknown) => {\n    if (opts.transformer) {\n      // assume transformer will do the right thing\n      return chunk;\n    }\n    // Special case for undefined, because `JSON.stringify(undefined)` throws\n    if (chunk === undefined) {\n      return chunk;\n    }\n    const serialized = JSON.stringify(transformer.input.serialize(chunk));\n    const deserialized = JSON.parse(transformer.output.deserialize(serialized));\n    return deserialized;\n  };\n\n  return () =>\n    ({ op }) =>\n      observable((observer) => {\n        let ctx: inferRouterContext<TRouter> | undefined = undefined;\n        const ac = new AbortController();\n\n        const signal = raceAbortSignals(op.signal, ac.signal);\n        const signalPromise = abortSignalToPromise(signal);\n\n        signalPromise.catch(() => {\n          // prevent unhandled rejection\n        });\n\n        let input = op.input;\n        async function runProcedure(newInput: unknown): Promise<unknown> {\n          input = newInput;\n\n          ctx = await opts.createContext();\n\n          return callProcedure({\n            router: opts.router,\n            path: op.path,\n            getRawInput: async () => newInput,\n            ctx,\n            type: op.type,\n            signal,\n          });\n        }\n\n        function onErrorCallback(cause: unknown) {\n          if (isAbortError(cause)) {\n            return;\n          }\n          opts.onError?.({\n            error: getTRPCErrorFromUnknown(cause),\n            type: op.type,\n            path: op.path,\n            input,\n            ctx,\n          });\n        }\n\n        function coerceToTRPCClientError(cause: unknown) {\n          if (isTRPCClientError<TRouter>(cause)) {\n            return cause;\n          }\n          const error = getTRPCErrorFromUnknown(cause);\n\n          const shape = getTRPCErrorShape({\n            config: opts.router._def._config,\n            ctx,\n            error,\n            input,\n            path: op.path,\n            type: op.type,\n          });\n          return TRPCClientError.from({\n            error: transformChunk(shape),\n          });\n        }\n\n        run(async () => {\n          switch (op.type) {\n            case 'query':\n            case 'mutation': {\n              const result = await runProcedure(op.input);\n              if (!isAsyncIterable(result)) {\n                observer.next({\n                  result: { data: transformChunk(result) },\n                });\n                observer.complete();\n                break;\n              }\n\n              observer.next({\n                result: {\n                  data: (async function* () {\n                    await using iterator = iteratorResource(result);\n                    using _finally = makeResource({}, () => {\n                      observer.complete();\n                    });\n                    try {\n                      while (true) {\n                        const res = await Promise.race([\n                          iterator.next(),\n                          signalPromise,\n                        ]);\n                        if (res.done) {\n                          return transformChunk(res.value);\n                        }\n                        yield transformChunk(res.value);\n                      }\n                    } catch (cause) {\n                      onErrorCallback(cause);\n                      throw coerceToTRPCClientError(cause);\n                    }\n                  })(),\n                },\n              });\n              break;\n            }\n            case 'subscription': {\n              const connectionState = behaviorSubject<\n                TRPCConnectionState<TRPCClientError<any>>\n              >({\n                type: 'state',\n                state: 'connecting',\n                error: null,\n              });\n\n              const connectionSub = connectionState.subscribe({\n                next(state) {\n                  observer.next({\n                    result: state,\n                  });\n                },\n              });\n              let lastEventId: string | undefined = undefined;\n\n              using _finally = makeResource({}, async () => {\n                observer.complete();\n\n                connectionState.next({\n                  type: 'state',\n                  state: 'idle',\n                  error: null,\n                });\n                connectionSub.unsubscribe();\n              });\n              while (true) {\n                const result = await runProcedure(\n                  inputWithTrackedEventId(op.input, lastEventId),\n                );\n                if (!isAsyncIterable(result)) {\n                  throw new Error('Expected an async iterable');\n                }\n                await using iterator = iteratorResource(result);\n\n                observer.next({\n                  result: {\n                    type: 'started',\n                  },\n                });\n                connectionState.next({\n                  type: 'state',\n                  state: 'pending',\n                  error: null,\n                });\n\n                // Use a while loop to handle errors and reconnects\n                while (true) {\n                  let res;\n                  try {\n                    res = await Promise.race([iterator.next(), signalPromise]);\n                  } catch (cause) {\n                    if (isAbortError(cause)) {\n                      return;\n                    }\n                    const error = getTRPCErrorFromUnknown(cause);\n\n                    if (\n                      !retryableRpcCodes.includes(\n                        TRPC_ERROR_CODES_BY_KEY[error.code],\n                      )\n                    ) {\n                      throw coerceToTRPCClientError(error);\n                    }\n\n                    onErrorCallback(error);\n                    connectionState.next({\n                      type: 'state',\n                      state: 'connecting',\n                      error: coerceToTRPCClientError(error),\n                    });\n\n                    break;\n                  }\n\n                  if (res.done) {\n                    return;\n                  }\n                  let chunk: TRPCResult<unknown>;\n                  if (isTrackedEnvelope(res.value)) {\n                    lastEventId = res.value[0];\n\n                    chunk = {\n                      id: res.value[0],\n                      data: {\n                        id: res.value[0],\n                        data: res.value[1],\n                      },\n                    };\n                  } else {\n                    chunk = {\n                      data: res.value,\n                    };\n                  }\n\n                  observer.next({\n                    result: {\n                      ...chunk,\n                      data: transformChunk(chunk.data),\n                    },\n                  });\n                }\n              }\n              break;\n            }\n          }\n        }).catch((cause) => {\n          onErrorCallback(cause);\n          observer.error(coerceToTRPCClientError(cause));\n        });\n\n        return () => {\n          ac.abort();\n        };\n      });\n}\n/**\n * @deprecated Renamed to `unstable_localLink`. This alias will be removed in a future major release.\n */\nexport const experimental_localLink: typeof unstable_localLink =\n  unstable_localLink;\n"],"names":["opts: CreateTRPCClientOptions<TInferrable>","opts: {\n    type: TRPCType;\n    input: TInput;\n    path: string;\n    context?: OperationContext;\n    signal: Maybe<AbortSignal>;\n  }","path: string","input?: unknown","opts?: TRPCRequestOptions","input: unknown","opts: Partial<\n      TRPCSubscriptionObserver<unknown, TRPCClientError<AnyRouter>>\n    > &\n      TRPCRequestOptions","opts: CreateTRPCClientOptions<TRouter>","clientCallTypeMap: Record<\n  keyof DecorateProcedure<any, any>,\n  ProcedureType\n>","clientCallType: string","client: TRPCUntypedClient<TRouter>","opts: CreateTRPCClientOptions<TRouter>","client: TRPCClient<TRouter>","opts: HTTPBatchLinkOptions<TRouter['_def']['_config']['$types']>","type: ProcedureType","opts","json: TRPCResponse","input: unknown","lastEventId: string | undefined","_asyncIterator","r","AsyncFromSyncIterator","opts: UrlOptionsWithConnectionParams","opts: HTTPSubscriptionLinkOptions<\n    inferClientTypes<TInferrable>,\n    TEventSource\n  >","lastEventId: string | undefined","result: TRPCResult<unknown>","opts: RetryLinkOptions<TInferrable>","next$: Unsubscribable","callNextTimeout: ReturnType<typeof setTimeout> | undefined","lastEventId: string | undefined","attempts: number","r","e","n","o","OverloadYield","_awaitAsyncGenerator","_wrapAsyncGenerator","r","t","e","opts: LocalLinkOptions<TRouter>","chunk: unknown","ctx: inferRouterContext<TRouter> | undefined","newInput: unknown","cause: unknown","lastEventId: string | undefined","chunk: TRPCResult<unknown>","experimental_localLink: typeof unstable_localLink"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12],"debugId":null}},
    {"offset": {"line": 6492, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40tanstack/query-core/src/utils.ts"],"sourcesContent":["import type {\n  DefaultError,\n  Enabled,\n  FetchStatus,\n  MutationKey,\n  MutationStatus,\n  QueryFunction,\n  QueryKey,\n  QueryOptions,\n  StaleTime,\n  StaleTimeFunction,\n} from './types'\nimport type { Mutation } from './mutation'\nimport type { FetchOptions, Query } from './query'\n\n// TYPES\n\nexport interface QueryFilters<TQueryKey extends QueryKey = QueryKey> {\n  /**\n   * Filter to active queries, inactive queries or all queries\n   */\n  type?: QueryTypeFilter\n  /**\n   * Match query key exactly\n   */\n  exact?: boolean\n  /**\n   * Include queries matching this predicate function\n   */\n  predicate?: (query: Query) => boolean\n  /**\n   * Include queries matching this query key\n   */\n  queryKey?: TQueryKey\n  /**\n   * Include or exclude stale queries\n   */\n  stale?: boolean\n  /**\n   * Include queries matching their fetchStatus\n   */\n  fetchStatus?: FetchStatus\n}\n\nexport interface MutationFilters<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = unknown,\n  TContext = unknown,\n> {\n  /**\n   * Match mutation key exactly\n   */\n  exact?: boolean\n  /**\n   * Include mutations matching this predicate function\n   */\n  predicate?: (\n    mutation: Mutation<TData, TError, TVariables, TContext>,\n  ) => boolean\n  /**\n   * Include mutations matching this mutation key\n   */\n  mutationKey?: MutationKey\n  /**\n   * Filter by mutation status\n   */\n  status?: MutationStatus\n}\n\nexport type Updater<TInput, TOutput> = TOutput | ((input: TInput) => TOutput)\n\nexport type QueryTypeFilter = 'all' | 'active' | 'inactive'\n\n// UTILS\n\nexport const isServer = typeof window === 'undefined' || 'Deno' in globalThis\n\nexport function noop(): void\nexport function noop(): undefined\nexport function noop() {}\n\nexport function functionalUpdate<TInput, TOutput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput,\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as (_: TInput) => TOutput)(input)\n    : updater\n}\n\nexport function isValidTimeout(value: unknown): value is number {\n  return typeof value === 'number' && value >= 0 && value !== Infinity\n}\n\nexport function timeUntilStale(updatedAt: number, staleTime?: number): number {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0)\n}\n\nexport function resolveStaleTime<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  staleTime:\n    | undefined\n    | StaleTimeFunction<TQueryFnData, TError, TData, TQueryKey>,\n  query: Query<TQueryFnData, TError, TData, TQueryKey>,\n): StaleTime | undefined {\n  return typeof staleTime === 'function' ? staleTime(query) : staleTime\n}\n\nexport function resolveEnabled<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  enabled: undefined | Enabled<TQueryFnData, TError, TData, TQueryKey>,\n  query: Query<TQueryFnData, TError, TData, TQueryKey>,\n): boolean | undefined {\n  return typeof enabled === 'function' ? enabled(query) : enabled\n}\n\nexport function matchQuery(\n  filters: QueryFilters,\n  query: Query<any, any, any, any>,\n): boolean {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale,\n  } = filters\n\n  if (queryKey) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive()\n    if (type === 'active' && !isActive) {\n      return false\n    }\n    if (type === 'inactive' && isActive) {\n      return false\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false\n  }\n\n  if (fetchStatus && fetchStatus !== query.state.fetchStatus) {\n    return false\n  }\n\n  if (predicate && !predicate(query)) {\n    return false\n  }\n\n  return true\n}\n\nexport function matchMutation(\n  filters: MutationFilters,\n  mutation: Mutation<any, any>,\n): boolean {\n  const { exact, status, predicate, mutationKey } = filters\n  if (mutationKey) {\n    if (!mutation.options.mutationKey) {\n      return false\n    }\n    if (exact) {\n      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {\n        return false\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false\n    }\n  }\n\n  if (status && mutation.state.status !== status) {\n    return false\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false\n  }\n\n  return true\n}\n\nexport function hashQueryKeyByOptions<TQueryKey extends QueryKey = QueryKey>(\n  queryKey: TQueryKey,\n  options?: Pick<QueryOptions<any, any, any, any>, 'queryKeyHashFn'>,\n): string {\n  const hashFn = options?.queryKeyHashFn || hashKey\n  return hashFn(queryKey)\n}\n\n/**\n * Default query & mutation keys hash function.\n * Hashes the value into a stable hash.\n */\nexport function hashKey(queryKey: QueryKey | MutationKey): string {\n  return JSON.stringify(queryKey, (_, val) =>\n    isPlainObject(val)\n      ? Object.keys(val)\n          .sort()\n          .reduce((result, key) => {\n            result[key] = val[key]\n            return result\n          }, {} as any)\n      : val,\n  )\n}\n\n/**\n * Checks if key `b` partially matches with key `a`.\n */\nexport function partialMatchKey(a: QueryKey, b: QueryKey): boolean\nexport function partialMatchKey(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return Object.keys(b).every((key) => partialMatchKey(a[key], b[key]))\n  }\n\n  return false\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nexport function replaceEqualDeep<T>(a: unknown, b: T): T\nexport function replaceEqualDeep(a: any, b: any): any {\n  if (a === b) {\n    return a\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b)\n\n  if (array || (isPlainObject(a) && isPlainObject(b))) {\n    const aItems = array ? a : Object.keys(a)\n    const aSize = aItems.length\n    const bItems = array ? b : Object.keys(b)\n    const bSize = bItems.length\n    const copy: any = array ? [] : {}\n    const aItemsSet = new Set(aItems)\n\n    let equalItems = 0\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i]\n      if (\n        ((!array && aItemsSet.has(key)) || array) &&\n        a[key] === undefined &&\n        b[key] === undefined\n      ) {\n        copy[key] = undefined\n        equalItems++\n      } else {\n        copy[key] = replaceEqualDeep(a[key], b[key])\n        if (copy[key] === a[key] && a[key] !== undefined) {\n          equalItems++\n        }\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy\n  }\n\n  return b\n}\n\n/**\n * Shallow compare objects.\n */\nexport function shallowEqualObjects<T extends Record<string, any>>(\n  a: T,\n  b: T | undefined,\n): boolean {\n  if (!b || Object.keys(a).length !== Object.keys(b).length) {\n    return false\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function isPlainArray(value: unknown) {\n  return Array.isArray(value) && value.length === Object.keys(value).length\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\n// eslint-disable-next-line @typescript-eslint/no-wrapper-object-types\nexport function isPlainObject(o: any): o is Object {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has no constructor\n  const ctor = o.constructor\n  if (ctor === undefined) {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Handles Objects created by Object.create(<arbitrary prototype>)\n  if (Object.getPrototypeOf(o) !== Object.prototype) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any): boolean {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function sleep(timeout: number): Promise<void> {\n  return new Promise((resolve) => {\n    setTimeout(resolve, timeout)\n  })\n}\n\nexport function replaceData<\n  TData,\n  TOptions extends QueryOptions<any, any, any, any>,\n>(prevData: TData | undefined, data: TData, options: TOptions): TData {\n  if (typeof options.structuralSharing === 'function') {\n    return options.structuralSharing(prevData, data) as TData\n  } else if (options.structuralSharing !== false) {\n    if (process.env.NODE_ENV !== 'production') {\n      try {\n        return replaceEqualDeep(prevData, data)\n      } catch (error) {\n        console.error(\n          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${options.queryHash}]: ${error}`,\n        )\n\n        // Prevent the replaceEqualDeep from being called again down below.\n        throw error\n      }\n    }\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data)\n  }\n  return data\n}\n\nexport function keepPreviousData<T>(\n  previousData: T | undefined,\n): T | undefined {\n  return previousData\n}\n\nexport function addToEnd<T>(items: Array<T>, item: T, max = 0): Array<T> {\n  const newItems = [...items, item]\n  return max && newItems.length > max ? newItems.slice(1) : newItems\n}\n\nexport function addToStart<T>(items: Array<T>, item: T, max = 0): Array<T> {\n  const newItems = [item, ...items]\n  return max && newItems.length > max ? newItems.slice(0, -1) : newItems\n}\n\nexport const skipToken = Symbol()\nexport type SkipToken = typeof skipToken\n\nexport function ensureQueryFn<\n  TQueryFnData = unknown,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: {\n    queryFn?: QueryFunction<TQueryFnData, TQueryKey> | SkipToken\n    queryHash?: string\n  },\n  fetchOptions?: FetchOptions<TQueryFnData>,\n): QueryFunction<TQueryFnData, TQueryKey> {\n  if (process.env.NODE_ENV !== 'production') {\n    if (options.queryFn === skipToken) {\n      console.error(\n        `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${options.queryHash}'`,\n      )\n    }\n  }\n\n  // if we attempt to retry a fetch that was triggered from an initialPromise\n  // when we don't have a queryFn yet, we can't retry, so we just return the already rejected initialPromise\n  // if an observer has already mounted, we will be able to retry with that queryFn\n  if (!options.queryFn && fetchOptions?.initialPromise) {\n    return () => fetchOptions.initialPromise!\n  }\n\n  if (!options.queryFn || options.queryFn === skipToken) {\n    return () =>\n      Promise.reject(new Error(`Missing queryFn: '${options.queryHash}'`))\n  }\n\n  return options.queryFn\n}\n\nexport function shouldThrowError<T extends (...args: Array<any>) => boolean>(\n  throwOnError: boolean | T | undefined,\n  params: Parameters<T>,\n): boolean {\n  // Allow throwOnError function to override throwing behavior on a per-error basis\n  if (typeof throwOnError === 'function') {\n    return throwOnError(...params)\n  }\n\n  return !!throwOnError\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6745, "column": 0}, "map": {"version":3,"file":"getQueryKey-BY58RNzP.mjs","sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/objectWithoutPropertiesLoose.js","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/objectWithoutProperties.js","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/typeof.js","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/toPrimitive.js","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/toPropertyKey.js","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/defineProperty.js","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/objectSpread2.js","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/react-query/src/internals/getQueryKey.ts"],"sourcesContent":["function _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (e.includes(n)) continue;\n    t[n] = r[n];\n  }\n  return t;\n}\nmodule.exports = _objectWithoutPropertiesLoose, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var objectWithoutPropertiesLoose = require(\"./objectWithoutPropertiesLoose.js\");\nfunction _objectWithoutProperties(e, t) {\n  if (null == e) return {};\n  var o,\n    r,\n    i = objectWithoutPropertiesLoose(e, t);\n  if (Object.getOwnPropertySymbols) {\n    var s = Object.getOwnPropertySymbols(e);\n    for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);\n  }\n  return i;\n}\nmodule.exports = _objectWithoutProperties, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return module.exports = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports, _typeof(o);\n}\nmodule.exports = _typeof, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var _typeof = require(\"./typeof.js\")[\"default\"];\nfunction toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nmodule.exports = toPrimitive, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var _typeof = require(\"./typeof.js\")[\"default\"];\nvar toPrimitive = require(\"./toPrimitive.js\");\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nmodule.exports = toPropertyKey, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var toPropertyKey = require(\"./toPropertyKey.js\");\nfunction _defineProperty(e, r, t) {\n  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nmodule.exports = _defineProperty, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var defineProperty = require(\"./defineProperty.js\");\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nmodule.exports = _objectSpread2, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","import { skipToken } from '@tanstack/react-query';\nimport {\n  isObject,\n  type DeepPartial,\n} from '@trpc/server/unstable-core-do-not-import';\nimport type { DecoratedMutation, DecoratedQuery } from '../createTRPCReact';\nimport type { DecorateRouterRecord } from '../shared';\n\nexport type QueryType = 'any' | 'infinite' | 'query';\n\nexport type TRPCQueryKey = [\n  readonly string[],\n  { input?: unknown; type?: Exclude<QueryType, 'any'> }?,\n];\n\nexport type TRPCMutationKey = [readonly string[]]; // = [TRPCQueryKey[0]]\n\ntype ProcedureOrRouter =\n  | DecoratedMutation<any>\n  | DecoratedQuery<any>\n  | DecorateRouterRecord<any, any>;\n\n/**\n * To allow easy interactions with groups of related queries, such as\n * invalidating all queries of a router, we use an array as the path when\n * storing in tanstack query.\n **/\nexport function getQueryKeyInternal(\n  path: readonly string[],\n  input: unknown,\n  type: QueryType,\n): TRPCQueryKey {\n  // Construct a query key that is easy to destructure and flexible for\n  // partial selecting etc.\n  // https://github.com/trpc/trpc/issues/3128\n\n  // some parts of the path may be dot-separated, split them up\n  const splitPath = path.flatMap((part) => part.split('.'));\n\n  if (!input && (!type || type === 'any')) {\n    // this matches also all mutations (see `getMutationKeyInternal`)\n\n    // for `utils.invalidate()` to match all queries (including vanilla react-query)\n    // we don't want nested array if path is empty, i.e. `[]` instead of `[[]]`\n    return splitPath.length ? [splitPath] : ([] as unknown as TRPCQueryKey);\n  }\n\n  if (\n    type === 'infinite' &&\n    isObject(input) &&\n    ('direction' in input || 'cursor' in input)\n  ) {\n    const {\n      cursor: _,\n      direction: __,\n      ...inputWithoutCursorAndDirection\n    } = input;\n    return [\n      splitPath,\n      {\n        input: inputWithoutCursorAndDirection,\n        type: 'infinite',\n      },\n    ];\n  }\n  return [\n    splitPath,\n    {\n      ...(typeof input !== 'undefined' &&\n        input !== skipToken && { input: input }),\n      ...(type && type !== 'any' && { type: type }),\n    },\n  ];\n}\n\nexport function getMutationKeyInternal(path: readonly string[]) {\n  return getQueryKeyInternal(path, undefined, 'any') as TRPCMutationKey;\n}\n\ntype GetInfiniteQueryInput<\n  TProcedureInput,\n  TInputWithoutCursorAndDirection = Omit<\n    TProcedureInput,\n    'cursor' | 'direction'\n  >,\n> = keyof TInputWithoutCursorAndDirection extends never\n  ? undefined\n  : DeepPartial<TInputWithoutCursorAndDirection> | undefined;\n\n/** @internal */\nexport type GetQueryProcedureInput<TProcedureInput> = TProcedureInput extends {\n  cursor?: any;\n}\n  ? GetInfiniteQueryInput<TProcedureInput>\n  : DeepPartial<TProcedureInput> | undefined;\n\ntype GetParams<TProcedureOrRouter extends ProcedureOrRouter> =\n  TProcedureOrRouter extends DecoratedQuery<infer $Def>\n    ? [input?: GetQueryProcedureInput<$Def['input']>, type?: QueryType]\n    : [];\n\n/**\n * Method to extract the query key for a procedure\n * @param procedureOrRouter - procedure or AnyRouter\n * @param input - input to procedureOrRouter\n * @param type - defaults to `any`\n * @see https://trpc.io/docs/v11/getQueryKey\n */\nexport function getQueryKey<TProcedureOrRouter extends ProcedureOrRouter>(\n  procedureOrRouter: TProcedureOrRouter,\n  ..._params: GetParams<TProcedureOrRouter>\n) {\n  const [input, type] = _params;\n\n  // @ts-expect-error - we don't expose _def on the type layer\n  const path = procedureOrRouter._def().path as string[];\n  const queryKey = getQueryKeyInternal(path, input, type ?? 'any');\n  return queryKey;\n}\n\n// TODO: look over if we can't use a single type\nexport type QueryKeyKnown<TInput, TType extends Exclude<QueryType, 'any'>> = [\n  string[],\n  { input?: GetQueryProcedureInput<TInput>; type: TType }?,\n];\n\n/**\n * Method to extract the mutation key for a procedure\n * @param procedure - procedure\n * @see https://trpc.io/docs/v11/getQueryKey#mutations\n */\nexport function getMutationKey<TProcedure extends DecoratedMutation<any>>(\n  procedure: TProcedure,\n) {\n  // @ts-expect-error - we don't expose _def on the type layer\n  const path = procedure._def().path as string[];\n  return getMutationKeyInternal(path);\n}\n"],"names":["_objectWithoutProperties","_typeof","o","_typeof","toPrimitive","toPropertyKey","r","path: readonly string[]","input: unknown","type: QueryType","procedureOrRouter: TProcedureOrRouter","procedure: TProcedure"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7],"debugId":null}},
    {"offset": {"line": 6976, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40tanstack/query-core/src/notifyManager.ts"],"sourcesContent":["// TYPES\n\ntype NotifyCallback = () => void\n\ntype NotifyFunction = (callback: () => void) => void\n\ntype BatchNotifyFunction = (callback: () => void) => void\n\ntype BatchCallsCallback<T extends Array<unknown>> = (...args: T) => void\n\ntype ScheduleFunction = (callback: () => void) => void\n\nexport const defaultScheduler: ScheduleFunction = (cb) => setTimeout(cb, 0)\n\nexport function createNotifyManager() {\n  let queue: Array<NotifyCallback> = []\n  let transactions = 0\n  let notifyFn: NotifyFunction = (callback) => {\n    callback()\n  }\n  let batchNotifyFn: BatchNotifyFunction = (callback: () => void) => {\n    callback()\n  }\n  let scheduleFn = defaultScheduler\n\n  const schedule = (callback: NotifyCallback): void => {\n    if (transactions) {\n      queue.push(callback)\n    } else {\n      scheduleFn(() => {\n        notifyFn(callback)\n      })\n    }\n  }\n  const flush = (): void => {\n    const originalQueue = queue\n    queue = []\n    if (originalQueue.length) {\n      scheduleFn(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach((callback) => {\n            notifyFn(callback)\n          })\n        })\n      })\n    }\n  }\n\n  return {\n    batch: <T>(callback: () => T): T => {\n      let result\n      transactions++\n      try {\n        result = callback()\n      } finally {\n        transactions--\n        if (!transactions) {\n          flush()\n        }\n      }\n      return result\n    },\n    /**\n     * All calls to the wrapped function will be batched.\n     */\n    batchCalls: <T extends Array<unknown>>(\n      callback: BatchCallsCallback<T>,\n    ): BatchCallsCallback<T> => {\n      return (...args) => {\n        schedule(() => {\n          callback(...args)\n        })\n      }\n    },\n    schedule,\n    /**\n     * Use this method to set a custom notify function.\n     * This can be used to for example wrap notifications with `React.act` while running tests.\n     */\n    setNotifyFunction: (fn: NotifyFunction) => {\n      notifyFn = fn\n    },\n    /**\n     * Use this method to set a custom function to batch notifications together into a single tick.\n     * By default React Query will use the batch function provided by ReactDOM or React Native.\n     */\n    setBatchNotifyFunction: (fn: BatchNotifyFunction) => {\n      batchNotifyFn = fn\n    },\n    setScheduler: (fn: ScheduleFunction) => {\n      scheduleFn = fn\n    },\n  } as const\n}\n\n// SINGLETON\nexport const notifyManager = createNotifyManager()\n"],"names":[],"mappings":";;;;;;AAYO,IAAM,mBAAqC,CAAC,KAAO,WAAW,IAAI,CAAC;AAEnE,SAAS,sBAAsB;IACpC,IAAI,QAA+B,CAAC,CAAA;IACpC,IAAI,eAAe;IACnB,IAAI,WAA2B,CAAC,aAAa;QAC3C,SAAS;IACX;IACA,IAAI,gBAAqC,CAAC,aAAyB;QACjE,SAAS;IACX;IACA,IAAI,aAAa;IAEjB,MAAM,WAAW,CAAC,aAAmC;QACnD,IAAI,cAAc;YAChB,MAAM,IAAA,CAAK,QAAQ;QACrB,OAAO;YACL,WAAW,MAAM;gBACf,SAAS,QAAQ;YACnB,CAAC;QACH;IACF;IACA,MAAM,QAAQ,MAAY;QACxB,MAAM,gBAAgB;QACtB,QAAQ,CAAC,CAAA;QACT,IAAI,cAAc,MAAA,EAAQ;YACxB,WAAW,MAAM;gBACf,cAAc,MAAM;oBAClB,cAAc,OAAA,CAAQ,CAAC,aAAa;wBAClC,SAAS,QAAQ;oBACnB,CAAC;gBACH,CAAC;YACH,CAAC;QACH;IACF;IAEA,OAAO;QACL,OAAO,CAAI,aAAyB;YAClC,IAAI;YACJ;YACA,IAAI;gBACF,SAAS,SAAS;YACpB,SAAE;gBACA;gBACA,IAAI,CAAC,cAAc;oBACjB,MAAM;gBACR;YACF;YACA,OAAO;QACT;QAAA;;KAAA,GAIA,YAAY,CACV,aAC0B;YAC1B,OAAO,CAAA,GAAI,SAAS;gBAClB,SAAS,MAAM;oBACb,SAAS,GAAG,IAAI;gBAClB,CAAC;YACH;QACF;QACA;QAAA;;;KAAA,GAKA,mBAAmB,CAAC,OAAuB;YACzC,WAAW;QACb;QAAA;;;KAAA,GAKA,wBAAwB,CAAC,OAA4B;YACnD,gBAAgB;QAClB;QACA,cAAc,CAAC,OAAyB;YACtC,aAAa;QACf;IACF;AACF;AAGO,IAAM,gBAAgB,oBAAoB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7065, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40tanstack/query-core/src/subscribable.ts"],"sourcesContent":["export class Subscribable<TListener extends Function> {\n  protected listeners = new Set<TListener>()\n\n  constructor() {\n    this.subscribe = this.subscribe.bind(this)\n  }\n\n  subscribe(listener: TListener): () => void {\n    this.listeners.add(listener)\n\n    this.onSubscribe()\n\n    return () => {\n      this.listeners.delete(listener)\n      this.onUnsubscribe()\n    }\n  }\n\n  hasListeners(): boolean {\n    return this.listeners.size > 0\n  }\n\n  protected onSubscribe(): void {\n    // Do nothing\n  }\n\n  protected onUnsubscribe(): void {\n    // Do nothing\n  }\n}\n"],"names":[],"mappings":";;;;AAAO,IAAM,eAAN,MAA+C;IAGpD,aAAc;QAFd,IAAA,CAAU,SAAA,GAAY,aAAA,GAAA,IAAI,IAAe;QAGvC,IAAA,CAAK,SAAA,GAAY,IAAA,CAAK,SAAA,CAAU,IAAA,CAAK,IAAI;IAC3C;IAEA,UAAU,QAAA,EAAiC;QACzC,IAAA,CAAK,SAAA,CAAU,GAAA,CAAI,QAAQ;QAE3B,IAAA,CAAK,WAAA,CAAY;QAEjB,OAAO,MAAM;YACX,IAAA,CAAK,SAAA,CAAU,MAAA,CAAO,QAAQ;YAC9B,IAAA,CAAK,aAAA,CAAc;QACrB;IACF;IAEA,eAAwB;QACtB,OAAO,IAAA,CAAK,SAAA,CAAU,IAAA,GAAO;IAC/B;IAEU,cAAoB,CAE9B;IAEU,gBAAsB,CAEhC;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7096, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40tanstack/query-core/src/focusManager.ts"],"sourcesContent":["import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\ntype Listener = (focused: boolean) => void\n\ntype SetupFn = (\n  setFocused: (focused?: boolean) => void,\n) => (() => void) | undefined\n\nexport class FocusManager extends Subscribable<Listener> {\n  #focused?: boolean\n  #cleanup?: () => void\n\n  #setup: SetupFn\n\n  constructor() {\n    super()\n    this.#setup = (onFocus) => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus()\n        // Listen to visibilitychange\n        window.addEventListener('visibilitychange', listener, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', listener)\n        }\n      }\n      return\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup)\n    }\n  }\n\n  protected onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.()\n      this.#cleanup = undefined\n    }\n  }\n\n  setEventListener(setup: SetupFn): void {\n    this.#setup = setup\n    this.#cleanup?.()\n    this.#cleanup = setup((focused) => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused)\n      } else {\n        this.onFocus()\n      }\n    })\n  }\n\n  setFocused(focused?: boolean): void {\n    const changed = this.#focused !== focused\n    if (changed) {\n      this.#focused = focused\n      this.onFocus()\n    }\n  }\n\n  onFocus(): void {\n    const isFocused = this.isFocused()\n    this.listeners.forEach((listener) => {\n      listener(isFocused)\n    })\n  }\n\n  isFocused(): boolean {\n    if (typeof this.#focused === 'boolean') {\n      return this.#focused\n    }\n\n    // document global can be unavailable in react native\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    return globalThis.document?.visibilityState !== 'hidden'\n  }\n}\n\nexport const focusManager = new FocusManager()\n"],"names":[],"mappings":";;;;;AAAA,SAAS,oBAAoB;AAC7B,SAAS,gBAAgB;;;AAQlB,IAAM,eAAN,gMAA2B,eAAA,CAAuB;KACvD,OAAA,CAAA;KACA,OAAA,CAAA;KAEA,KAAA,CAAA;IAEA,aAAc;QACZ,KAAA,CAAM;QACN,IAAA,EAAK,KAAA,GAAS,CAAC,YAAY;YAGzB,IAAI,4KAAC,WAAA,IAAY,OAAO,gBAAA,EAAkB;gBACxC,MAAM,WAAW,IAAM,QAAQ;gBAE/B,OAAO,gBAAA,CAAiB,oBAAoB,UAAU,KAAK;gBAE3D,OAAO,MAAM;oBAEX,OAAO,mBAAA,CAAoB,oBAAoB,QAAQ;gBACzD;YACF;YACA;QACF;IACF;IAEU,cAAoB;QAC5B,IAAI,CAAC,IAAA,EAAK,OAAA,EAAU;YAClB,IAAA,CAAK,gBAAA,CAAiB,IAAA,EAAK,KAAM;QACnC;IACF;IAEU,gBAAgB;QACxB,IAAI,CAAC,IAAA,CAAK,YAAA,CAAa,GAAG;YACxB,IAAA,EAAK,OAAA,GAAW;YAChB,IAAA,EAAK,OAAA,GAAW,KAAA;QAClB;IACF;IAEA,iBAAiB,KAAA,EAAsB;QACrC,IAAA,EAAK,KAAA,GAAS;QACd,IAAA,EAAK,OAAA,GAAW;QAChB,IAAA,EAAK,OAAA,GAAW,MAAM,CAAC,YAAY;YACjC,IAAI,OAAO,YAAY,WAAW;gBAChC,IAAA,CAAK,UAAA,CAAW,OAAO;YACzB,OAAO;gBACL,IAAA,CAAK,OAAA,CAAQ;YACf;QACF,CAAC;IACH;IAEA,WAAW,OAAA,EAAyB;QAClC,MAAM,UAAU,IAAA,EAAK,OAAA,KAAa;QAClC,IAAI,SAAS;YACX,IAAA,EAAK,OAAA,GAAW;YAChB,IAAA,CAAK,OAAA,CAAQ;QACf;IACF;IAEA,UAAgB;QACd,MAAM,YAAY,IAAA,CAAK,SAAA,CAAU;QACjC,IAAA,CAAK,SAAA,CAAU,OAAA,CAAQ,CAAC,aAAa;YACnC,SAAS,SAAS;QACpB,CAAC;IACH;IAEA,YAAqB;QACnB,IAAI,OAAO,IAAA,EAAK,OAAA,KAAa,WAAW;YACtC,OAAO,IAAA,EAAK,OAAA;QACd;QAIA,OAAO,WAAW,QAAA,EAAU,oBAAoB;IAClD;AACF;AAEO,IAAM,eAAe,IAAI,aAAa","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7173, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40tanstack/query-core/src/onlineManager.ts"],"sourcesContent":["import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\ntype Listener = (online: boolean) => void\ntype SetupFn = (setOnline: Listener) => (() => void) | undefined\n\nexport class OnlineManager extends Subscribable<Listener> {\n  #online = true\n  #cleanup?: () => void\n\n  #setup: SetupFn\n\n  constructor() {\n    super()\n    this.#setup = (onOnline) => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const onlineListener = () => onOnline(true)\n        const offlineListener = () => onOnline(false)\n        // Listen to online\n        window.addEventListener('online', onlineListener, false)\n        window.addEventListener('offline', offlineListener, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('online', onlineListener)\n          window.removeEventListener('offline', offlineListener)\n        }\n      }\n\n      return\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup)\n    }\n  }\n\n  protected onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.()\n      this.#cleanup = undefined\n    }\n  }\n\n  setEventListener(setup: SetupFn): void {\n    this.#setup = setup\n    this.#cleanup?.()\n    this.#cleanup = setup(this.setOnline.bind(this))\n  }\n\n  setOnline(online: boolean): void {\n    const changed = this.#online !== online\n\n    if (changed) {\n      this.#online = online\n      this.listeners.forEach((listener) => {\n        listener(online)\n      })\n    }\n  }\n\n  isOnline(): boolean {\n    return this.#online\n  }\n}\n\nexport const onlineManager = new OnlineManager()\n"],"names":[],"mappings":";;;;;AAAA,SAAS,oBAAoB;AAC7B,SAAS,gBAAgB;;;AAKlB,IAAM,gBAAN,gMAA4B,eAAA,CAAuB;KACxD,MAAA,GAAU,KAAA;KACV,OAAA,CAAA;KAEA,KAAA,CAAA;IAEA,aAAc;QACZ,KAAA,CAAM;QACN,IAAA,EAAK,KAAA,GAAS,CAAC,aAAa;YAG1B,IAAI,4KAAC,WAAA,IAAY,OAAO,gBAAA,EAAkB;gBACxC,MAAM,iBAAiB,IAAM,SAAS,IAAI;gBAC1C,MAAM,kBAAkB,IAAM,SAAS,KAAK;gBAE5C,OAAO,gBAAA,CAAiB,UAAU,gBAAgB,KAAK;gBACvD,OAAO,gBAAA,CAAiB,WAAW,iBAAiB,KAAK;gBAEzD,OAAO,MAAM;oBAEX,OAAO,mBAAA,CAAoB,UAAU,cAAc;oBACnD,OAAO,mBAAA,CAAoB,WAAW,eAAe;gBACvD;YACF;YAEA;QACF;IACF;IAEU,cAAoB;QAC5B,IAAI,CAAC,IAAA,EAAK,OAAA,EAAU;YAClB,IAAA,CAAK,gBAAA,CAAiB,IAAA,EAAK,KAAM;QACnC;IACF;IAEU,gBAAgB;QACxB,IAAI,CAAC,IAAA,CAAK,YAAA,CAAa,GAAG;YACxB,IAAA,EAAK,OAAA,GAAW;YAChB,IAAA,EAAK,OAAA,GAAW,KAAA;QAClB;IACF;IAEA,iBAAiB,KAAA,EAAsB;QACrC,IAAA,EAAK,KAAA,GAAS;QACd,IAAA,EAAK,OAAA,GAAW;QAChB,IAAA,EAAK,OAAA,GAAW,MAAM,IAAA,CAAK,SAAA,CAAU,IAAA,CAAK,IAAI,CAAC;IACjD;IAEA,UAAU,MAAA,EAAuB;QAC/B,MAAM,UAAU,IAAA,EAAK,MAAA,KAAY;QAEjC,IAAI,SAAS;YACX,IAAA,EAAK,MAAA,GAAU;YACf,IAAA,CAAK,SAAA,CAAU,OAAA,CAAQ,CAAC,aAAa;gBACnC,SAAS,MAAM;YACjB,CAAC;QACH;IACF;IAEA,WAAoB;QAClB,OAAO,IAAA,EAAK,MAAA;IACd;AACF;AAEO,IAAM,gBAAgB,IAAI,cAAc","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7240, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40tanstack/query-core/src/thenable.ts"],"sourcesContent":["/**\n * Thenable types which matches React's types for promises\n *\n * React seemingly uses `.status`, `.value` and `.reason` properties on a promises to optimistically unwrap data from promises\n *\n * @see https://github.com/facebook/react/blob/main/packages/shared/ReactTypes.js#L112-L138\n * @see https://github.com/facebook/react/blob/4f604941569d2e8947ce1460a0b2997e835f37b9/packages/react-debug-tools/src/ReactDebugHooks.js#L224-L227\n */\n\nimport { noop } from './utils'\n\ninterface Fulfilled<T> {\n  status: 'fulfilled'\n  value: T\n}\ninterface Rejected {\n  status: 'rejected'\n  reason: unknown\n}\ninterface Pending<T> {\n  status: 'pending'\n\n  /**\n   * Resolve the promise with a value.\n   * Will remove the `resolve` and `reject` properties from the promise.\n   */\n  resolve: (value: T) => void\n  /**\n   * Reject the promise with a reason.\n   * Will remove the `resolve` and `reject` properties from the promise.\n   */\n  reject: (reason: unknown) => void\n}\n\nexport type FulfilledThenable<T> = Promise<T> & Fulfilled<T>\nexport type RejectedThenable<T> = Promise<T> & Rejected\nexport type PendingThenable<T> = Promise<T> & Pending<T>\n\nexport type Thenable<T> =\n  | FulfilledThenable<T>\n  | RejectedThenable<T>\n  | PendingThenable<T>\n\nexport function pendingThenable<T>(): PendingThenable<T> {\n  let resolve: Pending<T>['resolve']\n  let reject: Pending<T>['reject']\n  // this could use `Promise.withResolvers()` in the future\n  const thenable = new Promise((_resolve, _reject) => {\n    resolve = _resolve\n    reject = _reject\n  }) as PendingThenable<T>\n\n  thenable.status = 'pending'\n  thenable.catch(() => {\n    // prevent unhandled rejection errors\n  })\n\n  function finalize(data: Fulfilled<T> | Rejected) {\n    Object.assign(thenable, data)\n\n    // clear pending props props to avoid calling them twice\n    delete (thenable as Partial<PendingThenable<T>>).resolve\n    delete (thenable as Partial<PendingThenable<T>>).reject\n  }\n\n  thenable.resolve = (value) => {\n    finalize({\n      status: 'fulfilled',\n      value,\n    })\n\n    resolve(value)\n  }\n  thenable.reject = (reason) => {\n    finalize({\n      status: 'rejected',\n      reason,\n    })\n\n    reject(reason)\n  }\n\n  return thenable\n}\n\n/**\n * This function takes a Promise-like input and detects whether the data\n * is synchronously available or not.\n *\n * It does not inspect .status, .value or .reason properties of the promise,\n * as those are not always available, and the .status of React's promises\n * should not be considered part of the public API.\n */\nexport function tryResolveSync(promise: Promise<unknown> | Thenable<unknown>) {\n  let data: unknown\n\n  promise\n    .then((result) => {\n      data = result\n      return result\n    }, noop)\n    // .catch can be unavailable on certain kinds of thenable's\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    ?.catch(noop)\n\n  if (data !== undefined) {\n    return { data }\n  }\n\n  return undefined\n}\n"],"names":[],"mappings":";;;;;AASA,SAAS,YAAY;;AAkCd,SAAS,kBAAyC;IACvD,IAAI;IACJ,IAAI;IAEJ,MAAM,WAAW,IAAI,QAAQ,CAAC,UAAU,YAAY;QAClD,UAAU;QACV,SAAS;IACX,CAAC;IAED,SAAS,MAAA,GAAS;IAClB,SAAS,KAAA,CAAM,KAEf,CAFqB,AAEpB;IAED,SAAS,SAAS,IAAA,EAA+B;QAC/C,OAAO,MAAA,CAAO,UAAU,IAAI;QAG5B,OAAQ,SAAyC,OAAA;QACjD,OAAQ,SAAyC,MAAA;IACnD;IAEA,SAAS,OAAA,GAAU,CAAC,UAAU;QAC5B,SAAS;YACP,QAAQ;YACR;QACF,CAAC;QAED,QAAQ,KAAK;IACf;IACA,SAAS,MAAA,GAAS,CAAC,WAAW;QAC5B,SAAS;YACP,QAAQ;YACR;QACF,CAAC;QAED,OAAO,MAAM;IACf;IAEA,OAAO;AACT;AAUO,SAAS,eAAe,OAAA,EAA+C;IAC5E,IAAI;IAEJ,QACG,IAAA,CAAK,CAAC,WAAW;QAChB,OAAO;QACP,OAAO;IACT,8KAAG,OAAI,GAGL,iLAAM,OAAI;IAEd,IAAI,SAAS,KAAA,GAAW;QACtB,OAAO;YAAE;QAAK;IAChB;IAEA,OAAO,KAAA;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7298, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40tanstack/query-core/src/retryer.ts"],"sourcesContent":["import { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { pendingThenable } from './thenable'\nimport { isServer, sleep } from './utils'\nimport type { CancelOptions, DefaultError, NetworkMode } from './types'\n\n// TYPES\n\ninterface RetryerConfig<TData = unknown, TError = DefaultError> {\n  fn: () => TData | Promise<TData>\n  initialPromise?: Promise<TData>\n  abort?: () => void\n  onError?: (error: TError) => void\n  onSuccess?: (data: TData) => void\n  onFail?: (failureCount: number, error: TError) => void\n  onPause?: () => void\n  onContinue?: () => void\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode: NetworkMode | undefined\n  canRun: () => boolean\n}\n\nexport interface Retryer<TData = unknown> {\n  promise: Promise<TData>\n  cancel: (cancelOptions?: CancelOptions) => void\n  continue: () => Promise<unknown>\n  cancelRetry: () => void\n  continueRetry: () => void\n  canStart: () => boolean\n  start: () => Promise<TData>\n}\n\nexport type RetryValue<TError> = boolean | number | ShouldRetryFunction<TError>\n\ntype ShouldRetryFunction<TError = DefaultError> = (\n  failureCount: number,\n  error: TError,\n) => boolean\n\nexport type RetryDelayValue<TError> = number | RetryDelayFunction<TError>\n\ntype RetryDelayFunction<TError = DefaultError> = (\n  failureCount: number,\n  error: TError,\n) => number\n\nfunction defaultRetryDelay(failureCount: number) {\n  return Math.min(1000 * 2 ** failureCount, 30000)\n}\n\nexport function canFetch(networkMode: NetworkMode | undefined): boolean {\n  return (networkMode ?? 'online') === 'online'\n    ? onlineManager.isOnline()\n    : true\n}\n\nexport class CancelledError extends Error {\n  revert?: boolean\n  silent?: boolean\n  constructor(options?: CancelOptions) {\n    super('CancelledError')\n    this.revert = options?.revert\n    this.silent = options?.silent\n  }\n}\n\nexport function isCancelledError(value: any): value is CancelledError {\n  return value instanceof CancelledError\n}\n\nexport function createRetryer<TData = unknown, TError = DefaultError>(\n  config: RetryerConfig<TData, TError>,\n): Retryer<TData> {\n  let isRetryCancelled = false\n  let failureCount = 0\n  let isResolved = false\n  let continueFn: ((value?: unknown) => void) | undefined\n\n  const thenable = pendingThenable<TData>()\n\n  const cancel = (cancelOptions?: CancelOptions): void => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions))\n\n      config.abort?.()\n    }\n  }\n  const cancelRetry = () => {\n    isRetryCancelled = true\n  }\n\n  const continueRetry = () => {\n    isRetryCancelled = false\n  }\n\n  const canContinue = () =>\n    focusManager.isFocused() &&\n    (config.networkMode === 'always' || onlineManager.isOnline()) &&\n    config.canRun()\n\n  const canStart = () => canFetch(config.networkMode) && config.canRun()\n\n  const resolve = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onSuccess?.(value)\n      continueFn?.()\n      thenable.resolve(value)\n    }\n  }\n\n  const reject = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onError?.(value)\n      continueFn?.()\n      thenable.reject(value)\n    }\n  }\n\n  const pause = () => {\n    return new Promise((continueResolve) => {\n      continueFn = (value) => {\n        if (isResolved || canContinue()) {\n          continueResolve(value)\n        }\n      }\n      config.onPause?.()\n    }).then(() => {\n      continueFn = undefined\n      if (!isResolved) {\n        config.onContinue?.()\n      }\n    })\n  }\n\n  // Create loop function\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return\n    }\n\n    let promiseOrValue: any\n\n    // we can re-use config.initialPromise on the first call of run()\n    const initialPromise =\n      failureCount === 0 ? config.initialPromise : undefined\n\n    // Execute query\n    try {\n      promiseOrValue = initialPromise ?? config.fn()\n    } catch (error) {\n      promiseOrValue = Promise.reject(error)\n    }\n\n    Promise.resolve(promiseOrValue)\n      .then(resolve)\n      .catch((error) => {\n        // Stop if the fetch is already resolved\n        if (isResolved) {\n          return\n        }\n\n        // Do we need to retry the request?\n        const retry = config.retry ?? (isServer ? 0 : 3)\n        const retryDelay = config.retryDelay ?? defaultRetryDelay\n        const delay =\n          typeof retryDelay === 'function'\n            ? retryDelay(failureCount, error)\n            : retryDelay\n        const shouldRetry =\n          retry === true ||\n          (typeof retry === 'number' && failureCount < retry) ||\n          (typeof retry === 'function' && retry(failureCount, error))\n\n        if (isRetryCancelled || !shouldRetry) {\n          // We are done if the query does not need to be retried\n          reject(error)\n          return\n        }\n\n        failureCount++\n\n        // Notify on fail\n        config.onFail?.(failureCount, error)\n\n        // Delay\n        sleep(delay)\n          // Pause if the document is not visible or when the device is offline\n          .then(() => {\n            return canContinue() ? undefined : pause()\n          })\n          .then(() => {\n            if (isRetryCancelled) {\n              reject(error)\n            } else {\n              run()\n            }\n          })\n      })\n  }\n\n  return {\n    promise: thenable,\n    cancel,\n    continue: () => {\n      continueFn?.()\n      return thenable\n    },\n    cancelRetry,\n    continueRetry,\n    canStart,\n    start: () => {\n      // Start loop\n      if (canStart()) {\n        run()\n      } else {\n        pause().then(run)\n      }\n      return thenable\n    },\n  }\n}\n"],"names":[],"mappings":";;;;;;;AAAA,SAAS,oBAAoB;AAC7B,SAAS,qBAAqB;AAC9B,SAAS,uBAAuB;AAChC,SAAS,UAAU,aAAa;;;;;AA4ChC,SAAS,kBAAkB,YAAA,EAAsB;IAC/C,OAAO,KAAK,GAAA,CAAI,MAAO,KAAK,cAAc,GAAK;AACjD;AAEO,SAAS,SAAS,WAAA,EAA+C;IACtE,OAAA,CAAQ,eAAe,QAAA,MAAc,8LACjC,gBAAA,CAAc,QAAA,CAAS,IACvB;AACN;AAEO,IAAM,iBAAN,cAA6B,MAAM;IAGxC,YAAY,OAAA,CAAyB;QACnC,KAAA,CAAM,gBAAgB;QACtB,IAAA,CAAK,MAAA,GAAS,SAAS;QACvB,IAAA,CAAK,MAAA,GAAS,SAAS;IACzB;AACF;AAEO,SAAS,iBAAiB,KAAA,EAAqC;IACpE,OAAO,iBAAiB;AAC1B;AAEO,SAAS,cACd,MAAA,EACgB;IAChB,IAAI,mBAAmB;IACvB,IAAI,eAAe;IACnB,IAAI,aAAa;IACjB,IAAI;IAEJ,MAAM,6LAAW,kBAAA,CAAuB;IAExC,MAAM,SAAS,CAAC,kBAAwC;QACtD,IAAI,CAAC,YAAY;YACf,OAAO,IAAI,eAAe,aAAa,CAAC;YAExC,OAAO,KAAA,GAAQ;QACjB;IACF;IACA,MAAM,cAAc,MAAM;QACxB,mBAAmB;IACrB;IAEA,MAAM,gBAAgB,MAAM;QAC1B,mBAAmB;IACrB;IAEA,MAAM,cAAc,IAClB,iMAAA,CAAa,SAAA,CAAU,KAAA,CACtB,OAAO,WAAA,KAAgB,+LAAY,gBAAA,CAAc,QAAA,CAAS,CAAA,KAC3D,OAAO,MAAA,CAAO;IAEhB,MAAM,WAAW,IAAM,SAAS,OAAO,WAAW,KAAK,OAAO,MAAA,CAAO;IAErE,MAAM,UAAU,CAAC,UAAe;QAC9B,IAAI,CAAC,YAAY;YACf,aAAa;YACb,OAAO,SAAA,GAAY,KAAK;YACxB,aAAa;YACb,SAAS,OAAA,CAAQ,KAAK;QACxB;IACF;IAEA,MAAM,SAAS,CAAC,UAAe;QAC7B,IAAI,CAAC,YAAY;YACf,aAAa;YACb,OAAO,OAAA,GAAU,KAAK;YACtB,aAAa;YACb,SAAS,MAAA,CAAO,KAAK;QACvB;IACF;IAEA,MAAM,QAAQ,MAAM;QAClB,OAAO,IAAI,QAAQ,CAAC,oBAAoB;YACtC,aAAa,CAAC,UAAU;gBACtB,IAAI,cAAc,YAAY,GAAG;oBAC/B,gBAAgB,KAAK;gBACvB;YACF;YACA,OAAO,OAAA,GAAU;QACnB,CAAC,EAAE,IAAA,CAAK,MAAM;YACZ,aAAa,KAAA;YACb,IAAI,CAAC,YAAY;gBACf,OAAO,UAAA,GAAa;YACtB;QACF,CAAC;IACH;IAGA,MAAM,MAAM,MAAM;QAEhB,IAAI,YAAY;YACd;QACF;QAEA,IAAI;QAGJ,MAAM,iBACJ,iBAAiB,IAAI,OAAO,cAAA,GAAiB,KAAA;QAG/C,IAAI;YACF,iBAAiB,kBAAkB,OAAO,EAAA,CAAG;QAC/C,EAAA,OAAS,OAAO;YACd,iBAAiB,QAAQ,MAAA,CAAO,KAAK;QACvC;QAEA,QAAQ,OAAA,CAAQ,cAAc,EAC3B,IAAA,CAAK,OAAO,EACZ,KAAA,CAAM,CAAC,UAAU;YAEhB,IAAI,YAAY;gBACd;YACF;YAGA,MAAM,QAAQ,OAAO,KAAA,IAAA,4KAAU,WAAA,GAAW,IAAI,CAAA;YAC9C,MAAM,aAAa,OAAO,UAAA,IAAc;YACxC,MAAM,QACJ,OAAO,eAAe,aAClB,WAAW,cAAc,KAAK,IAC9B;YACN,MAAM,cACJ,UAAU,QACT,OAAO,UAAU,YAAY,eAAe,SAC5C,OAAO,UAAU,cAAc,MAAM,cAAc,KAAK;YAE3D,IAAI,oBAAoB,CAAC,aAAa;gBAEpC,OAAO,KAAK;gBACZ;YACF;YAEA;YAGA,OAAO,MAAA,GAAS,cAAc,KAAK;YAGnC,CAAA,GAAA,0KAAA,CAAA,QAAA,EAAM,KAAK,EAER,IAAA,CAAK,MAAM;gBACV,OAAO,YAAY,IAAI,KAAA,IAAY,MAAM;YAC3C,CAAC,EACA,IAAA,CAAK,MAAM;gBACV,IAAI,kBAAkB;oBACpB,OAAO,KAAK;gBACd,OAAO;oBACL,IAAI;gBACN;YACF,CAAC;QACL,CAAC;IACL;IAEA,OAAO;QACL,SAAS;QACT;QACA,UAAU,MAAM;YACd,aAAa;YACb,OAAO;QACT;QACA;QACA;QACA;QACA,OAAO,MAAM;YAEX,IAAI,SAAS,GAAG;gBACd,IAAI;YACN,OAAO;gBACL,MAAM,EAAE,IAAA,CAAK,GAAG;YAClB;YACA,OAAO;QACT;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7444, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40tanstack/query-core/src/removable.ts"],"sourcesContent":["import { isServer, isValidTimeout } from './utils'\n\nexport abstract class Removable {\n  gcTime!: number\n  #gcTimeout?: ReturnType<typeof setTimeout>\n\n  destroy(): void {\n    this.clearGcTimeout()\n  }\n\n  protected scheduleGc(): void {\n    this.clearGcTimeout()\n\n    if (isValidTimeout(this.gcTime)) {\n      this.#gcTimeout = setTimeout(() => {\n        this.optionalRemove()\n      }, this.gcTime)\n    }\n  }\n\n  protected updateGcTime(newGcTime: number | undefined): void {\n    // Default to 5 minutes (Infinity for server-side) if no gcTime is set\n    this.gcTime = Math.max(\n      this.gcTime || 0,\n      newGcTime ?? (isServer ? Infinity : 5 * 60 * 1000),\n    )\n  }\n\n  protected clearGcTimeout() {\n    if (this.#gcTimeout) {\n      clearTimeout(this.#gcTimeout)\n      this.#gcTimeout = undefined\n    }\n  }\n\n  protected abstract optionalRemove(): void\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,UAAU,sBAAsB;;AAElC,IAAe,YAAf,MAAyB;KAE9B,SAAA,CAAA;IAEA,UAAgB;QACd,IAAA,CAAK,cAAA,CAAe;IACtB;IAEU,aAAmB;QAC3B,IAAA,CAAK,cAAA,CAAe;QAEpB,mLAAI,iBAAA,EAAe,IAAA,CAAK,MAAM,GAAG;YAC/B,IAAA,EAAK,SAAA,GAAa,WAAW,MAAM;gBACjC,IAAA,CAAK,cAAA,CAAe;YACtB,GAAG,IAAA,CAAK,MAAM;QAChB;IACF;IAEU,aAAa,SAAA,EAAqC;QAE1D,IAAA,CAAK,MAAA,GAAS,KAAK,GAAA,CACjB,IAAA,CAAK,MAAA,IAAU,GACf,aAAA,4KAAc,WAAA,GAAW,WAAW,IAAI,KAAK,GAAA;IAEjD;IAEU,iBAAiB;QACzB,IAAI,IAAA,EAAK,SAAA,EAAY;YACnB,aAAa,IAAA,EAAK,SAAU;YAC5B,IAAA,EAAK,SAAA,GAAa,KAAA;QACpB;IACF;AAGF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7481, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40tanstack/query-core/src/query.ts"],"sourcesContent":["import {\n  ensureQueryFn,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  skipToken,\n  timeUntilStale,\n} from './utils'\nimport { notifyManager } from './notifyManager'\nimport { canFetch, createRetryer, isCancelledError } from './retryer'\nimport { Removable } from './removable'\nimport type { QueryCache } from './queryCache'\nimport type { QueryClient } from './queryClient'\nimport type {\n  CancelOptions,\n  DefaultError,\n  FetchStatus,\n  InitialDataFunction,\n  OmitKeyof,\n  QueryFunctionContext,\n  QueryKey,\n  QueryMeta,\n  QueryOptions,\n  QueryStatus,\n  SetDataOptions,\n  StaleTime,\n} from './types'\nimport type { QueryObserver } from './queryObserver'\nimport type { Retryer } from './retryer'\n\n// TYPES\n\ninterface QueryConfig<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  client: QueryClient\n  queryKey: TQueryKey\n  queryHash: string\n  options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state?: QueryState<TData, TError>\n}\n\nexport interface QueryState<TData = unknown, TError = DefaultError> {\n  data: TData | undefined\n  dataUpdateCount: number\n  dataUpdatedAt: number\n  error: TError | null\n  errorUpdateCount: number\n  errorUpdatedAt: number\n  fetchFailureCount: number\n  fetchFailureReason: TError | null\n  fetchMeta: FetchMeta | null\n  isInvalidated: boolean\n  status: QueryStatus\n  fetchStatus: FetchStatus\n}\n\nexport interface FetchContext<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  fetchFn: () => unknown | Promise<unknown>\n  fetchOptions?: FetchOptions\n  signal: AbortSignal\n  options: QueryOptions<TQueryFnData, TError, TData, any>\n  client: QueryClient\n  queryKey: TQueryKey\n  state: QueryState<TData, TError>\n}\n\nexport interface QueryBehavior<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  onFetch: (\n    context: FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n    query: Query,\n  ) => void\n}\n\nexport type FetchDirection = 'forward' | 'backward'\n\nexport interface FetchMeta {\n  fetchMore?: { direction: FetchDirection }\n}\n\nexport interface FetchOptions<TData = unknown> {\n  cancelRefetch?: boolean\n  meta?: FetchMeta\n  initialPromise?: Promise<TData>\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError\n}\n\ninterface FetchAction {\n  type: 'fetch'\n  meta?: FetchMeta\n}\n\ninterface SuccessAction<TData> {\n  data: TData | undefined\n  type: 'success'\n  dataUpdatedAt?: number\n  manual?: boolean\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface InvalidateAction {\n  type: 'invalidate'\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError> {\n  type: 'setState'\n  state: Partial<QueryState<TData, TError>>\n  setStateOptions?: SetStateOptions\n}\n\nexport type Action<TData, TError> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | FetchAction\n  | InvalidateAction\n  | PauseAction\n  | SetStateAction<TData, TError>\n  | SuccessAction<TData>\n\nexport interface SetStateOptions {\n  meta?: any\n}\n\n// CLASS\n\nexport class Query<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Removable {\n  queryKey: TQueryKey\n  queryHash: string\n  options!: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state: QueryState<TData, TError>\n\n  #initialState: QueryState<TData, TError>\n  #revertState?: QueryState<TData, TError>\n  #cache: QueryCache\n  #client: QueryClient\n  #retryer?: Retryer<TData>\n  observers: Array<QueryObserver<any, any, any, any, any>>\n  #defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  #abortSignalConsumed: boolean\n\n  constructor(config: QueryConfig<TQueryFnData, TError, TData, TQueryKey>) {\n    super()\n\n    this.#abortSignalConsumed = false\n    this.#defaultOptions = config.defaultOptions\n    this.setOptions(config.options)\n    this.observers = []\n    this.#client = config.client\n    this.#cache = this.#client.getQueryCache()\n    this.queryKey = config.queryKey\n    this.queryHash = config.queryHash\n    this.#initialState = getDefaultState(this.options)\n    this.state = config.state ?? this.#initialState\n    this.scheduleGc()\n  }\n  get meta(): QueryMeta | undefined {\n    return this.options.meta\n  }\n\n  get promise(): Promise<TData> | undefined {\n    return this.#retryer?.promise\n  }\n\n  setOptions(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): void {\n    this.options = { ...this.#defaultOptions, ...options }\n\n    this.updateGcTime(this.options.gcTime)\n  }\n\n  protected optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.#cache.remove(this)\n    }\n  }\n\n  setData(\n    newData: TData,\n    options?: SetDataOptions & { manual: boolean },\n  ): TData {\n    const data = replaceData(this.state.data, newData, this.options)\n\n    // Set data and mark it as cached\n    this.#dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual,\n    })\n\n    return data\n  }\n\n  setState(\n    state: Partial<QueryState<TData, TError>>,\n    setStateOptions?: SetStateOptions,\n  ): void {\n    this.#dispatch({ type: 'setState', state, setStateOptions })\n  }\n\n  cancel(options?: CancelOptions): Promise<void> {\n    const promise = this.#retryer?.promise\n    this.#retryer?.cancel(options)\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve()\n  }\n\n  destroy(): void {\n    super.destroy()\n\n    this.cancel({ silent: true })\n  }\n\n  reset(): void {\n    this.destroy()\n    this.setState(this.#initialState)\n  }\n\n  isActive(): boolean {\n    return this.observers.some(\n      (observer) => resolveEnabled(observer.options.enabled, this) !== false,\n    )\n  }\n\n  isDisabled(): boolean {\n    if (this.getObserversCount() > 0) {\n      return !this.isActive()\n    }\n    // if a query has no observers, it should still be considered disabled if it never attempted a fetch\n    return (\n      this.options.queryFn === skipToken ||\n      this.state.dataUpdateCount + this.state.errorUpdateCount === 0\n    )\n  }\n\n  isStatic(): boolean {\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) =>\n          resolveStaleTime(observer.options.staleTime, this) === 'static',\n      )\n    }\n\n    return false\n  }\n\n  isStale(): boolean {\n    // check observers first, their `isStale` has the source of truth\n    // calculated with `isStaleByTime` and it takes `enabled` into account\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) => observer.getCurrentResult().isStale,\n      )\n    }\n\n    return this.state.data === undefined || this.state.isInvalidated\n  }\n\n  isStaleByTime(staleTime: StaleTime = 0): boolean {\n    // no data is always stale\n    if (this.state.data === undefined) {\n      return true\n    }\n    // static is never stale\n    if (staleTime === 'static') {\n      return false\n    }\n    // if the query is invalidated, it is stale\n    if (this.state.isInvalidated) {\n      return true\n    }\n\n    return !timeUntilStale(this.state.dataUpdatedAt, staleTime)\n  }\n\n  onFocus(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  onOnline(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnReconnect())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  addObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer)\n\n      // Stop the query from being garbage collected\n      this.clearGcTimeout()\n\n      this.#cache.notify({ type: 'observerAdded', query: this, observer })\n    }\n  }\n\n  removeObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter((x) => x !== observer)\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({ revert: true })\n          } else {\n            this.#retryer.cancelRetry()\n          }\n        }\n\n        this.scheduleGc()\n      }\n\n      this.#cache.notify({ type: 'observerRemoved', query: this, observer })\n    }\n  }\n\n  getObserversCount(): number {\n    return this.observers.length\n  }\n\n  invalidate(): void {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({ type: 'invalidate' })\n    }\n  }\n\n  fetch(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    fetchOptions?: FetchOptions<TQueryFnData>,\n  ): Promise<TData> {\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.data !== undefined && fetchOptions?.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetch\n        this.cancel({ silent: true })\n      } else if (this.#retryer) {\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        this.#retryer.continueRetry()\n        // Return current promise if we are already fetching\n        return this.#retryer.promise\n      }\n    }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (options) {\n      this.setOptions(options)\n    }\n\n    // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n    if (!this.options.queryFn) {\n      const observer = this.observers.find((x) => x.options.queryFn)\n      if (observer) {\n        this.setOptions(observer.options)\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`,\n        )\n      }\n    }\n\n    const abortController = new AbortController()\n\n    // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n    const addSignalProperty = (object: unknown) => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          this.#abortSignalConsumed = true\n          return abortController.signal\n        },\n      })\n    }\n\n    // Create fetch function\n    const fetchFn = () => {\n      const queryFn = ensureQueryFn(this.options, fetchOptions)\n\n      // Create query function context\n      const createQueryFnContext = (): QueryFunctionContext<TQueryKey> => {\n        const queryFnContext: OmitKeyof<\n          QueryFunctionContext<TQueryKey>,\n          'signal'\n        > = {\n          client: this.#client,\n          queryKey: this.queryKey,\n          meta: this.meta,\n        }\n        addSignalProperty(queryFnContext)\n        return queryFnContext as QueryFunctionContext<TQueryKey>\n      }\n\n      const queryFnContext = createQueryFnContext()\n\n      this.#abortSignalConsumed = false\n      if (this.options.persister) {\n        return this.options.persister(\n          queryFn,\n          queryFnContext,\n          this as unknown as Query,\n        )\n      }\n\n      return queryFn(queryFnContext)\n    }\n\n    // Trigger behavior hook\n    const createFetchContext = (): FetchContext<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey\n    > => {\n      const context: OmitKeyof<\n        FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n        'signal'\n      > = {\n        fetchOptions,\n        options: this.options,\n        queryKey: this.queryKey,\n        client: this.#client,\n        state: this.state,\n        fetchFn,\n      }\n\n      addSignalProperty(context)\n      return context as FetchContext<TQueryFnData, TError, TData, TQueryKey>\n    }\n\n    const context = createFetchContext()\n\n    this.options.behavior?.onFetch(context, this as unknown as Query)\n\n    // Store state in case the current fetch needs to be reverted\n    this.#revertState = this.state\n\n    // Set to fetching state if not already in it\n    if (\n      this.state.fetchStatus === 'idle' ||\n      this.state.fetchMeta !== context.fetchOptions?.meta\n    ) {\n      this.#dispatch({ type: 'fetch', meta: context.fetchOptions?.meta })\n    }\n\n    const onError = (error: TError | { silent?: boolean }) => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.#dispatch({\n          type: 'error',\n          error: error as TError,\n        })\n      }\n\n      if (!isCancelledError(error)) {\n        // Notify cache callback\n        this.#cache.config.onError?.(\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n        this.#cache.config.onSettled?.(\n          this.state.data,\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n      }\n\n      // Schedule query gc after fetching\n      this.scheduleGc()\n    }\n\n    // Try to fetch the data\n    this.#retryer = createRetryer({\n      initialPromise: fetchOptions?.initialPromise as\n        | Promise<TData>\n        | undefined,\n      fn: context.fetchFn as () => Promise<TData>,\n      abort: abortController.abort.bind(abortController),\n      onSuccess: (data) => {\n        if (data === undefined) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.error(\n              `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`,\n            )\n          }\n          onError(new Error(`${this.queryHash} data is undefined`) as any)\n          return\n        }\n\n        try {\n          this.setData(data)\n        } catch (error) {\n          onError(error as TError)\n          return\n        }\n\n        // Notify cache callback\n        this.#cache.config.onSuccess?.(data, this as Query<any, any, any, any>)\n        this.#cache.config.onSettled?.(\n          data,\n          this.state.error as any,\n          this as Query<any, any, any, any>,\n        )\n\n        // Schedule query gc after fetching\n        this.scheduleGc()\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: 'failed', failureCount, error })\n      },\n      onPause: () => {\n        this.#dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.#dispatch({ type: 'continue' })\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n      canRun: () => true,\n    })\n\n    return this.#retryer.start()\n  }\n\n  #dispatch(action: Action<TData, TError>): void {\n    const reducer = (\n      state: QueryState<TData, TError>,\n    ): QueryState<TData, TError> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            fetchStatus: 'paused',\n          }\n        case 'continue':\n          return {\n            ...state,\n            fetchStatus: 'fetching',\n          }\n        case 'fetch':\n          return {\n            ...state,\n            ...fetchState(state.data, this.options),\n            fetchMeta: action.meta ?? null,\n          }\n        case 'success':\n          // If fetching ends successfully, we don't need revertState as a fallback anymore.\n          this.#revertState = undefined\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0,\n              fetchFailureReason: null,\n            }),\n          }\n        case 'error':\n          const error = action.error\n\n          if (isCancelledError(error) && error.revert && this.#revertState) {\n            return { ...this.#revertState, fetchStatus: 'idle' }\n          }\n\n          return {\n            ...state,\n            error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: 'idle',\n            status: 'error',\n          }\n        case 'invalidate':\n          return {\n            ...state,\n            isInvalidated: true,\n          }\n        case 'setState':\n          return {\n            ...state,\n            ...action.state,\n          }\n      }\n    }\n\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onQueryUpdate()\n      })\n\n      this.#cache.notify({ query: this, type: 'updated', action })\n    })\n  }\n}\n\nexport function fetchState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  data: TData | undefined,\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n) {\n  return {\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchStatus: canFetch(options.networkMode) ? 'fetching' : 'paused',\n    ...(data === undefined &&\n      ({\n        error: null,\n        status: 'pending',\n      } as const)),\n  } as const\n}\n\nfunction getDefaultState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): QueryState<TData, TError> {\n  const data =\n    typeof options.initialData === 'function'\n      ? (options.initialData as InitialDataFunction<TData>)()\n      : options.initialData\n\n  const hasData = data !== undefined\n\n  const initialDataUpdatedAt = hasData\n    ? typeof options.initialDataUpdatedAt === 'function'\n      ? (options.initialDataUpdatedAt as () => number | undefined)()\n      : options.initialDataUpdatedAt\n    : 0\n\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? (initialDataUpdatedAt ?? Date.now()) : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'pending',\n    fetchStatus: 'idle',\n  }\n}\n"],"names":["queryFnContext","context"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7913, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40tanstack/query-core/src/queryCache.ts"],"sourcesContent":["import { hashQueryKeyByOptions, matchQuery } from './utils'\nimport { Query } from './query'\nimport { notifyManager } from './notifyManager'\nimport { Subscribable } from './subscribable'\nimport type { QueryFilters } from './utils'\nimport type { Action, QueryState } from './query'\nimport type {\n  DefaultError,\n  NotifyEvent,\n  QueryKey,\n  QueryOptions,\n  WithRequired,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport type { QueryObserver } from './queryObserver'\n\n// TYPES\n\ninterface QueryCacheConfig {\n  onError?: (\n    error: DefaultError,\n    query: Query<unknown, unknown, unknown>,\n  ) => void\n  onSuccess?: (data: unknown, query: Query<unknown, unknown, unknown>) => void\n  onSettled?: (\n    data: unknown | undefined,\n    error: DefaultError | null,\n    query: Query<unknown, unknown, unknown>,\n  ) => void\n}\n\ninterface NotifyEventQueryAdded extends NotifyEvent {\n  type: 'added'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryRemoved extends NotifyEvent {\n  type: 'removed'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryUpdated extends NotifyEvent {\n  type: 'updated'\n  query: Query<any, any, any, any>\n  action: Action<any, any>\n}\n\ninterface NotifyEventQueryObserverAdded extends NotifyEvent {\n  type: 'observerAdded'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverRemoved extends NotifyEvent {\n  type: 'observerRemoved'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverResultsUpdated extends NotifyEvent {\n  type: 'observerResultsUpdated'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverOptionsUpdated extends NotifyEvent {\n  type: 'observerOptionsUpdated'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\nexport type QueryCacheNotifyEvent =\n  | NotifyEventQueryAdded\n  | NotifyEventQueryRemoved\n  | NotifyEventQueryUpdated\n  | NotifyEventQueryObserverAdded\n  | NotifyEventQueryObserverRemoved\n  | NotifyEventQueryObserverResultsUpdated\n  | NotifyEventQueryObserverOptionsUpdated\n\ntype QueryCacheListener = (event: QueryCacheNotifyEvent) => void\n\nexport interface QueryStore {\n  has: (queryHash: string) => boolean\n  set: (queryHash: string, query: Query) => void\n  get: (queryHash: string) => Query | undefined\n  delete: (queryHash: string) => void\n  values: () => IterableIterator<Query>\n}\n\n// CLASS\n\nexport class QueryCache extends Subscribable<QueryCacheListener> {\n  #queries: QueryStore\n\n  constructor(public config: QueryCacheConfig = {}) {\n    super()\n    this.#queries = new Map<string, Query>()\n  }\n\n  build<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    client: QueryClient,\n    options: WithRequired<\n      QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey'\n    >,\n    state?: QueryState<TData, TError>,\n  ): Query<TQueryFnData, TError, TData, TQueryKey> {\n    const queryKey = options.queryKey\n    const queryHash =\n      options.queryHash ?? hashQueryKeyByOptions(queryKey, options)\n    let query = this.get<TQueryFnData, TError, TData, TQueryKey>(queryHash)\n\n    if (!query) {\n      query = new Query({\n        client,\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey),\n      })\n      this.add(query)\n    }\n\n    return query\n  }\n\n  add(query: Query<any, any, any, any>): void {\n    if (!this.#queries.has(query.queryHash)) {\n      this.#queries.set(query.queryHash, query)\n\n      this.notify({\n        type: 'added',\n        query,\n      })\n    }\n  }\n\n  remove(query: Query<any, any, any, any>): void {\n    const queryInMap = this.#queries.get(query.queryHash)\n\n    if (queryInMap) {\n      query.destroy()\n\n      if (queryInMap === query) {\n        this.#queries.delete(query.queryHash)\n      }\n\n      this.notify({ type: 'removed', query })\n    }\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        this.remove(query)\n      })\n    })\n  }\n\n  get<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryHash: string,\n  ): Query<TQueryFnData, TError, TData, TQueryKey> | undefined {\n    return this.#queries.get(queryHash) as\n      | Query<TQueryFnData, TError, TData, TQueryKey>\n      | undefined\n  }\n\n  getAll(): Array<Query> {\n    return [...this.#queries.values()]\n  }\n\n  find<TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData>(\n    filters: WithRequired<QueryFilters, 'queryKey'>,\n  ): Query<TQueryFnData, TError, TData> | undefined {\n    const defaultedFilters = { exact: true, ...filters }\n\n    return this.getAll().find((query) =>\n      matchQuery(defaultedFilters, query),\n    ) as Query<TQueryFnData, TError, TData> | undefined\n  }\n\n  findAll(filters: QueryFilters<any> = {}): Array<Query> {\n    const queries = this.getAll()\n    return Object.keys(filters).length > 0\n      ? queries.filter((query) => matchQuery(filters, query))\n      : queries\n  }\n\n  notify(event: QueryCacheNotifyEvent): void {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event)\n      })\n    })\n  }\n\n  onFocus(): void {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onFocus()\n      })\n    })\n  }\n\n  onOnline(): void {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onOnline()\n      })\n    })\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8027, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40tanstack/query-core/src/mutation.ts"],"sourcesContent":["import { notifyManager } from './notifyManager'\nimport { Removable } from './removable'\nimport { createRetryer } from './retryer'\nimport type {\n  DefaultError,\n  MutationMeta,\n  MutationOptions,\n  MutationStatus,\n} from './types'\nimport type { MutationCache } from './mutationCache'\nimport type { MutationObserver } from './mutationObserver'\nimport type { Retryer } from './retryer'\n\n// TYPES\n\ninterface MutationConfig<TData, TError, TVariables, TContext> {\n  mutationId: number\n  mutationCache: MutationCache\n  options: MutationOptions<TData, TError, TVariables, TContext>\n  state?: MutationState<TData, TError, TVariables, TContext>\n}\n\nexport interface MutationState<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = unknown,\n  TContext = unknown,\n> {\n  context: TContext | undefined\n  data: TData | undefined\n  error: TError | null\n  failureCount: number\n  failureReason: TError | null\n  isPaused: boolean\n  status: MutationStatus\n  variables: TVariables | undefined\n  submittedAt: number\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError | null\n}\n\ninterface PendingAction<TVariables, TContext> {\n  type: 'pending'\n  isPaused: boolean\n  variables?: TVariables\n  context?: TContext\n}\n\ninterface SuccessAction<TData> {\n  type: 'success'\n  data: TData\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\nexport type Action<TData, TError, TVariables, TContext> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | PendingAction<TVariables, TContext>\n  | PauseAction\n  | SuccessAction<TData>\n\n// CLASS\n\nexport class Mutation<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = unknown,\n  TContext = unknown,\n> extends Removable {\n  state: MutationState<TData, TError, TVariables, TContext>\n  options!: MutationOptions<TData, TError, TVariables, TContext>\n  readonly mutationId: number\n\n  #observers: Array<MutationObserver<TData, TError, TVariables, TContext>>\n  #mutationCache: MutationCache\n  #retryer?: Retryer<TData>\n\n  constructor(config: MutationConfig<TData, TError, TVariables, TContext>) {\n    super()\n\n    this.mutationId = config.mutationId\n    this.#mutationCache = config.mutationCache\n    this.#observers = []\n    this.state = config.state || getDefaultState()\n\n    this.setOptions(config.options)\n    this.scheduleGc()\n  }\n\n  setOptions(\n    options: MutationOptions<TData, TError, TVariables, TContext>,\n  ): void {\n    this.options = options\n\n    this.updateGcTime(this.options.gcTime)\n  }\n\n  get meta(): MutationMeta | undefined {\n    return this.options.meta\n  }\n\n  addObserver(observer: MutationObserver<any, any, any, any>): void {\n    if (!this.#observers.includes(observer)) {\n      this.#observers.push(observer)\n\n      // Stop the mutation from being garbage collected\n      this.clearGcTimeout()\n\n      this.#mutationCache.notify({\n        type: 'observerAdded',\n        mutation: this,\n        observer,\n      })\n    }\n  }\n\n  removeObserver(observer: MutationObserver<any, any, any, any>): void {\n    this.#observers = this.#observers.filter((x) => x !== observer)\n\n    this.scheduleGc()\n\n    this.#mutationCache.notify({\n      type: 'observerRemoved',\n      mutation: this,\n      observer,\n    })\n  }\n\n  protected optionalRemove() {\n    if (!this.#observers.length) {\n      if (this.state.status === 'pending') {\n        this.scheduleGc()\n      } else {\n        this.#mutationCache.remove(this)\n      }\n    }\n  }\n\n  continue(): Promise<unknown> {\n    return (\n      this.#retryer?.continue() ??\n      // continuing a mutation assumes that variables are set, mutation must have been dehydrated before\n      this.execute(this.state.variables!)\n    )\n  }\n\n  async execute(variables: TVariables): Promise<TData> {\n    const onContinue = () => {\n      this.#dispatch({ type: 'continue' })\n    }\n\n    this.#retryer = createRetryer({\n      fn: () => {\n        if (!this.options.mutationFn) {\n          return Promise.reject(new Error('No mutationFn found'))\n        }\n        return this.options.mutationFn(variables)\n      },\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: 'failed', failureCount, error })\n      },\n      onPause: () => {\n        this.#dispatch({ type: 'pause' })\n      },\n      onContinue,\n      retry: this.options.retry ?? 0,\n      retryDelay: this.options.retryDelay,\n      networkMode: this.options.networkMode,\n      canRun: () => this.#mutationCache.canRun(this),\n    })\n\n    const restored = this.state.status === 'pending'\n    const isPaused = !this.#retryer.canStart()\n\n    try {\n      if (restored) {\n        // Dispatch continue action to unpause restored mutation\n        onContinue()\n      } else {\n        this.#dispatch({ type: 'pending', variables, isPaused })\n        // Notify cache callback\n        await this.#mutationCache.config.onMutate?.(\n          variables,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n        const context = await this.options.onMutate?.(variables)\n        if (context !== this.state.context) {\n          this.#dispatch({\n            type: 'pending',\n            context,\n            variables,\n            isPaused,\n          })\n        }\n      }\n      const data = await this.#retryer.start()\n\n      // Notify cache callback\n      await this.#mutationCache.config.onSuccess?.(\n        data,\n        variables,\n        this.state.context,\n        this as Mutation<unknown, unknown, unknown, unknown>,\n      )\n\n      await this.options.onSuccess?.(data, variables, this.state.context!)\n\n      // Notify cache callback\n      await this.#mutationCache.config.onSettled?.(\n        data,\n        null,\n        this.state.variables,\n        this.state.context,\n        this as Mutation<unknown, unknown, unknown, unknown>,\n      )\n\n      await this.options.onSettled?.(data, null, variables, this.state.context)\n\n      this.#dispatch({ type: 'success', data })\n      return data\n    } catch (error) {\n      try {\n        // Notify cache callback\n        await this.#mutationCache.config.onError?.(\n          error as any,\n          variables,\n          this.state.context,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n\n        await this.options.onError?.(\n          error as TError,\n          variables,\n          this.state.context,\n        )\n\n        // Notify cache callback\n        await this.#mutationCache.config.onSettled?.(\n          undefined,\n          error as any,\n          this.state.variables,\n          this.state.context,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n\n        await this.options.onSettled?.(\n          undefined,\n          error as TError,\n          variables,\n          this.state.context,\n        )\n        throw error\n      } finally {\n        this.#dispatch({ type: 'error', error: error as TError })\n      }\n    } finally {\n      this.#mutationCache.runNext(this)\n    }\n  }\n\n  #dispatch(action: Action<TData, TError, TVariables, TContext>): void {\n    const reducer = (\n      state: MutationState<TData, TError, TVariables, TContext>,\n    ): MutationState<TData, TError, TVariables, TContext> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            failureCount: action.failureCount,\n            failureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            isPaused: true,\n          }\n        case 'continue':\n          return {\n            ...state,\n            isPaused: false,\n          }\n        case 'pending':\n          return {\n            ...state,\n            context: action.context,\n            data: undefined,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            isPaused: action.isPaused,\n            status: 'pending',\n            variables: action.variables,\n            submittedAt: Date.now(),\n          }\n        case 'success':\n          return {\n            ...state,\n            data: action.data,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            status: 'success',\n            isPaused: false,\n          }\n        case 'error':\n          return {\n            ...state,\n            data: undefined,\n            error: action.error,\n            failureCount: state.failureCount + 1,\n            failureReason: action.error,\n            isPaused: false,\n            status: 'error',\n          }\n      }\n    }\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.#observers.forEach((observer) => {\n        observer.onMutationUpdate(action)\n      })\n      this.#mutationCache.notify({\n        mutation: this,\n        type: 'updated',\n        action,\n      })\n    })\n  }\n}\n\nexport function getDefaultState<\n  TData,\n  TError,\n  TVariables,\n  TContext,\n>(): MutationState<TData, TError, TVariables, TContext> {\n  return {\n    context: undefined,\n    data: undefined,\n    error: null,\n    failureCount: 0,\n    failureReason: null,\n    isPaused: false,\n    status: 'idle',\n    variables: undefined,\n    submittedAt: 0,\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8259, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40tanstack/query-core/src/mutationCache.ts"],"sourcesContent":["import { notifyManager } from './notifyManager'\nimport { Mutation } from './mutation'\nimport { matchMutation, noop } from './utils'\nimport { Subscribable } from './subscribable'\nimport type { MutationObserver } from './mutationObserver'\nimport type { DefaultError, MutationOptions, NotifyEvent } from './types'\nimport type { QueryClient } from './queryClient'\nimport type { Action, MutationState } from './mutation'\nimport type { MutationFilters } from './utils'\n\n// TYPES\n\ninterface MutationCacheConfig {\n  onError?: (\n    error: DefaultError,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onSuccess?: (\n    data: unknown,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onMutate?: (\n    variables: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onSettled?: (\n    data: unknown | undefined,\n    error: DefaultError | null,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n}\n\ninterface NotifyEventMutationAdded extends NotifyEvent {\n  type: 'added'\n  mutation: Mutation<any, any, any, any>\n}\ninterface NotifyEventMutationRemoved extends NotifyEvent {\n  type: 'removed'\n  mutation: Mutation<any, any, any, any>\n}\n\ninterface NotifyEventMutationObserverAdded extends NotifyEvent {\n  type: 'observerAdded'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverRemoved extends NotifyEvent {\n  type: 'observerRemoved'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverOptionsUpdated extends NotifyEvent {\n  type: 'observerOptionsUpdated'\n  mutation?: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any, any>\n}\n\ninterface NotifyEventMutationUpdated extends NotifyEvent {\n  type: 'updated'\n  mutation: Mutation<any, any, any, any>\n  action: Action<any, any, any, any>\n}\n\nexport type MutationCacheNotifyEvent =\n  | NotifyEventMutationAdded\n  | NotifyEventMutationRemoved\n  | NotifyEventMutationObserverAdded\n  | NotifyEventMutationObserverRemoved\n  | NotifyEventMutationObserverOptionsUpdated\n  | NotifyEventMutationUpdated\n\ntype MutationCacheListener = (event: MutationCacheNotifyEvent) => void\n\n// CLASS\n\nexport class MutationCache extends Subscribable<MutationCacheListener> {\n  #mutations: Set<Mutation<any, any, any, any>>\n  #scopes: Map<string, Array<Mutation<any, any, any, any>>>\n  #mutationId: number\n\n  constructor(public config: MutationCacheConfig = {}) {\n    super()\n    this.#mutations = new Set()\n    this.#scopes = new Map()\n    this.#mutationId = 0\n  }\n\n  build<TData, TError, TVariables, TContext>(\n    client: QueryClient,\n    options: MutationOptions<TData, TError, TVariables, TContext>,\n    state?: MutationState<TData, TError, TVariables, TContext>,\n  ): Mutation<TData, TError, TVariables, TContext> {\n    const mutation = new Mutation({\n      mutationCache: this,\n      mutationId: ++this.#mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n    })\n\n    this.add(mutation)\n\n    return mutation\n  }\n\n  add(mutation: Mutation<any, any, any, any>): void {\n    this.#mutations.add(mutation)\n    const scope = scopeFor(mutation)\n    if (typeof scope === 'string') {\n      const scopedMutations = this.#scopes.get(scope)\n      if (scopedMutations) {\n        scopedMutations.push(mutation)\n      } else {\n        this.#scopes.set(scope, [mutation])\n      }\n    }\n    this.notify({ type: 'added', mutation })\n  }\n\n  remove(mutation: Mutation<any, any, any, any>): void {\n    if (this.#mutations.delete(mutation)) {\n      const scope = scopeFor(mutation)\n      if (typeof scope === 'string') {\n        const scopedMutations = this.#scopes.get(scope)\n        if (scopedMutations) {\n          if (scopedMutations.length > 1) {\n            const index = scopedMutations.indexOf(mutation)\n            if (index !== -1) {\n              scopedMutations.splice(index, 1)\n            }\n          } else if (scopedMutations[0] === mutation) {\n            this.#scopes.delete(scope)\n          }\n        }\n      }\n    }\n\n    // Currently we notify the removal even if the mutation was already removed.\n    // Consider making this an error or not notifying of the removal depending on the desired semantics.\n    this.notify({ type: 'removed', mutation })\n  }\n\n  canRun(mutation: Mutation<any, any, any, any>): boolean {\n    const scope = scopeFor(mutation)\n    if (typeof scope === 'string') {\n      const mutationsWithSameScope = this.#scopes.get(scope)\n      const firstPendingMutation = mutationsWithSameScope?.find(\n        (m) => m.state.status === 'pending',\n      )\n      // we can run if there is no current pending mutation (start use-case)\n      // or if WE are the first pending mutation (continue use-case)\n      return !firstPendingMutation || firstPendingMutation === mutation\n    } else {\n      // For unscoped mutations there are never any pending mutations in front of the\n      // current mutation\n      return true\n    }\n  }\n\n  runNext(mutation: Mutation<any, any, any, any>): Promise<unknown> {\n    const scope = scopeFor(mutation)\n    if (typeof scope === 'string') {\n      const foundMutation = this.#scopes\n        .get(scope)\n        ?.find((m) => m !== mutation && m.state.isPaused)\n\n      return foundMutation?.continue() ?? Promise.resolve()\n    } else {\n      return Promise.resolve()\n    }\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.#mutations.forEach((mutation) => {\n        this.notify({ type: 'removed', mutation })\n      })\n      this.#mutations.clear()\n      this.#scopes.clear()\n    })\n  }\n\n  getAll(): Array<Mutation> {\n    return Array.from(this.#mutations)\n  }\n\n  find<\n    TData = unknown,\n    TError = DefaultError,\n    TVariables = any,\n    TContext = unknown,\n  >(\n    filters: MutationFilters,\n  ): Mutation<TData, TError, TVariables, TContext> | undefined {\n    const defaultedFilters = { exact: true, ...filters }\n\n    return this.getAll().find((mutation) =>\n      matchMutation(defaultedFilters, mutation),\n    ) as Mutation<TData, TError, TVariables, TContext> | undefined\n  }\n\n  findAll(filters: MutationFilters = {}): Array<Mutation> {\n    return this.getAll().filter((mutation) => matchMutation(filters, mutation))\n  }\n\n  notify(event: MutationCacheNotifyEvent) {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event)\n      })\n    })\n  }\n\n  resumePausedMutations(): Promise<unknown> {\n    const pausedMutations = this.getAll().filter((x) => x.state.isPaused)\n\n    return notifyManager.batch(() =>\n      Promise.all(\n        pausedMutations.map((mutation) => mutation.continue().catch(noop)),\n      ),\n    )\n  }\n}\n\nfunction scopeFor(mutation: Mutation<any, any, any, any>) {\n  return mutation.options.scope?.id\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8399, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40tanstack/query-core/src/infiniteQueryBehavior.ts"],"sourcesContent":["import { addToEnd, addToStart, ensureQueryFn } from './utils'\nimport type { QueryBehavior } from './query'\nimport type {\n  InfiniteData,\n  InfiniteQueryPageParamsOptions,\n  OmitKeyof,\n  QueryFunctionContext,\n  QueryKey,\n} from './types'\n\nexport function infiniteQueryBehavior<TQueryFnData, TError, TData, TPageParam>(\n  pages?: number,\n): QueryBehavior<TQueryFnData, TError, InfiniteData<TData, TPageParam>> {\n  return {\n    onFetch: (context, query) => {\n      const options = context.options as InfiniteQueryPageParamsOptions<TData>\n      const direction = context.fetchOptions?.meta?.fetchMore?.direction\n      const oldPages = context.state.data?.pages || []\n      const oldPageParams = context.state.data?.pageParams || []\n      let result: InfiniteData<unknown> = { pages: [], pageParams: [] }\n      let currentPage = 0\n\n      const fetchFn = async () => {\n        let cancelled = false\n        const addSignalProperty = (object: unknown) => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              if (context.signal.aborted) {\n                cancelled = true\n              } else {\n                context.signal.addEventListener('abort', () => {\n                  cancelled = true\n                })\n              }\n              return context.signal\n            },\n          })\n        }\n\n        const queryFn = ensureQueryFn(context.options, context.fetchOptions)\n\n        // Create function to fetch a page\n        const fetchPage = async (\n          data: InfiniteData<unknown>,\n          param: unknown,\n          previous?: boolean,\n        ): Promise<InfiniteData<unknown>> => {\n          if (cancelled) {\n            return Promise.reject()\n          }\n\n          if (param == null && data.pages.length) {\n            return Promise.resolve(data)\n          }\n\n          const createQueryFnContext = () => {\n            const queryFnContext: OmitKeyof<\n              QueryFunctionContext<QueryKey, unknown>,\n              'signal'\n            > = {\n              client: context.client,\n              queryKey: context.queryKey,\n              pageParam: param,\n              direction: previous ? 'backward' : 'forward',\n              meta: context.options.meta,\n            }\n            addSignalProperty(queryFnContext)\n            return queryFnContext as QueryFunctionContext<QueryKey, unknown>\n          }\n\n          const queryFnContext = createQueryFnContext()\n\n          const page = await queryFn(queryFnContext)\n\n          const { maxPages } = context.options\n          const addTo = previous ? addToStart : addToEnd\n\n          return {\n            pages: addTo(data.pages, page, maxPages),\n            pageParams: addTo(data.pageParams, param, maxPages),\n          }\n        }\n\n        // fetch next / previous page?\n        if (direction && oldPages.length) {\n          const previous = direction === 'backward'\n          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam\n          const oldData = {\n            pages: oldPages,\n            pageParams: oldPageParams,\n          }\n          const param = pageParamFn(options, oldData)\n\n          result = await fetchPage(oldData, param, previous)\n        } else {\n          const remainingPages = pages ?? oldPages.length\n\n          // Fetch all pages\n          do {\n            const param =\n              currentPage === 0\n                ? (oldPageParams[0] ?? options.initialPageParam)\n                : getNextPageParam(options, result)\n            if (currentPage > 0 && param == null) {\n              break\n            }\n            result = await fetchPage(result, param)\n            currentPage++\n          } while (currentPage < remainingPages)\n        }\n\n        return result\n      }\n      if (context.options.persister) {\n        context.fetchFn = () => {\n          return context.options.persister?.(\n            fetchFn as any,\n            {\n              client: context.client,\n              queryKey: context.queryKey,\n              meta: context.options.meta,\n              signal: context.signal,\n            },\n            query,\n          )\n        }\n      } else {\n        context.fetchFn = fetchFn\n      }\n    },\n  }\n}\n\nfunction getNextPageParam(\n  options: InfiniteQueryPageParamsOptions<any>,\n  { pages, pageParams }: InfiniteData<unknown>,\n): unknown | undefined {\n  const lastIndex = pages.length - 1\n  return pages.length > 0\n    ? options.getNextPageParam(\n        pages[lastIndex],\n        pages,\n        pageParams[lastIndex],\n        pageParams,\n      )\n    : undefined\n}\n\nfunction getPreviousPageParam(\n  options: InfiniteQueryPageParamsOptions<any>,\n  { pages, pageParams }: InfiniteData<unknown>,\n): unknown | undefined {\n  return pages.length > 0\n    ? options.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams)\n    : undefined\n}\n\n/**\n * Checks if there is a next page.\n */\nexport function hasNextPage(\n  options: InfiniteQueryPageParamsOptions<any, any>,\n  data?: InfiniteData<unknown>,\n): boolean {\n  if (!data) return false\n  return getNextPageParam(options, data) != null\n}\n\n/**\n * Checks if there is a previous page.\n */\nexport function hasPreviousPage(\n  options: InfiniteQueryPageParamsOptions<any, any>,\n  data?: InfiniteData<unknown>,\n): boolean {\n  if (!data || !options.getPreviousPageParam) return false\n  return getPreviousPageParam(options, data) != null\n}\n"],"names":["queryFnContext"],"mappings":";;;;;;AAAA,SAAS,UAAU,YAAY,qBAAqB;;AAU7C,SAAS,sBACd,KAAA,EACsE;IACtE,OAAO;QACL,SAAS,CAAC,SAAS,UAAU;YAC3B,MAAM,UAAU,QAAQ,OAAA;YACxB,MAAM,YAAY,QAAQ,YAAA,EAAc,MAAM,WAAW;YACzD,MAAM,WAAW,QAAQ,KAAA,CAAM,IAAA,EAAM,SAAS,CAAC,CAAA;YAC/C,MAAM,gBAAgB,QAAQ,KAAA,CAAM,IAAA,EAAM,cAAc,CAAC,CAAA;YACzD,IAAI,SAAgC;gBAAE,OAAO,CAAC,CAAA;gBAAG,YAAY,CAAC,CAAA;YAAE;YAChE,IAAI,cAAc;YAElB,MAAM,UAAU,YAAY;gBAC1B,IAAI,YAAY;gBAChB,MAAM,oBAAoB,CAAC,WAAoB;oBAC7C,OAAO,cAAA,CAAe,QAAQ,UAAU;wBACtC,YAAY;wBACZ,KAAK,MAAM;4BACT,IAAI,QAAQ,MAAA,CAAO,OAAA,EAAS;gCAC1B,YAAY;4BACd,OAAO;gCACL,QAAQ,MAAA,CAAO,gBAAA,CAAiB,SAAS,MAAM;oCAC7C,YAAY;gCACd,CAAC;4BACH;4BACA,OAAO,QAAQ,MAAA;wBACjB;oBACF,CAAC;gBACH;gBAEA,MAAM,cAAU,2LAAA,EAAc,QAAQ,OAAA,EAAS,QAAQ,YAAY;gBAGnE,MAAM,YAAY,OAChB,MACA,OACA,aACmC;oBACnC,IAAI,WAAW;wBACb,OAAO,QAAQ,MAAA,CAAO;oBACxB;oBAEA,IAAI,SAAS,QAAQ,KAAK,KAAA,CAAM,MAAA,EAAQ;wBACtC,OAAO,QAAQ,OAAA,CAAQ,IAAI;oBAC7B;oBAEA,MAAM,uBAAuB,MAAM;wBACjC,MAAMA,kBAGF;4BACF,QAAQ,QAAQ,MAAA;4BAChB,UAAU,QAAQ,QAAA;4BAClB,WAAW;4BACX,WAAW,WAAW,aAAa;4BACnC,MAAM,QAAQ,OAAA,CAAQ,IAAA;wBACxB;wBACA,kBAAkBA,eAAc;wBAChC,OAAOA;oBACT;oBAEA,MAAM,iBAAiB,qBAAqB;oBAE5C,MAAM,OAAO,MAAM,QAAQ,cAAc;oBAEzC,MAAM,EAAE,QAAA,CAAS,CAAA,GAAI,QAAQ,OAAA;oBAC7B,MAAM,QAAQ,sLAAW,aAAA,6KAAa,YAAA;oBAEtC,OAAO;wBACL,OAAO,MAAM,KAAK,KAAA,EAAO,MAAM,QAAQ;wBACvC,YAAY,MAAM,KAAK,UAAA,EAAY,OAAO,QAAQ;oBACpD;gBACF;gBAGA,IAAI,aAAa,SAAS,MAAA,EAAQ;oBAChC,MAAM,WAAW,cAAc;oBAC/B,MAAM,cAAc,WAAW,uBAAuB;oBACtD,MAAM,UAAU;wBACd,OAAO;wBACP,YAAY;oBACd;oBACA,MAAM,QAAQ,YAAY,SAAS,OAAO;oBAE1C,SAAS,MAAM,UAAU,SAAS,OAAO,QAAQ;gBACnD,OAAO;oBACL,MAAM,iBAAiB,SAAS,SAAS,MAAA;oBAGzC,GAAG;wBACD,MAAM,QACJ,gBAAgB,IACX,aAAA,CAAc,CAAC,CAAA,IAAK,QAAQ,gBAAA,GAC7B,iBAAiB,SAAS,MAAM;wBACtC,IAAI,cAAc,KAAK,SAAS,MAAM;4BACpC;wBACF;wBACA,SAAS,MAAM,UAAU,QAAQ,KAAK;wBACtC;oBACF,QAAS,cAAc,eAAA;gBACzB;gBAEA,OAAO;YACT;YACA,IAAI,QAAQ,OAAA,CAAQ,SAAA,EAAW;gBAC7B,QAAQ,OAAA,GAAU,MAAM;oBACtB,OAAO,QAAQ,OAAA,CAAQ,SAAA,GACrB,SACA;wBACE,QAAQ,QAAQ,MAAA;wBAChB,UAAU,QAAQ,QAAA;wBAClB,MAAM,QAAQ,OAAA,CAAQ,IAAA;wBACtB,QAAQ,QAAQ,MAAA;oBAClB,GACA;gBAEJ;YACF,OAAO;gBACL,QAAQ,OAAA,GAAU;YACpB;QACF;IACF;AACF;AAEA,SAAS,iBACP,OAAA,EACA,EAAE,KAAA,EAAO,UAAA,CAAW,CAAA,EACC;IACrB,MAAM,YAAY,MAAM,MAAA,GAAS;IACjC,OAAO,MAAM,MAAA,GAAS,IAClB,QAAQ,gBAAA,CACN,KAAA,CAAM,SAAS,CAAA,EACf,OACA,UAAA,CAAW,SAAS,CAAA,EACpB,cAEF,KAAA;AACN;AAEA,SAAS,qBACP,OAAA,EACA,EAAE,KAAA,EAAO,UAAA,CAAW,CAAA,EACC;IACrB,OAAO,MAAM,MAAA,GAAS,IAClB,QAAQ,oBAAA,GAAuB,KAAA,CAAM,CAAC,CAAA,EAAG,OAAO,UAAA,CAAW,CAAC,CAAA,EAAG,UAAU,IACzE,KAAA;AACN;AAKO,SAAS,YACd,OAAA,EACA,IAAA,EACS;IACT,IAAI,CAAC,KAAM,CAAA,OAAO;IAClB,OAAO,iBAAiB,SAAS,IAAI,KAAK;AAC5C;AAKO,SAAS,gBACd,OAAA,EACA,IAAA,EACS;IACT,IAAI,CAAC,QAAQ,CAAC,QAAQ,oBAAA,CAAsB,CAAA,OAAO;IACnD,OAAO,qBAAqB,SAAS,IAAI,KAAK;AAChD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8524, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40tanstack/query-core/src/queryClient.ts"],"sourcesContent":["import {\n  functionalUpdate,\n  hashKey,\n  hashQueryKeyByOptions,\n  noop,\n  partialMatchKey,\n  resolveStaleTime,\n  skipToken,\n} from './utils'\nimport { QueryCache } from './queryCache'\nimport { MutationCache } from './mutationCache'\nimport { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { notifyManager } from './notifyManager'\nimport { infiniteQueryBehavior } from './infiniteQueryBehavior'\nimport type {\n  CancelOptions,\n  DefaultError,\n  DefaultOptions,\n  DefaultedQueryObserverOptions,\n  EnsureInfiniteQueryDataOptions,\n  EnsureQueryDataOptions,\n  FetchInfiniteQueryOptions,\n  FetchQueryOptions,\n  InferDataFromTag,\n  InferErrorFromTag,\n  InfiniteData,\n  InvalidateOptions,\n  InvalidateQueryFilters,\n  MutationKey,\n  MutationObserverOptions,\n  MutationOptions,\n  NoInfer,\n  OmitKeyof,\n  QueryClientConfig,\n  QueryKey,\n  QueryObserverOptions,\n  QueryOptions,\n  RefetchOptions,\n  RefetchQueryFilters,\n  ResetOptions,\n  SetDataOptions,\n} from './types'\nimport type { QueryState } from './query'\nimport type { MutationFilters, QueryFilters, Updater } from './utils'\n\n// TYPES\n\ninterface QueryDefaults {\n  queryKey: QueryKey\n  defaultOptions: OmitKeyof<QueryOptions<any, any, any>, 'queryKey'>\n}\n\ninterface MutationDefaults {\n  mutationKey: MutationKey\n  defaultOptions: MutationOptions<any, any, any, any>\n}\n\n// CLASS\n\nexport class QueryClient {\n  #queryCache: QueryCache\n  #mutationCache: MutationCache\n  #defaultOptions: DefaultOptions\n  #queryDefaults: Map<string, QueryDefaults>\n  #mutationDefaults: Map<string, MutationDefaults>\n  #mountCount: number\n  #unsubscribeFocus?: () => void\n  #unsubscribeOnline?: () => void\n\n  constructor(config: QueryClientConfig = {}) {\n    this.#queryCache = config.queryCache || new QueryCache()\n    this.#mutationCache = config.mutationCache || new MutationCache()\n    this.#defaultOptions = config.defaultOptions || {}\n    this.#queryDefaults = new Map()\n    this.#mutationDefaults = new Map()\n    this.#mountCount = 0\n  }\n\n  mount(): void {\n    this.#mountCount++\n    if (this.#mountCount !== 1) return\n\n    this.#unsubscribeFocus = focusManager.subscribe(async (focused) => {\n      if (focused) {\n        await this.resumePausedMutations()\n        this.#queryCache.onFocus()\n      }\n    })\n    this.#unsubscribeOnline = onlineManager.subscribe(async (online) => {\n      if (online) {\n        await this.resumePausedMutations()\n        this.#queryCache.onOnline()\n      }\n    })\n  }\n\n  unmount(): void {\n    this.#mountCount--\n    if (this.#mountCount !== 0) return\n\n    this.#unsubscribeFocus?.()\n    this.#unsubscribeFocus = undefined\n\n    this.#unsubscribeOnline?.()\n    this.#unsubscribeOnline = undefined\n  }\n\n  isFetching<TQueryFilters extends QueryFilters<any> = QueryFilters>(\n    filters?: TQueryFilters,\n  ): number {\n    return this.#queryCache.findAll({ ...filters, fetchStatus: 'fetching' })\n      .length\n  }\n\n  isMutating<\n    TMutationFilters extends MutationFilters<any, any> = MutationFilters,\n  >(filters?: TMutationFilters): number {\n    return this.#mutationCache.findAll({ ...filters, status: 'pending' }).length\n  }\n\n  /**\n   * Imperative (non-reactive) way to retrieve data for a QueryKey.\n   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.\n   *\n   * Hint: Do not use this function inside a component, because it won't receive updates.\n   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.\n   */\n  getQueryData<\n    TQueryFnData = unknown,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n  >(queryKey: TTaggedQueryKey): TInferredQueryFnData | undefined {\n    const options = this.defaultQueryOptions({ queryKey })\n\n    return this.#queryCache.get<TInferredQueryFnData>(options.queryHash)?.state\n      .data\n  }\n\n  ensureQueryData<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: EnsureQueryDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData> {\n    const defaultedOptions = this.defaultQueryOptions(options)\n    const query = this.#queryCache.build(this, defaultedOptions)\n    const cachedData = query.state.data\n\n    if (cachedData === undefined) {\n      return this.fetchQuery(options)\n    }\n\n    if (\n      options.revalidateIfStale &&\n      query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query))\n    ) {\n      void this.prefetchQuery(defaultedOptions)\n    }\n\n    return Promise.resolve(cachedData)\n  }\n\n  getQueriesData<\n    TQueryFnData = unknown,\n    TQueryFilters extends QueryFilters<any> = QueryFilters,\n  >(filters: TQueryFilters): Array<[QueryKey, TQueryFnData | undefined]> {\n    return this.#queryCache.findAll(filters).map(({ queryKey, state }) => {\n      const data = state.data as TQueryFnData | undefined\n      return [queryKey, data]\n    })\n  }\n\n  setQueryData<\n    TQueryFnData = unknown,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n  >(\n    queryKey: TTaggedQueryKey,\n    updater: Updater<\n      NoInfer<TInferredQueryFnData> | undefined,\n      NoInfer<TInferredQueryFnData> | undefined\n    >,\n    options?: SetDataOptions,\n  ): NoInfer<TInferredQueryFnData> | undefined {\n    const defaultedOptions = this.defaultQueryOptions<\n      any,\n      any,\n      unknown,\n      any,\n      QueryKey\n    >({ queryKey })\n\n    const query = this.#queryCache.get<TInferredQueryFnData>(\n      defaultedOptions.queryHash,\n    )\n    const prevData = query?.state.data\n    const data = functionalUpdate(updater, prevData)\n\n    if (data === undefined) {\n      return undefined\n    }\n\n    return this.#queryCache\n      .build(this, defaultedOptions)\n      .setData(data, { ...options, manual: true })\n  }\n\n  setQueriesData<\n    TQueryFnData,\n    TQueryFilters extends QueryFilters<any> = QueryFilters,\n  >(\n    filters: TQueryFilters,\n    updater: Updater<\n      NoInfer<TQueryFnData> | undefined,\n      NoInfer<TQueryFnData> | undefined\n    >,\n    options?: SetDataOptions,\n  ): Array<[QueryKey, TQueryFnData | undefined]> {\n    return notifyManager.batch(() =>\n      this.#queryCache\n        .findAll(filters)\n        .map(({ queryKey }) => [\n          queryKey,\n          this.setQueryData<TQueryFnData>(queryKey, updater, options),\n        ]),\n    )\n  }\n\n  getQueryState<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n    TInferredError = InferErrorFromTag<TError, TTaggedQueryKey>,\n  >(\n    queryKey: TTaggedQueryKey,\n  ): QueryState<TInferredQueryFnData, TInferredError> | undefined {\n    const options = this.defaultQueryOptions({ queryKey })\n    return this.#queryCache.get<TInferredQueryFnData, TInferredError>(\n      options.queryHash,\n    )?.state\n  }\n\n  removeQueries<TTaggedQueryKey extends QueryKey = QueryKey>(\n    filters?: QueryFilters<TTaggedQueryKey>,\n  ): void {\n    const queryCache = this.#queryCache\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        queryCache.remove(query)\n      })\n    })\n  }\n\n  resetQueries<TTaggedQueryKey extends QueryKey = QueryKey>(\n    filters?: QueryFilters<TTaggedQueryKey>,\n    options?: ResetOptions,\n  ): Promise<void> {\n    const queryCache = this.#queryCache\n\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        query.reset()\n      })\n      return this.refetchQueries(\n        {\n          type: 'active',\n          ...filters,\n        },\n        options,\n      )\n    })\n  }\n\n  cancelQueries<TTaggedQueryKey extends QueryKey = QueryKey>(\n    filters?: QueryFilters<TTaggedQueryKey>,\n    cancelOptions: CancelOptions = {},\n  ): Promise<void> {\n    const defaultedCancelOptions = { revert: true, ...cancelOptions }\n\n    const promises = notifyManager.batch(() =>\n      this.#queryCache\n        .findAll(filters)\n        .map((query) => query.cancel(defaultedCancelOptions)),\n    )\n\n    return Promise.all(promises).then(noop).catch(noop)\n  }\n\n  invalidateQueries<TTaggedQueryKey extends QueryKey = QueryKey>(\n    filters?: InvalidateQueryFilters<TTaggedQueryKey>,\n    options: InvalidateOptions = {},\n  ): Promise<void> {\n    return notifyManager.batch(() => {\n      this.#queryCache.findAll(filters).forEach((query) => {\n        query.invalidate()\n      })\n\n      if (filters?.refetchType === 'none') {\n        return Promise.resolve()\n      }\n      return this.refetchQueries(\n        {\n          ...filters,\n          type: filters?.refetchType ?? filters?.type ?? 'active',\n        },\n        options,\n      )\n    })\n  }\n\n  refetchQueries<TTaggedQueryKey extends QueryKey = QueryKey>(\n    filters?: RefetchQueryFilters<TTaggedQueryKey>,\n    options: RefetchOptions = {},\n  ): Promise<void> {\n    const fetchOptions = {\n      ...options,\n      cancelRefetch: options.cancelRefetch ?? true,\n    }\n    const promises = notifyManager.batch(() =>\n      this.#queryCache\n        .findAll(filters)\n        .filter((query) => !query.isDisabled() && !query.isStatic())\n        .map((query) => {\n          let promise = query.fetch(undefined, fetchOptions)\n          if (!fetchOptions.throwOnError) {\n            promise = promise.catch(noop)\n          }\n          return query.state.fetchStatus === 'paused'\n            ? Promise.resolve()\n            : promise\n        }),\n    )\n\n    return Promise.all(promises).then(noop)\n  }\n\n  fetchQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = never,\n  >(\n    options: FetchQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<TData> {\n    const defaultedOptions = this.defaultQueryOptions(options)\n\n    // https://github.com/tannerlinsley/react-query/issues/652\n    if (defaultedOptions.retry === undefined) {\n      defaultedOptions.retry = false\n    }\n\n    const query = this.#queryCache.build(this, defaultedOptions)\n\n    return query.isStaleByTime(\n      resolveStaleTime(defaultedOptions.staleTime, query),\n    )\n      ? query.fetch(defaultedOptions)\n      : Promise.resolve(query.state.data as TData)\n  }\n\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void> {\n    return this.fetchQuery(options).then(noop).catch(noop)\n  }\n\n  fetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: FetchInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<InfiniteData<TData, TPageParam>> {\n    options.behavior = infiniteQueryBehavior<\n      TQueryFnData,\n      TError,\n      TData,\n      TPageParam\n    >(options.pages)\n    return this.fetchQuery(options as any)\n  }\n\n  prefetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: FetchInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<void> {\n    return this.fetchInfiniteQuery(options).then(noop).catch(noop)\n  }\n\n  ensureInfiniteQueryData<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: EnsureInfiniteQueryDataOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<InfiniteData<TData, TPageParam>> {\n    options.behavior = infiniteQueryBehavior<\n      TQueryFnData,\n      TError,\n      TData,\n      TPageParam\n    >(options.pages)\n\n    return this.ensureQueryData(options as any)\n  }\n\n  resumePausedMutations(): Promise<unknown> {\n    if (onlineManager.isOnline()) {\n      return this.#mutationCache.resumePausedMutations()\n    }\n    return Promise.resolve()\n  }\n\n  getQueryCache(): QueryCache {\n    return this.#queryCache\n  }\n\n  getMutationCache(): MutationCache {\n    return this.#mutationCache\n  }\n\n  getDefaultOptions(): DefaultOptions {\n    return this.#defaultOptions\n  }\n\n  setDefaultOptions(options: DefaultOptions): void {\n    this.#defaultOptions = options\n  }\n\n  setQueryDefaults<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryData = TQueryFnData,\n  >(\n    queryKey: QueryKey,\n    options: Partial<\n      OmitKeyof<\n        QueryObserverOptions<TQueryFnData, TError, TData, TQueryData>,\n        'queryKey'\n      >\n    >,\n  ): void {\n    this.#queryDefaults.set(hashKey(queryKey), {\n      queryKey,\n      defaultOptions: options,\n    })\n  }\n\n  getQueryDefaults(\n    queryKey: QueryKey,\n  ): OmitKeyof<QueryObserverOptions<any, any, any, any, any>, 'queryKey'> {\n    const defaults = [...this.#queryDefaults.values()]\n\n    const result: OmitKeyof<\n      QueryObserverOptions<any, any, any, any, any>,\n      'queryKey'\n    > = {}\n\n    defaults.forEach((queryDefault) => {\n      if (partialMatchKey(queryKey, queryDefault.queryKey)) {\n        Object.assign(result, queryDefault.defaultOptions)\n      }\n    })\n    return result\n  }\n\n  setMutationDefaults<\n    TData = unknown,\n    TError = DefaultError,\n    TVariables = void,\n    TContext = unknown,\n  >(\n    mutationKey: MutationKey,\n    options: OmitKeyof<\n      MutationObserverOptions<TData, TError, TVariables, TContext>,\n      'mutationKey'\n    >,\n  ): void {\n    this.#mutationDefaults.set(hashKey(mutationKey), {\n      mutationKey,\n      defaultOptions: options,\n    })\n  }\n\n  getMutationDefaults(\n    mutationKey: MutationKey,\n  ): OmitKeyof<MutationObserverOptions<any, any, any, any>, 'mutationKey'> {\n    const defaults = [...this.#mutationDefaults.values()]\n\n    const result: OmitKeyof<\n      MutationObserverOptions<any, any, any, any>,\n      'mutationKey'\n    > = {}\n\n    defaults.forEach((queryDefault) => {\n      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {\n        Object.assign(result, queryDefault.defaultOptions)\n      }\n    })\n\n    return result\n  }\n\n  defaultQueryOptions<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = never,\n  >(\n    options:\n      | QueryObserverOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryData,\n          TQueryKey,\n          TPageParam\n        >\n      | DefaultedQueryObserverOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryData,\n          TQueryKey\n        >,\n  ): DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  > {\n    if (options._defaulted) {\n      return options as DefaultedQueryObserverOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryData,\n        TQueryKey\n      >\n    }\n\n    const defaultedOptions = {\n      ...this.#defaultOptions.queries,\n      ...this.getQueryDefaults(options.queryKey),\n      ...options,\n      _defaulted: true,\n    }\n\n    if (!defaultedOptions.queryHash) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(\n        defaultedOptions.queryKey,\n        defaultedOptions,\n      )\n    }\n\n    // dependent default values\n    if (defaultedOptions.refetchOnReconnect === undefined) {\n      defaultedOptions.refetchOnReconnect =\n        defaultedOptions.networkMode !== 'always'\n    }\n    if (defaultedOptions.throwOnError === undefined) {\n      defaultedOptions.throwOnError = !!defaultedOptions.suspense\n    }\n\n    if (!defaultedOptions.networkMode && defaultedOptions.persister) {\n      defaultedOptions.networkMode = 'offlineFirst'\n    }\n\n    if (defaultedOptions.queryFn === skipToken) {\n      defaultedOptions.enabled = false\n    }\n\n    return defaultedOptions as DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >\n  }\n\n  defaultMutationOptions<T extends MutationOptions<any, any, any, any>>(\n    options?: T,\n  ): T {\n    if (options?._defaulted) {\n      return options\n    }\n    return {\n      ...this.#defaultOptions.mutations,\n      ...(options?.mutationKey &&\n        this.getMutationDefaults(options.mutationKey)),\n      ...options,\n      _defaulted: true,\n    } as T\n  }\n\n  clear(): void {\n    this.#queryCache.clear()\n    this.#mutationCache.clear()\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8838, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40tanstack/react-query/src/infiniteQueryOptions.ts"],"sourcesContent":["import type {\n  DataTag,\n  DefaultError,\n  InfiniteData,\n  InitialDataFunction,\n  NonUndefinedGuard,\n  OmitKeyof,\n  QueryKey,\n  SkipToken,\n} from '@tanstack/query-core'\nimport type { UseInfiniteQueryOptions } from './types'\n\nexport type UndefinedInitialDataInfiniteOptions<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = UseInfiniteQueryOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam\n> & {\n  initialData?:\n    | undefined\n    | NonUndefinedGuard<InfiniteData<TQueryFnData, TPageParam>>\n    | InitialDataFunction<\n        NonUndefinedGuard<InfiniteData<TQueryFnData, TPageParam>>\n      >\n}\n\nexport type UnusedSkipTokenInfiniteOptions<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = OmitKeyof<\n  UseInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>,\n  'queryFn'\n> & {\n  queryFn?: Exclude<\n    UseInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >['queryFn'],\n    SkipToken | undefined\n  >\n}\n\nexport type DefinedInitialDataInfiniteOptions<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = UseInfiniteQueryOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam\n> & {\n  initialData:\n    | NonUndefinedGuard<InfiniteData<TQueryFnData, TPageParam>>\n    | (() => NonUndefinedGuard<InfiniteData<TQueryFnData, TPageParam>>)\n    | undefined\n}\n\nexport function infiniteQueryOptions<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: DefinedInitialDataInfiniteOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n): DefinedInitialDataInfiniteOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam\n> & {\n  queryKey: DataTag<TQueryKey, InfiniteData<TQueryFnData>, TError>\n}\n\nexport function infiniteQueryOptions<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: UnusedSkipTokenInfiniteOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n): UnusedSkipTokenInfiniteOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam\n> & {\n  queryKey: DataTag<TQueryKey, InfiniteData<TQueryFnData>, TError>\n}\n\nexport function infiniteQueryOptions<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: UndefinedInitialDataInfiniteOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n): UndefinedInitialDataInfiniteOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam\n> & {\n  queryKey: DataTag<TQueryKey, InfiniteData<TQueryFnData>, TError>\n}\n\nexport function infiniteQueryOptions(options: unknown) {\n  return options\n}\n"],"names":[],"mappings":";;;;AAkJO,SAAS,qBAAqB,OAAA,EAAkB;IACrD,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8853, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40tanstack/react-query/src/queryOptions.ts"],"sourcesContent":["import type {\n  DataTag,\n  DefaultError,\n  InitialDataFunction,\n  NonUndefinedGuard,\n  OmitKeyof,\n  QueryFunction,\n  QueryKey,\n  SkipToken,\n} from '@tanstack/query-core'\nimport type { UseQueryOptions } from './types'\n\nexport type UndefinedInitialDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = UseQueryOptions<TQueryFnData, TError, TData, TQueryKey> & {\n  initialData?:\n    | undefined\n    | InitialDataFunction<NonUndefinedGuard<TQueryFnData>>\n    | NonUndefinedGuard<TQueryFnData>\n}\n\nexport type UnusedSkipTokenOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = OmitKeyof<\n  UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  'queryFn'\n> & {\n  queryFn?: Exclude<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>['queryFn'],\n    SkipToken | undefined\n  >\n}\n\nexport type DefinedInitialDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = Omit<UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>, 'queryFn'> & {\n  initialData:\n    | NonUndefinedGuard<TQueryFnData>\n    | (() => NonUndefinedGuard<TQueryFnData>)\n  queryFn?: QueryFunction<TQueryFnData, TQueryKey>\n}\n\nexport function queryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n): DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey> & {\n  queryKey: DataTag<TQueryKey, TQueryFnData, TError>\n}\n\nexport function queryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UnusedSkipTokenOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UnusedSkipTokenOptions<TQueryFnData, TError, TData, TQueryKey> & {\n  queryKey: DataTag<TQueryKey, TQueryFnData, TError>\n}\n\nexport function queryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey> & {\n  queryKey: DataTag<TQueryKey, TQueryFnData, TError>\n}\n\nexport function queryOptions(options: unknown) {\n  return options\n}\n"],"names":[],"mappings":";;;;AAoFO,SAAS,aAAa,OAAA,EAAkB;IAC7C,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8868, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40tanstack/query-core/src/queryObserver.ts"],"sourcesContent":["import { focusManager } from './focusManager'\nimport { notifyManager } from './notifyManager'\nimport { fetchState } from './query'\nimport { Subscribable } from './subscribable'\nimport { pendingThenable } from './thenable'\nimport {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  shallowEqualObjects,\n  timeUntilStale,\n} from './utils'\nimport type { FetchOptions, Query, QueryState } from './query'\nimport type { QueryClient } from './queryClient'\nimport type { PendingThenable, Thenable } from './thenable'\nimport type {\n  DefaultError,\n  DefaultedQueryObserverOptions,\n  PlaceholderDataFunction,\n  QueryKey,\n  QueryObserverBaseResult,\n  QueryObserverOptions,\n  QueryObserverResult,\n  QueryOptions,\n  RefetchOptions,\n} from './types'\n\ntype QueryObserverListener<TData, TError> = (\n  result: QueryObserverResult<TData, TError>,\n) => void\n\ninterface ObserverFetchOptions extends FetchOptions {\n  throwOnError?: boolean\n}\n\nexport class QueryObserver<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Subscribable<QueryObserverListener<TData, TError>> {\n  #client: QueryClient\n  #currentQuery: Query<TQueryFnData, TError, TQueryData, TQueryKey> = undefined!\n  #currentQueryInitialState: QueryState<TQueryData, TError> = undefined!\n  #currentResult: QueryObserverResult<TData, TError> = undefined!\n  #currentResultState?: QueryState<TQueryData, TError>\n  #currentResultOptions?: QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >\n  #currentThenable: Thenable<TData>\n  #selectError: TError | null\n  #selectFn?: (data: TQueryData) => TData\n  #selectResult?: TData\n  // This property keeps track of the last query with defined data.\n  // It will be used to pass the previous data and query to the placeholder function between renders.\n  #lastQueryWithDefinedData?: Query<TQueryFnData, TError, TQueryData, TQueryKey>\n  #staleTimeoutId?: ReturnType<typeof setTimeout>\n  #refetchIntervalId?: ReturnType<typeof setInterval>\n  #currentRefetchInterval?: number | false\n  #trackedProps = new Set<keyof QueryObserverResult>()\n\n  constructor(\n    client: QueryClient,\n    public options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ) {\n    super()\n\n    this.#client = client\n    this.#selectError = null\n    this.#currentThenable = pendingThenable()\n    if (!this.options.experimental_prefetchInRender) {\n      this.#currentThenable.reject(\n        new Error('experimental_prefetchInRender feature flag is not enabled'),\n      )\n    }\n\n    this.bindMethods()\n    this.setOptions(options)\n  }\n\n  protected bindMethods(): void {\n    this.refetch = this.refetch.bind(this)\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.size === 1) {\n      this.#currentQuery.addObserver(this)\n\n      if (shouldFetchOnMount(this.#currentQuery, this.options)) {\n        this.#executeFetch()\n      } else {\n        this.updateResult()\n      }\n\n      this.#updateTimers()\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.hasListeners()) {\n      this.destroy()\n    }\n  }\n\n  shouldFetchOnReconnect(): boolean {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnReconnect,\n    )\n  }\n\n  shouldFetchOnWindowFocus(): boolean {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus,\n    )\n  }\n\n  destroy(): void {\n    this.listeners = new Set()\n    this.#clearStaleTimeout()\n    this.#clearRefetchInterval()\n    this.#currentQuery.removeObserver(this)\n  }\n\n  setOptions(\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): void {\n    const prevOptions = this.options\n    const prevQuery = this.#currentQuery\n\n    this.options = this.#client.defaultQueryOptions(options)\n\n    if (\n      this.options.enabled !== undefined &&\n      typeof this.options.enabled !== 'boolean' &&\n      typeof this.options.enabled !== 'function' &&\n      typeof resolveEnabled(this.options.enabled, this.#currentQuery) !==\n        'boolean'\n    ) {\n      throw new Error(\n        'Expected enabled to be a boolean or a callback that returns a boolean',\n      )\n    }\n\n    this.#updateQuery()\n    this.#currentQuery.setOptions(this.options)\n\n    if (\n      prevOptions._defaulted &&\n      !shallowEqualObjects(this.options, prevOptions)\n    ) {\n      this.#client.getQueryCache().notify({\n        type: 'observerOptionsUpdated',\n        query: this.#currentQuery,\n        observer: this,\n      })\n    }\n\n    const mounted = this.hasListeners()\n\n    // Fetch if there are subscribers\n    if (\n      mounted &&\n      shouldFetchOptionally(\n        this.#currentQuery,\n        prevQuery,\n        this.options,\n        prevOptions,\n      )\n    ) {\n      this.#executeFetch()\n    }\n\n    // Update result\n    this.updateResult()\n\n    // Update stale interval if needed\n    if (\n      mounted &&\n      (this.#currentQuery !== prevQuery ||\n        resolveEnabled(this.options.enabled, this.#currentQuery) !==\n          resolveEnabled(prevOptions.enabled, this.#currentQuery) ||\n        resolveStaleTime(this.options.staleTime, this.#currentQuery) !==\n          resolveStaleTime(prevOptions.staleTime, this.#currentQuery))\n    ) {\n      this.#updateStaleTimeout()\n    }\n\n    const nextRefetchInterval = this.#computeRefetchInterval()\n\n    // Update refetch interval if needed\n    if (\n      mounted &&\n      (this.#currentQuery !== prevQuery ||\n        resolveEnabled(this.options.enabled, this.#currentQuery) !==\n          resolveEnabled(prevOptions.enabled, this.#currentQuery) ||\n        nextRefetchInterval !== this.#currentRefetchInterval)\n    ) {\n      this.#updateRefetchInterval(nextRefetchInterval)\n    }\n  }\n\n  getOptimisticResult(\n    options: DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const query = this.#client.getQueryCache().build(this.#client, options)\n\n    const result = this.createResult(query, options)\n\n    if (shouldAssignObserverCurrentProperties(this, result)) {\n      // this assigns the optimistic result to the current Observer\n      // because if the query function changes, useQuery will be performing\n      // an effect where it would fetch again.\n      // When the fetch finishes, we perform a deep data cloning in order\n      // to reuse objects references. This deep data clone is performed against\n      // the `observer.currentResult.data` property\n      // When QueryKey changes, we refresh the query and get new `optimistic`\n      // result, while we leave the `observer.currentResult`, so when new data\n      // arrives, it finds the old `observer.currentResult` which is related\n      // to the old QueryKey. Which means that currentResult and selectData are\n      // out of sync already.\n      // To solve this, we move the cursor of the currentResult every time\n      // an observer reads an optimistic value.\n\n      // When keeping the previous data, the result doesn't change until new\n      // data arrives.\n      this.#currentResult = result\n      this.#currentResultOptions = this.options\n      this.#currentResultState = this.#currentQuery.state\n    }\n    return result\n  }\n\n  getCurrentResult(): QueryObserverResult<TData, TError> {\n    return this.#currentResult\n  }\n\n  trackResult(\n    result: QueryObserverResult<TData, TError>,\n    onPropTracked?: (key: keyof QueryObserverResult) => void,\n  ): QueryObserverResult<TData, TError> {\n    return new Proxy(result, {\n      get: (target, key) => {\n        this.trackProp(key as keyof QueryObserverResult)\n        onPropTracked?.(key as keyof QueryObserverResult)\n        return Reflect.get(target, key)\n      },\n    })\n  }\n\n  trackProp(key: keyof QueryObserverResult) {\n    this.#trackedProps.add(key)\n  }\n\n  getCurrentQuery(): Query<TQueryFnData, TError, TQueryData, TQueryKey> {\n    return this.#currentQuery\n  }\n\n  refetch({ ...options }: RefetchOptions = {}): Promise<\n    QueryObserverResult<TData, TError>\n  > {\n    return this.fetch({\n      ...options,\n    })\n  }\n\n  fetchOptimistic(\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    const defaultedOptions = this.#client.defaultQueryOptions(options)\n\n    const query = this.#client\n      .getQueryCache()\n      .build(this.#client, defaultedOptions)\n\n    return query.fetch().then(() => this.createResult(query, defaultedOptions))\n  }\n\n  protected fetch(\n    fetchOptions: ObserverFetchOptions,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    return this.#executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true,\n    }).then(() => {\n      this.updateResult()\n      return this.#currentResult\n    })\n  }\n\n  #executeFetch(\n    fetchOptions?: Omit<ObserverFetchOptions, 'initialPromise'>,\n  ): Promise<TQueryData | undefined> {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.#updateQuery()\n\n    // Fetch\n    let promise: Promise<TQueryData | undefined> = this.#currentQuery.fetch(\n      this.options as QueryOptions<TQueryFnData, TError, TQueryData, TQueryKey>,\n      fetchOptions,\n    )\n\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  #updateStaleTimeout(): void {\n    this.#clearStaleTimeout()\n    const staleTime = resolveStaleTime(\n      this.options.staleTime,\n      this.#currentQuery,\n    )\n\n    if (isServer || this.#currentResult.isStale || !isValidTimeout(staleTime)) {\n      return\n    }\n\n    const time = timeUntilStale(this.#currentResult.dataUpdatedAt, staleTime)\n\n    // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n    const timeout = time + 1\n\n    this.#staleTimeoutId = setTimeout(() => {\n      if (!this.#currentResult.isStale) {\n        this.updateResult()\n      }\n    }, timeout)\n  }\n\n  #computeRefetchInterval() {\n    return (\n      (typeof this.options.refetchInterval === 'function'\n        ? this.options.refetchInterval(this.#currentQuery)\n        : this.options.refetchInterval) ?? false\n    )\n  }\n\n  #updateRefetchInterval(nextInterval: number | false): void {\n    this.#clearRefetchInterval()\n\n    this.#currentRefetchInterval = nextInterval\n\n    if (\n      isServer ||\n      resolveEnabled(this.options.enabled, this.#currentQuery) === false ||\n      !isValidTimeout(this.#currentRefetchInterval) ||\n      this.#currentRefetchInterval === 0\n    ) {\n      return\n    }\n\n    this.#refetchIntervalId = setInterval(() => {\n      if (\n        this.options.refetchIntervalInBackground ||\n        focusManager.isFocused()\n      ) {\n        this.#executeFetch()\n      }\n    }, this.#currentRefetchInterval)\n  }\n\n  #updateTimers(): void {\n    this.#updateStaleTimeout()\n    this.#updateRefetchInterval(this.#computeRefetchInterval())\n  }\n\n  #clearStaleTimeout(): void {\n    if (this.#staleTimeoutId) {\n      clearTimeout(this.#staleTimeoutId)\n      this.#staleTimeoutId = undefined\n    }\n  }\n\n  #clearRefetchInterval(): void {\n    if (this.#refetchIntervalId) {\n      clearInterval(this.#refetchIntervalId)\n      this.#refetchIntervalId = undefined\n    }\n  }\n\n  protected createResult(\n    query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const prevQuery = this.#currentQuery\n    const prevOptions = this.options\n    const prevResult = this.#currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n    const prevResultState = this.#currentResultState\n    const prevResultOptions = this.#currentResultOptions\n    const queryChange = query !== prevQuery\n    const queryInitialState = queryChange\n      ? query.state\n      : this.#currentQueryInitialState\n\n    const { state } = query\n    let newState = { ...state }\n    let isPlaceholderData = false\n    let data: TData | undefined\n\n    // Optimistically set result in fetching state if needed\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners()\n\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options)\n\n      const fetchOptionally =\n        mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions)\n\n      if (fetchOnMount || fetchOptionally) {\n        newState = {\n          ...newState,\n          ...fetchState(state.data, query.options),\n        }\n      }\n      if (options._optimisticResults === 'isRestoring') {\n        newState.fetchStatus = 'idle'\n      }\n    }\n\n    let { error, errorUpdatedAt, status } = newState\n\n    // Per default, use query data\n    data = newState.data as unknown as TData\n    let skipSelect = false\n\n    // use placeholderData if needed\n    if (\n      options.placeholderData !== undefined &&\n      data === undefined &&\n      status === 'pending'\n    ) {\n      let placeholderData\n\n      // Memoize placeholder data\n      if (\n        prevResult?.isPlaceholderData &&\n        options.placeholderData === prevResultOptions?.placeholderData\n      ) {\n        placeholderData = prevResult.data\n        // we have to skip select when reading this memoization\n        // because prevResult.data is already \"selected\"\n        skipSelect = true\n      } else {\n        // compute placeholderData\n        placeholderData =\n          typeof options.placeholderData === 'function'\n            ? (\n                options.placeholderData as unknown as PlaceholderDataFunction<TQueryData>\n              )(\n                this.#lastQueryWithDefinedData?.state.data,\n                this.#lastQueryWithDefinedData as any,\n              )\n            : options.placeholderData\n      }\n\n      if (placeholderData !== undefined) {\n        status = 'success'\n        data = replaceData(\n          prevResult?.data,\n          placeholderData as unknown,\n          options,\n        ) as TData\n        isPlaceholderData = true\n      }\n    }\n\n    // Select data if needed\n    // this also runs placeholderData through the select function\n    if (options.select && data !== undefined && !skipSelect) {\n      // Memoize select result\n      if (\n        prevResult &&\n        data === prevResultState?.data &&\n        options.select === this.#selectFn\n      ) {\n        data = this.#selectResult\n      } else {\n        try {\n          this.#selectFn = options.select\n          data = options.select(data as any)\n          data = replaceData(prevResult?.data, data, options)\n          this.#selectResult = data\n          this.#selectError = null\n        } catch (selectError) {\n          this.#selectError = selectError as TError\n        }\n      }\n    }\n\n    if (this.#selectError) {\n      error = this.#selectError as any\n      data = this.#selectResult\n      errorUpdatedAt = Date.now()\n      status = 'error'\n    }\n\n    const isFetching = newState.fetchStatus === 'fetching'\n    const isPending = status === 'pending'\n    const isError = status === 'error'\n\n    const isLoading = isPending && isFetching\n    const hasData = data !== undefined\n\n    const result: QueryObserverBaseResult<TData, TError> = {\n      status,\n      fetchStatus: newState.fetchStatus,\n      isPending,\n      isSuccess: status === 'success',\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: newState.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: newState.fetchFailureCount,\n      failureReason: newState.fetchFailureReason,\n      errorUpdateCount: newState.errorUpdateCount,\n      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,\n      isFetchedAfterMount:\n        newState.dataUpdateCount > queryInitialState.dataUpdateCount ||\n        newState.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && !hasData,\n      isPaused: newState.fetchStatus === 'paused',\n      isPlaceholderData,\n      isRefetchError: isError && hasData,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      promise: this.#currentThenable,\n    }\n\n    const nextResult = result as QueryObserverResult<TData, TError>\n\n    if (this.options.experimental_prefetchInRender) {\n      const finalizeThenableIfPossible = (thenable: PendingThenable<TData>) => {\n        if (nextResult.status === 'error') {\n          thenable.reject(nextResult.error)\n        } else if (nextResult.data !== undefined) {\n          thenable.resolve(nextResult.data)\n        }\n      }\n\n      /**\n       * Create a new thenable and result promise when the results have changed\n       */\n      const recreateThenable = () => {\n        const pending =\n          (this.#currentThenable =\n          nextResult.promise =\n            pendingThenable())\n\n        finalizeThenableIfPossible(pending)\n      }\n\n      const prevThenable = this.#currentThenable\n      switch (prevThenable.status) {\n        case 'pending':\n          // Finalize the previous thenable if it was pending\n          // and we are still observing the same query\n          if (query.queryHash === prevQuery.queryHash) {\n            finalizeThenableIfPossible(prevThenable)\n          }\n          break\n        case 'fulfilled':\n          if (\n            nextResult.status === 'error' ||\n            nextResult.data !== prevThenable.value\n          ) {\n            recreateThenable()\n          }\n          break\n        case 'rejected':\n          if (\n            nextResult.status !== 'error' ||\n            nextResult.error !== prevThenable.reason\n          ) {\n            recreateThenable()\n          }\n          break\n      }\n    }\n\n    return nextResult\n  }\n\n  updateResult(): void {\n    const prevResult = this.#currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n\n    const nextResult = this.createResult(this.#currentQuery, this.options)\n\n    this.#currentResultState = this.#currentQuery.state\n    this.#currentResultOptions = this.options\n\n    if (this.#currentResultState.data !== undefined) {\n      this.#lastQueryWithDefinedData = this.#currentQuery\n    }\n\n    // Only notify and update result if something has changed\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return\n    }\n\n    this.#currentResult = nextResult\n\n    const shouldNotifyListeners = (): boolean => {\n      if (!prevResult) {\n        return true\n      }\n\n      const { notifyOnChangeProps } = this.options\n      const notifyOnChangePropsValue =\n        typeof notifyOnChangeProps === 'function'\n          ? notifyOnChangeProps()\n          : notifyOnChangeProps\n\n      if (\n        notifyOnChangePropsValue === 'all' ||\n        (!notifyOnChangePropsValue && !this.#trackedProps.size)\n      ) {\n        return true\n      }\n\n      const includedProps = new Set(\n        notifyOnChangePropsValue ?? this.#trackedProps,\n      )\n\n      if (this.options.throwOnError) {\n        includedProps.add('error')\n      }\n\n      return Object.keys(this.#currentResult).some((key) => {\n        const typedKey = key as keyof QueryObserverResult\n        const changed = this.#currentResult[typedKey] !== prevResult[typedKey]\n\n        return changed && includedProps.has(typedKey)\n      })\n    }\n\n    this.#notify({ listeners: shouldNotifyListeners() })\n  }\n\n  #updateQuery(): void {\n    const query = this.#client.getQueryCache().build(this.#client, this.options)\n\n    if (query === this.#currentQuery) {\n      return\n    }\n\n    const prevQuery = this.#currentQuery as\n      | Query<TQueryFnData, TError, TQueryData, TQueryKey>\n      | undefined\n    this.#currentQuery = query\n    this.#currentQueryInitialState = query.state\n\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this)\n      query.addObserver(this)\n    }\n  }\n\n  onQueryUpdate(): void {\n    this.updateResult()\n\n    if (this.hasListeners()) {\n      this.#updateTimers()\n    }\n  }\n\n  #notify(notifyOptions: { listeners: boolean }): void {\n    notifyManager.batch(() => {\n      // First, trigger the listeners\n      if (notifyOptions.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.#currentResult)\n        })\n      }\n\n      // Then the cache listeners\n      this.#client.getQueryCache().notify({\n        query: this.#currentQuery,\n        type: 'observerResultsUpdated',\n      })\n    })\n  }\n}\n\nfunction shouldLoadOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any>,\n): boolean {\n  return (\n    resolveEnabled(options.enabled, query) !== false &&\n    query.state.data === undefined &&\n    !(query.state.status === 'error' && options.retryOnMount === false)\n  )\n}\n\nfunction shouldFetchOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    shouldLoadOnMount(query, options) ||\n    (query.state.data !== undefined &&\n      shouldFetchOn(query, options, options.refetchOnMount))\n  )\n}\n\nfunction shouldFetchOn(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  field: (typeof options)['refetchOnMount'] &\n    (typeof options)['refetchOnWindowFocus'] &\n    (typeof options)['refetchOnReconnect'],\n) {\n  if (\n    resolveEnabled(options.enabled, query) !== false &&\n    resolveStaleTime(options.staleTime, query) !== 'static'\n  ) {\n    const value = typeof field === 'function' ? field(query) : field\n\n    return value === 'always' || (value !== false && isStale(query, options))\n  }\n  return false\n}\n\nfunction shouldFetchOptionally(\n  query: Query<any, any, any, any>,\n  prevQuery: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  prevOptions: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    (query !== prevQuery ||\n      resolveEnabled(prevOptions.enabled, query) === false) &&\n    (!options.suspense || query.state.status !== 'error') &&\n    isStale(query, options)\n  )\n}\n\nfunction isStale(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    resolveEnabled(options.enabled, query) !== false &&\n    query.isStaleByTime(resolveStaleTime(options.staleTime, query))\n  )\n}\n\n// this function would decide if we will update the observer's 'current'\n// properties after an optimistic reading via getOptimisticResult\nfunction shouldAssignObserverCurrentProperties<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  optimisticResult: QueryObserverResult<TData, TError>,\n) {\n  // if the newly created result isn't what the observer is holding as current,\n  // then we'll need to update the properties as well\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true\n  }\n\n  // basically, just keep previous properties if nothing changed\n  return false\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 9307, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40tanstack/query-core/src/infiniteQueryObserver.ts"],"sourcesContent":["import { QueryObserver } from './queryObserver'\nimport {\n  hasNextPage,\n  hasPreviousPage,\n  infiniteQueryBehavior,\n} from './infiniteQueryBehavior'\nimport type { Subscribable } from './subscribable'\nimport type {\n  DefaultError,\n  DefaultedInfiniteQueryObserverOptions,\n  FetchNextPageOptions,\n  FetchPreviousPageOptions,\n  InfiniteData,\n  InfiniteQueryObserverBaseResult,\n  InfiniteQueryObserverOptions,\n  InfiniteQueryObserverResult,\n  QueryKey,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport type { Query } from './query'\n\ntype InfiniteQueryObserverListener<TData, TError> = (\n  result: InfiniteQueryObserverResult<TData, TError>,\n) => void\n\nexport class InfiniteQueryObserver<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> extends QueryObserver<\n  TQueryFnData,\n  TError,\n  TData,\n  InfiniteData<TQueryFnData, TPageParam>,\n  TQueryKey\n> {\n  // Type override\n  subscribe!: Subscribable<\n    InfiniteQueryObserverListener<TData, TError>\n  >['subscribe']\n\n  // Type override\n  getCurrentResult!: ReplaceReturnType<\n    QueryObserver<\n      TQueryFnData,\n      TError,\n      TData,\n      InfiniteData<TQueryFnData, TPageParam>,\n      TQueryKey\n    >['getCurrentResult'],\n    InfiniteQueryObserverResult<TData, TError>\n  >\n\n  // Type override\n  protected fetch!: ReplaceReturnType<\n    QueryObserver<\n      TQueryFnData,\n      TError,\n      TData,\n      InfiniteData<TQueryFnData, TPageParam>,\n      TQueryKey\n    >['fetch'],\n    Promise<InfiniteQueryObserverResult<TData, TError>>\n  >\n\n  constructor(\n    client: QueryClient,\n    options: InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ) {\n    super(client, options)\n  }\n\n  protected bindMethods(): void {\n    super.bindMethods()\n    this.fetchNextPage = this.fetchNextPage.bind(this)\n    this.fetchPreviousPage = this.fetchPreviousPage.bind(this)\n  }\n\n  setOptions(\n    options: InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): void {\n    super.setOptions({\n      ...options,\n      behavior: infiniteQueryBehavior(),\n    })\n  }\n\n  getOptimisticResult(\n    options: DefaultedInfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): InfiniteQueryObserverResult<TData, TError> {\n    options.behavior = infiniteQueryBehavior()\n    return super.getOptimisticResult(options) as InfiniteQueryObserverResult<\n      TData,\n      TError\n    >\n  }\n\n  fetchNextPage(\n    options?: FetchNextPageOptions,\n  ): Promise<InfiniteQueryObserverResult<TData, TError>> {\n    return this.fetch({\n      ...options,\n      meta: {\n        fetchMore: { direction: 'forward' },\n      },\n    })\n  }\n\n  fetchPreviousPage(\n    options?: FetchPreviousPageOptions,\n  ): Promise<InfiniteQueryObserverResult<TData, TError>> {\n    return this.fetch({\n      ...options,\n      meta: {\n        fetchMore: { direction: 'backward' },\n      },\n    })\n  }\n\n  protected createResult(\n    query: Query<\n      TQueryFnData,\n      TError,\n      InfiniteData<TQueryFnData, TPageParam>,\n      TQueryKey\n    >,\n    options: InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): InfiniteQueryObserverResult<TData, TError> {\n    const { state } = query\n    const parentResult = super.createResult(query, options)\n\n    const { isFetching, isRefetching, isError, isRefetchError } = parentResult\n    const fetchDirection = state.fetchMeta?.fetchMore?.direction\n\n    const isFetchNextPageError = isError && fetchDirection === 'forward'\n    const isFetchingNextPage = isFetching && fetchDirection === 'forward'\n\n    const isFetchPreviousPageError = isError && fetchDirection === 'backward'\n    const isFetchingPreviousPage = isFetching && fetchDirection === 'backward'\n\n    const result: InfiniteQueryObserverBaseResult<TData, TError> = {\n      ...parentResult,\n      fetchNextPage: this.fetchNextPage,\n      fetchPreviousPage: this.fetchPreviousPage,\n      hasNextPage: hasNextPage(options, state.data),\n      hasPreviousPage: hasPreviousPage(options, state.data),\n      isFetchNextPageError,\n      isFetchingNextPage,\n      isFetchPreviousPageError,\n      isFetchingPreviousPage,\n      isRefetchError:\n        isRefetchError && !isFetchNextPageError && !isFetchPreviousPageError,\n      isRefetching:\n        isRefetching && !isFetchingNextPage && !isFetchingPreviousPage,\n    }\n\n    return result as InfiniteQueryObserverResult<TData, TError>\n  }\n}\n\ntype ReplaceReturnType<\n  TFunction extends (...args: Array<any>) => unknown,\n  TReturn,\n> = (...args: Parameters<TFunction>) => TReturn\n"],"names":[],"mappings":";;;;AAAA,SAAS,qBAAqB;AAC9B;;;AAwBO,IAAM,wBAAN,iMAMG,gBAAA,CAMR;IA8BA,YACE,MAAA,EACA,OAAA,CAOA;QACA,KAAA,CAAM,QAAQ,OAAO;IACvB;IAEU,cAAoB;QAC5B,KAAA,CAAM,YAAY;QAClB,IAAA,CAAK,aAAA,GAAgB,IAAA,CAAK,aAAA,CAAc,IAAA,CAAK,IAAI;QACjD,IAAA,CAAK,iBAAA,GAAoB,IAAA,CAAK,iBAAA,CAAkB,IAAA,CAAK,IAAI;IAC3D;IAEA,WACE,OAAA,EAOM;QACN,KAAA,CAAM,WAAW;YACf,GAAG,OAAA;YACH,cAAU,mNAAA,CAAsB;QAClC,CAAC;IACH;IAEA,oBACE,OAAA,EAO4C;QAC5C,QAAQ,QAAA,GAAW,uNAAA,CAAsB;QACzC,OAAO,KAAA,CAAM,oBAAoB,OAAO;IAI1C;IAEA,cACE,OAAA,EACqD;QACrD,OAAO,IAAA,CAAK,KAAA,CAAM;YAChB,GAAG,OAAA;YACH,MAAM;gBACJ,WAAW;oBAAE,WAAW;gBAAU;YACpC;QACF,CAAC;IACH;IAEA,kBACE,OAAA,EACqD;QACrD,OAAO,IAAA,CAAK,KAAA,CAAM;YAChB,GAAG,OAAA;YACH,MAAM;gBACJ,WAAW;oBAAE,WAAW;gBAAW;YACrC;QACF,CAAC;IACH;IAEU,aACR,KAAA,EAMA,OAAA,EAO4C;QAC5C,MAAM,EAAE,KAAA,CAAM,CAAA,GAAI;QAClB,MAAM,eAAe,KAAA,CAAM,aAAa,OAAO,OAAO;QAEtD,MAAM,EAAE,UAAA,EAAY,YAAA,EAAc,OAAA,EAAS,cAAA,CAAe,CAAA,GAAI;QAC9D,MAAM,iBAAiB,MAAM,SAAA,EAAW,WAAW;QAEnD,MAAM,uBAAuB,WAAW,mBAAmB;QAC3D,MAAM,qBAAqB,cAAc,mBAAmB;QAE5D,MAAM,2BAA2B,WAAW,mBAAmB;QAC/D,MAAM,yBAAyB,cAAc,mBAAmB;QAEhE,MAAM,SAAyD;YAC7D,GAAG,YAAA;YACH,eAAe,IAAA,CAAK,aAAA;YACpB,mBAAmB,IAAA,CAAK,iBAAA;YACxB,4MAAa,cAAA,EAAY,SAAS,MAAM,IAAI;YAC5C,kBAAiB,gNAAA,EAAgB,SAAS,MAAM,IAAI;YACpD;YACA;YACA;YACA;YACA,gBACE,kBAAkB,CAAC,wBAAwB,CAAC;YAC9C,cACE,gBAAgB,CAAC,sBAAsB,CAAC;QAC5C;QAEA,OAAO;IACT;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 9387, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40tanstack/react-query/src/QueryErrorResetBoundary.tsx"],"sourcesContent":["'use client'\nimport * as React from 'react'\n\n// CONTEXT\nexport type QueryErrorResetFunction = () => void\nexport type QueryErrorIsResetFunction = () => boolean\nexport type QueryErrorClearResetFunction = () => void\n\nexport interface QueryErrorResetBoundaryValue {\n  clearReset: QueryErrorClearResetFunction\n  isReset: QueryErrorIsResetFunction\n  reset: QueryErrorResetFunction\n}\n\nfunction createValue(): QueryErrorResetBoundaryValue {\n  let isReset = false\n  return {\n    clearReset: () => {\n      isReset = false\n    },\n    reset: () => {\n      isReset = true\n    },\n    isReset: () => {\n      return isReset\n    },\n  }\n}\n\nconst QueryErrorResetBoundaryContext = React.createContext(createValue())\n\n// HOOK\n\nexport const useQueryErrorResetBoundary = () =>\n  React.useContext(QueryErrorResetBoundaryContext)\n\n// COMPONENT\n\nexport type QueryErrorResetBoundaryFunction = (\n  value: QueryErrorResetBoundaryValue,\n) => React.ReactNode\n\nexport interface QueryErrorResetBoundaryProps {\n  children: QueryErrorResetBoundaryFunction | React.ReactNode\n}\n\nexport const QueryErrorResetBoundary = ({\n  children,\n}: QueryErrorResetBoundaryProps) => {\n  const [value] = React.useState(() => createValue())\n  return (\n    <QueryErrorResetBoundaryContext.Provider value={value}>\n      {typeof children === 'function' ? children(value) : children}\n    </QueryErrorResetBoundaryContext.Provider>\n  )\n}\n"],"names":[],"mappings":";;;;;AACA,YAAY,WAAW;AAkDnB;;;;AArCJ,SAAS,cAA4C;IACnD,IAAI,UAAU;IACd,OAAO;QACL,YAAY,MAAM;YAChB,UAAU;QACZ;QACA,OAAO,MAAM;YACX,UAAU;QACZ;QACA,SAAS,MAAM;YACb,OAAO;QACT;IACF;AACF;AAEA,IAAM,mMAAuC,gBAAA,EAAc,YAAY,CAAC;AAIjE,IAAM,6BAA6B,sKAClC,aAAA,EAAW,8BAA8B;AAY1C,IAAM,0BAA0B,CAAC,EACtC,QAAA,EACF,KAAoC;IAClC,MAAM,CAAC,KAAK,CAAA,qKAAU,WAAA;4CAAS,IAAM,YAAY,CAAC;;IAClD,OACE,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,+BAA+B,QAAA,EAA/B;QAAwC;QACtC,UAAA,OAAO,aAAa,aAAa,SAAS,KAAK,IAAI;IAAA,CACtD;AAEJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 9430, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40tanstack/react-query/src/errorBoundaryUtils.ts"],"sourcesContent":["'use client'\nimport * as React from 'react'\nimport { shouldThrowError } from '@tanstack/query-core'\nimport type {\n  DefaultedQueryObserverOptions,\n  Query,\n  QueryKey,\n  QueryObserverResult,\n  ThrowOnError,\n} from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\n\nexport const ensurePreventErrorBoundaryRetry = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  if (\n    options.suspense ||\n    options.throwOnError ||\n    options.experimental_prefetchInRender\n  ) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      options.retryOnMount = false\n    }\n  }\n}\n\nexport const useClearResetErrorBoundary = (\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  React.useEffect(() => {\n    errorResetBoundary.clearReset()\n  }, [errorResetBoundary])\n}\n\nexport const getHasError = <\n  TData,\n  TError,\n  TQueryFnData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>({\n  result,\n  errorResetBoundary,\n  throwOnError,\n  query,\n  suspense,\n}: {\n  result: QueryObserverResult<TData, TError>\n  errorResetBoundary: QueryErrorResetBoundaryValue\n  throwOnError: ThrowOnError<TQueryFnData, TError, TQueryData, TQueryKey>\n  query: Query<TQueryFnData, TError, TQueryData, TQueryKey> | undefined\n  suspense: boolean | undefined\n}) => {\n  return (\n    result.isError &&\n    !errorResetBoundary.isReset() &&\n    !result.isFetching &&\n    query &&\n    ((suspense && result.data === undefined) ||\n      shouldThrowError(throwOnError, [result.error, query]))\n  )\n}\n"],"names":[],"mappings":";;;;;;AACA,YAAY,WAAW;AACvB,SAAS,wBAAwB;;;;AAU1B,IAAM,kCAAkC,CAO7C,SAOA,uBACG;IACH,IACE,QAAQ,QAAA,IACR,QAAQ,YAAA,IACR,QAAQ,6BAAA,EACR;QAEA,IAAI,CAAC,mBAAmB,OAAA,CAAQ,GAAG;YACjC,QAAQ,YAAA,GAAe;QACzB;IACF;AACF;AAEO,IAAM,6BAA6B,CACxC,uBACG;sKACG,YAAA;gDAAU,MAAM;YACpB,mBAAmB,UAAA,CAAW;QAChC;+CAAG;QAAC,kBAAkB;KAAC;AACzB;AAEO,IAAM,cAAc,CAMzB,EACA,MAAA,EACA,kBAAA,EACA,YAAA,EACA,KAAA,EACA,QAAA,EACF,KAMM;IACJ,OACE,OAAO,OAAA,IACP,CAAC,mBAAmB,OAAA,CAAQ,KAC5B,CAAC,OAAO,UAAA,IACR,SAAA,CACE,YAAY,OAAO,IAAA,KAAS,KAAA,oLAC5B,mBAAA,EAAiB,cAAc;QAAC,OAAO,KAAA;QAAO,KAAK;KAAC,CAAA;AAE1D","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 9471, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40tanstack/react-query/src/IsRestoringProvider.ts"],"sourcesContent":["'use client'\nimport * as React from 'react'\n\nconst IsRestoringContext = React.createContext(false)\n\nexport const useIsRestoring = () => React.useContext(IsRestoringContext)\nexport const IsRestoringProvider = IsRestoringContext.Provider\n"],"names":[],"mappings":";;;;;AACA,YAAY,WAAW;;;AAEvB,IAAM,uLAA2B,gBAAA,EAAc,KAAK;AAE7C,IAAM,iBAAiB,sKAAY,aAAA,EAAW,kBAAkB;AAChE,IAAM,sBAAsB,mBAAmB,QAAA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 9490, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40tanstack/react-query/src/suspense.ts"],"sourcesContent":["import type {\n  DefaultError,\n  DefaultedQueryObserverOptions,\n  Query,\n  QueryKey,\n  QueryObserver,\n  QueryObserverResult,\n} from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\n\nexport const defaultThrowOnError = <\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  _error: TError,\n  query: Query<TQueryFnData, TError, TData, TQueryKey>,\n) => query.state.data === undefined\n\nexport const ensureSuspenseTimers = (\n  defaultedOptions: DefaultedQueryObserverOptions<any, any, any, any, any>,\n) => {\n  if (defaultedOptions.suspense) {\n    // Handle staleTime to ensure minimum 1000ms in Suspense mode\n    // This prevents unnecessary refetching when components remount after suspending\n\n    const clamp = (value: number | 'static' | undefined) =>\n      value === 'static' ? value : Math.max(value ?? 1000, 1000)\n\n    const originalStaleTime = defaultedOptions.staleTime\n    defaultedOptions.staleTime =\n      typeof originalStaleTime === 'function'\n        ? (...args) => clamp(originalStaleTime(...args))\n        : clamp(originalStaleTime)\n\n    if (typeof defaultedOptions.gcTime === 'number') {\n      defaultedOptions.gcTime = Math.max(defaultedOptions.gcTime, 1000)\n    }\n  }\n}\n\nexport const willFetch = (\n  result: QueryObserverResult<any, any>,\n  isRestoring: boolean,\n) => result.isLoading && result.isFetching && !isRestoring\n\nexport const shouldSuspend = (\n  defaultedOptions:\n    | DefaultedQueryObserverOptions<any, any, any, any, any>\n    | undefined,\n  result: QueryObserverResult<any, any>,\n) => defaultedOptions?.suspense && result.isPending\n\nexport const fetchOptimistic = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  defaultedOptions: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) =>\n  observer.fetchOptimistic(defaultedOptions).catch(() => {\n    errorResetBoundary.clearReset()\n  })\n"],"names":[],"mappings":";;;;;;;;AAUO,IAAM,sBAAsB,CAMjC,QACA,QACG,MAAM,KAAA,CAAM,IAAA,KAAS,KAAA;AAEnB,IAAM,uBAAuB,CAClC,qBACG;IACH,IAAI,iBAAiB,QAAA,EAAU;QAI7B,MAAM,QAAQ,CAAC,QACb,UAAU,WAAW,QAAQ,KAAK,GAAA,CAAI,SAAS,KAAM,GAAI;QAE3D,MAAM,oBAAoB,iBAAiB,SAAA;QAC3C,iBAAiB,SAAA,GACf,OAAO,sBAAsB,aACzB,CAAA,GAAI,OAAS,MAAM,kBAAkB,GAAG,IAAI,CAAC,IAC7C,MAAM,iBAAiB;QAE7B,IAAI,OAAO,iBAAiB,MAAA,KAAW,UAAU;YAC/C,iBAAiB,MAAA,GAAS,KAAK,GAAA,CAAI,iBAAiB,MAAA,EAAQ,GAAI;QAClE;IACF;AACF;AAEO,IAAM,YAAY,CACvB,QACA,cACG,OAAO,SAAA,IAAa,OAAO,UAAA,IAAc,CAAC;AAExC,IAAM,gBAAgB,CAC3B,kBAGA,SACG,kBAAkB,YAAY,OAAO,SAAA;AAEnC,IAAM,kBAAkB,CAO7B,kBAOA,UACA,qBAEA,SAAS,eAAA,CAAgB,gBAAgB,EAAE,KAAA,CAAM,MAAM;QACrD,mBAAmB,UAAA,CAAW;IAChC,CAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 9522, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40tanstack/react-query/src/useBaseQuery.ts"],"sourcesContent":["'use client'\nimport * as React from 'react'\n\nimport { isServer, noop, notifyManager } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport { useIsRestoring } from './IsRestoringProvider'\nimport {\n  ensureSuspenseTimers,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch,\n} from './suspense'\nimport type {\n  QueryClient,\n  QueryKey,\n  QueryObserver,\n  QueryObserverResult,\n} from '@tanstack/query-core'\nimport type { UseBaseQueryOptions } from './types'\n\nexport function useBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: UseBaseQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  Observer: typeof QueryObserver,\n  queryClient?: QueryClient,\n): QueryObserverResult<TData, TError> {\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof options !== 'object' || Array.isArray(options)) {\n      throw new Error(\n        'Bad argument type. Starting with v5, only the \"Object\" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object',\n      )\n    }\n  }\n\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n  const client = useQueryClient(queryClient)\n  const defaultedOptions = client.defaultQueryOptions(options)\n\n  ;(client.getDefaultOptions().queries as any)?._experimental_beforeQuery?.(\n    defaultedOptions,\n  )\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!defaultedOptions.queryFn) {\n      console.error(\n        `[${defaultedOptions.queryHash}]: No queryFn was passed as an option, and no default queryFn was found. The queryFn parameter is only optional when using a default queryFn. More info here: https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function`,\n      )\n    }\n  }\n\n  // Make sure results are optimistically set in fetching state before subscribing or updating options\n  defaultedOptions._optimisticResults = isRestoring\n    ? 'isRestoring'\n    : 'optimistic'\n\n  ensureSuspenseTimers(defaultedOptions)\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary)\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  // this needs to be invoked before creating the Observer because that can create a cache entry\n  const isNewCacheEntry = !client\n    .getQueryCache()\n    .get(defaultedOptions.queryHash)\n\n  const [observer] = React.useState(\n    () =>\n      new Observer<TQueryFnData, TError, TData, TQueryData, TQueryKey>(\n        client,\n        defaultedOptions,\n      ),\n  )\n\n  // note: this must be called before useSyncExternalStore\n  const result = observer.getOptimisticResult(defaultedOptions)\n\n  const shouldSubscribe = !isRestoring && options.subscribed !== false\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) => {\n        const unsubscribe = shouldSubscribe\n          ? observer.subscribe(notifyManager.batchCalls(onStoreChange))\n          : noop\n\n        // Update result to make sure we did not miss any query updates\n        // between creating the observer and subscribing to it.\n        observer.updateResult()\n\n        return unsubscribe\n      },\n      [observer, shouldSubscribe],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    observer.setOptions(defaultedOptions)\n  }, [defaultedOptions, observer])\n\n  // Handle suspense\n  if (shouldSuspend(defaultedOptions, result)) {\n    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary)\n  }\n\n  // Handle error boundary\n  if (\n    getHasError({\n      result,\n      errorResetBoundary,\n      throwOnError: defaultedOptions.throwOnError,\n      query: client\n        .getQueryCache()\n        .get<\n          TQueryFnData,\n          TError,\n          TQueryData,\n          TQueryKey\n        >(defaultedOptions.queryHash),\n      suspense: defaultedOptions.suspense,\n    })\n  ) {\n    throw result.error\n  }\n\n  ;(client.getDefaultOptions().queries as any)?._experimental_afterQuery?.(\n    defaultedOptions,\n    result,\n  )\n\n  if (\n    defaultedOptions.experimental_prefetchInRender &&\n    !isServer &&\n    willFetch(result, isRestoring)\n  ) {\n    const promise = isNewCacheEntry\n      ? // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted\n        fetchOptimistic(defaultedOptions, observer, errorResetBoundary)\n      : // subscribe to the \"cache promise\" so that we can finalize the currentThenable once data comes in\n        client.getQueryCache().get(defaultedOptions.queryHash)?.promise\n\n    promise?.catch(noop).finally(() => {\n      // `.updateResult()` will trigger `.#currentThenable` to finalize\n      observer.updateResult()\n    })\n  }\n\n  // Handle result property usage tracking\n  return !defaultedOptions.notifyOnChangeProps\n    ? observer.trackResult(result)\n    : result\n}\n"],"names":[],"mappings":";;;AA2CM,QAAQ,IAAI,aAAa;;AA1C/B,YAAY,WAAW;;AAEvB,SAAS,UAAU,MAAM,qBAAqB;AAC9C,SAAS,sBAAsB;AAC/B,SAAS,kCAAkC;AAC3C;AAKA,SAAS,sBAAsB;AAC/B;;;;;;;;;AAcO,SAAS,aAOd,OAAA,EAOA,QAAA,EACA,WAAA,EACoC;IACpC,wCAA2C;QACzC,IAAI,OAAO,YAAY,YAAY,MAAM,OAAA,CAAQ,OAAO,GAAG;YACzD,MAAM,IAAI,MACR;QAEJ;IACF;IAEA,MAAM,4MAAc,iBAAA,CAAe;IACnC,MAAM,uNAAqB,6BAAA,CAA2B;IACtD,MAAM,uMAAS,iBAAA,EAAe,WAAW;IACzC,MAAM,mBAAmB,OAAO,mBAAA,CAAoB,OAAO;IAEzD,OAAO,iBAAA,CAAkB,EAAE,OAAA,EAAiB,4BAC5C;IAGF,IAAI,QAAQ,IAAI,aAAa,WAAc;QACzC,IAAI,CAAC,iBAAiB,OAAA,EAAS;YAC7B,QAAQ,KAAA,CACN,CAAA,CAAA,EAAI,iBAAiB,SAAS,CAAA,kPAAA,CAAA;QAElC;IACF;IAGA,iBAAiB,kBAAA,GAAqB,cAClC,gBACA;IAEJ,CAAA,GAAA,8KAAA,CAAA,uBAAA,EAAqB,gBAAgB;IACrC,CAAA,GAAA,wLAAA,CAAA,kCAAA,EAAgC,kBAAkB,kBAAkB;IAEpE,CAAA,GAAA,wLAAA,CAAA,6BAAA,EAA2B,kBAAkB;IAG7C,MAAM,kBAAkB,CAAC,OACtB,aAAA,CAAc,EACd,GAAA,CAAI,iBAAiB,SAAS;IAEjC,MAAM,CAAC,QAAQ,CAAA,qKAAU,WAAA;iCACvB,IACE,IAAI,SACF,QACA;;IAKN,MAAM,SAAS,SAAS,mBAAA,CAAoB,gBAAgB;IAE5D,MAAM,kBAAkB,CAAC,eAAe,QAAQ,UAAA,KAAe;sKACzD,uBAAA,oKACE,cAAA;yDACJ,CAAC,kBAAkB;YACjB,MAAM,cAAc,kBAChB,SAAS,SAAA,oLAAU,gBAAA,CAAc,UAAA,CAAW,aAAa,CAAC,+KAC1D,OAAA;YAIJ,SAAS,YAAA,CAAa;YAEtB,OAAO;QACT;wDACA;QAAC;QAAU,eAAe;KAAA;6CAE5B,IAAM,SAAS,gBAAA,CAAiB;;6CAChC,IAAM,SAAS,gBAAA,CAAiB;;sKAG5B,YAAA;kCAAU,MAAM;YACpB,SAAS,UAAA,CAAW,gBAAgB;QACtC;iCAAG;QAAC;QAAkB,QAAQ;KAAC;IAG/B,uLAAI,gBAAA,EAAc,kBAAkB,MAAM,GAAG;QAC3C,yLAAM,kBAAA,EAAgB,kBAAkB,UAAU,kBAAkB;IACtE;IAGA,iMACE,cAAA,EAAY;QACV;QACA;QACA,cAAc,iBAAiB,YAAA;QAC/B,OAAO,OACJ,aAAA,CAAc,EACd,GAAA,CAKC,iBAAiB,SAAS;QAC9B,UAAU,iBAAiB,QAAA;IAC7B,CAAC,GACD;QACA,MAAM,OAAO,KAAA;IACf;;IAEE,OAAO,iBAAA,CAAkB,EAAE,OAAA,EAAiB,2BAC5C,kBACA;IAGF,IACE,iBAAiB,6BAAA,IACjB,4KAAC,WAAA,uLACD,YAAA,EAAU,QAAQ,WAAW,GAC7B;QACA,MAAM,UAAU,kBAAA,2GAAA;2LAEZ,kBAAA,EAAgB,kBAAkB,UAAU,kBAAkB,IAAA,kGAAA;QAE9D,OAAO,aAAA,CAAc,EAAE,GAAA,CAAI,iBAAiB,SAAS,GAAG;QAE5D,SAAS,iLAAM,OAAI,EAAE,QAAQ,MAAM;YAEjC,SAAS,YAAA,CAAa;QACxB,CAAC;IACH;IAGA,OAAO,CAAC,iBAAiB,mBAAA,GACrB,SAAS,WAAA,CAAY,MAAM,IAC3B;AACN","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 9623, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40tanstack/react-query/src/useInfiniteQuery.ts"],"sourcesContent":["'use client'\nimport { InfiniteQueryObserver } from '@tanstack/query-core'\nimport { useBaseQuery } from './useBaseQuery'\nimport type {\n  DefaultError,\n  InfiniteData,\n  QueryClient,\n  QueryKey,\n  QueryObserver,\n} from '@tanstack/query-core'\nimport type {\n  DefinedUseInfiniteQueryResult,\n  UseInfiniteQueryOptions,\n  UseInfiniteQueryResult,\n} from './types'\nimport type {\n  DefinedInitialDataInfiniteOptions,\n  UndefinedInitialDataInfiniteOptions,\n} from './infiniteQueryOptions'\n\nexport function useInfiniteQuery<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: DefinedInitialDataInfiniteOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n  queryClient?: QueryClient,\n): DefinedUseInfiniteQueryResult<TData, TError>\n\nexport function useInfiniteQuery<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: UndefinedInitialDataInfiniteOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n  queryClient?: QueryClient,\n): UseInfiniteQueryResult<TData, TError>\n\nexport function useInfiniteQuery<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: UseInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n  queryClient?: QueryClient,\n): UseInfiniteQueryResult<TData, TError>\n\nexport function useInfiniteQuery(\n  options: UseInfiniteQueryOptions,\n  queryClient?: QueryClient,\n) {\n  return useBaseQuery(\n    options,\n    InfiniteQueryObserver as typeof QueryObserver,\n    queryClient,\n  )\n}\n"],"names":[],"mappings":";;;;AACA,SAAS,6BAA6B;AACtC,SAAS,oBAAoB;;;;AAqEtB,SAAS,iBACd,OAAA,EACA,WAAA,EACA;IACA,8LAAO,eAAA,EACL,oMACA,wBAAA,EACA;AAEJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 9643, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40tanstack/query-core/src/mutationObserver.ts"],"sourcesContent":["import { getDefaultState } from './mutation'\nimport { notifyManager } from './notifyManager'\nimport { Subscribable } from './subscribable'\nimport { hashKey, shallowEqualObjects } from './utils'\nimport type { QueryClient } from './queryClient'\nimport type {\n  DefaultError,\n  MutateOptions,\n  MutationObserverOptions,\n  MutationObserverResult,\n} from './types'\nimport type { Action, Mutation } from './mutation'\n\n// TYPES\n\ntype MutationObserverListener<TData, TError, TVariables, TContext> = (\n  result: MutationObserverResult<TData, TError, TVariables, TContext>,\n) => void\n\n// CLASS\n\nexport class MutationObserver<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends Subscribable<\n  MutationObserverListener<TData, TError, TVariables, TContext>\n> {\n  options!: MutationObserverOptions<TData, TError, TVariables, TContext>\n\n  #client: QueryClient\n  #currentResult: MutationObserverResult<TData, TError, TVariables, TContext> =\n    undefined!\n  #currentMutation?: Mutation<TData, TError, TVariables, TContext>\n  #mutateOptions?: MutateOptions<TData, TError, TVariables, TContext>\n\n  constructor(\n    client: QueryClient,\n    options: MutationObserverOptions<TData, TError, TVariables, TContext>,\n  ) {\n    super()\n\n    this.#client = client\n    this.setOptions(options)\n    this.bindMethods()\n    this.#updateResult()\n  }\n\n  protected bindMethods(): void {\n    this.mutate = this.mutate.bind(this)\n    this.reset = this.reset.bind(this)\n  }\n\n  setOptions(\n    options: MutationObserverOptions<TData, TError, TVariables, TContext>,\n  ) {\n    const prevOptions = this.options as\n      | MutationObserverOptions<TData, TError, TVariables, TContext>\n      | undefined\n    this.options = this.#client.defaultMutationOptions(options)\n    if (!shallowEqualObjects(this.options, prevOptions)) {\n      this.#client.getMutationCache().notify({\n        type: 'observerOptionsUpdated',\n        mutation: this.#currentMutation,\n        observer: this,\n      })\n    }\n\n    if (\n      prevOptions?.mutationKey &&\n      this.options.mutationKey &&\n      hashKey(prevOptions.mutationKey) !== hashKey(this.options.mutationKey)\n    ) {\n      this.reset()\n    } else if (this.#currentMutation?.state.status === 'pending') {\n      this.#currentMutation.setOptions(this.options)\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.hasListeners()) {\n      this.#currentMutation?.removeObserver(this)\n    }\n  }\n\n  onMutationUpdate(action: Action<TData, TError, TVariables, TContext>): void {\n    this.#updateResult()\n\n    this.#notify(action)\n  }\n\n  getCurrentResult(): MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  > {\n    return this.#currentResult\n  }\n\n  reset(): void {\n    // reset needs to remove the observer from the mutation because there is no way to \"get it back\"\n    // another mutate call will yield a new mutation!\n    this.#currentMutation?.removeObserver(this)\n    this.#currentMutation = undefined\n    this.#updateResult()\n    this.#notify()\n  }\n\n  mutate(\n    variables: TVariables,\n    options?: MutateOptions<TData, TError, TVariables, TContext>,\n  ): Promise<TData> {\n    this.#mutateOptions = options\n\n    this.#currentMutation?.removeObserver(this)\n\n    this.#currentMutation = this.#client\n      .getMutationCache()\n      .build(this.#client, this.options)\n\n    this.#currentMutation.addObserver(this)\n\n    return this.#currentMutation.execute(variables)\n  }\n\n  #updateResult(): void {\n    const state =\n      this.#currentMutation?.state ??\n      getDefaultState<TData, TError, TVariables, TContext>()\n\n    this.#currentResult = {\n      ...state,\n      isPending: state.status === 'pending',\n      isSuccess: state.status === 'success',\n      isError: state.status === 'error',\n      isIdle: state.status === 'idle',\n      mutate: this.mutate,\n      reset: this.reset,\n    } as MutationObserverResult<TData, TError, TVariables, TContext>\n  }\n\n  #notify(action?: Action<TData, TError, TVariables, TContext>): void {\n    notifyManager.batch(() => {\n      // First trigger the mutate callbacks\n      if (this.#mutateOptions && this.hasListeners()) {\n        const variables = this.#currentResult.variables!\n        const context = this.#currentResult.context\n\n        if (action?.type === 'success') {\n          this.#mutateOptions.onSuccess?.(action.data, variables, context!)\n          this.#mutateOptions.onSettled?.(action.data, null, variables, context)\n        } else if (action?.type === 'error') {\n          this.#mutateOptions.onError?.(action.error, variables, context)\n          this.#mutateOptions.onSettled?.(\n            undefined,\n            action.error,\n            variables,\n            context,\n          )\n        }\n      }\n\n      // Then trigger the listeners\n      this.listeners.forEach((listener) => {\n        listener(this.#currentResult)\n      })\n    })\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 9751, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40tanstack/react-query/src/useMutation.ts"],"sourcesContent":["'use client'\nimport * as React from 'react'\nimport {\n  MutationObserver,\n  noop,\n  notifyManager,\n  shouldThrowError,\n} from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type {\n  UseMutateFunction,\n  UseMutationOptions,\n  UseMutationResult,\n} from './types'\nimport type { DefaultError, QueryClient } from '@tanstack/query-core'\n\n// HOOK\n\nexport function useMutation<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n>(\n  options: UseMutationOptions<TData, TError, TVariables, TContext>,\n  queryClient?: QueryClient,\n): UseMutationResult<TData, TError, TVariables, TContext> {\n  const client = useQueryClient(queryClient)\n\n  const [observer] = React.useState(\n    () =>\n      new MutationObserver<TData, TError, TVariables, TContext>(\n        client,\n        options,\n      ),\n  )\n\n  React.useEffect(() => {\n    observer.setOptions(options)\n  }, [observer, options])\n\n  const result = React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  const mutate = React.useCallback<\n    UseMutateFunction<TData, TError, TVariables, TContext>\n  >(\n    (variables, mutateOptions) => {\n      observer.mutate(variables, mutateOptions).catch(noop)\n    },\n    [observer],\n  )\n\n  if (\n    result.error &&\n    shouldThrowError(observer.options.throwOnError, [result.error])\n  ) {\n    throw result.error\n  }\n\n  return { ...result, mutate, mutateAsync: result.mutate }\n}\n"],"names":[],"mappings":";;;;AACA,YAAY,WAAW;;;AACvB;AAMA,SAAS,sBAAsB;;;;;AAUxB,SAAS,YAMd,OAAA,EACA,WAAA,EACwD;IACxD,MAAM,uMAAS,iBAAA,EAAe,WAAW;IAEzC,MAAM,CAAC,QAAQ,CAAA,GAAU,6KAAA;gCACvB,IACE,0LAAI,mBAAA,CACF,QACA;;sKAIA,YAAA;iCAAU,MAAM;YACpB,SAAS,UAAA,CAAW,OAAO;QAC7B;gCAAG;QAAC;QAAU,OAAO;KAAC;IAEtB,MAAM,UAAe,wLAAA,oKACb,cAAA;oDACJ,CAAC,gBACC,SAAS,SAAA,oLAAU,gBAAA,CAAc,UAAA,CAAW,aAAa,CAAC;mDAC5D;QAAC,QAAQ;KAAA;oDAEX,IAAM,SAAS,gBAAA,CAAiB;;oDAChC,IAAM,SAAS,gBAAA,CAAiB;;IAGlC,MAAM,2KAAe,cAAA;2CAGnB,CAAC,WAAW,kBAAkB;YAC5B,SAAS,MAAA,CAAO,WAAW,aAAa,EAAE,KAAA,4KAAM,OAAI;QACtD;0CACA;QAAC,QAAQ;KAAA;IAGX,IACE,OAAO,KAAA,IACP,kMAAA,EAAiB,SAAS,OAAA,CAAQ,YAAA,EAAc;QAAC,OAAO,KAAK;KAAC,GAC9D;QACA,MAAM,OAAO,KAAA;IACf;IAEA,OAAO;QAAE,GAAG,MAAA;QAAQ;QAAQ,aAAa,OAAO,MAAA;IAAO;AACzD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 9812, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40tanstack/react-query/src/usePrefetchInfiniteQuery.tsx"],"sourcesContent":["import { useQueryClient } from './QueryClientProvider'\nimport type {\n  DefaultError,\n  FetchInfiniteQueryOptions,\n  QueryClient,\n  QueryKey,\n} from '@tanstack/query-core'\n\nexport function usePrefetchInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: FetchInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n  queryClient?: QueryClient,\n) {\n  const client = useQueryClient(queryClient)\n\n  if (!client.getQueryState(options.queryKey)) {\n    client.prefetchInfiniteQuery(options)\n  }\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,sBAAsB;;AAQxB,SAAS,yBAOd,OAAA,EAOA,WAAA,EACA;IACA,MAAM,uMAAS,iBAAA,EAAe,WAAW;IAEzC,IAAI,CAAC,OAAO,aAAA,CAAc,QAAQ,QAAQ,GAAG;QAC3C,OAAO,qBAAA,CAAsB,OAAO;IACtC;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 9832, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40tanstack/react-query/src/usePrefetchQuery.tsx"],"sourcesContent":["import { useQueryClient } from './QueryClientProvider'\nimport type { DefaultError, QueryClient, QueryKey } from '@tanstack/query-core'\nimport type { UsePrefetchQueryOptions } from './types'\n\nexport function usePrefetchQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UsePrefetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n) {\n  const client = useQueryClient(queryClient)\n\n  if (!client.getQueryState(options.queryKey)) {\n    client.prefetchQuery(options)\n  }\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,sBAAsB;;AAIxB,SAAS,iBAMd,OAAA,EACA,WAAA,EACA;IACA,MAAM,uMAAS,iBAAA,EAAe,WAAW;IAEzC,IAAI,CAAC,OAAO,aAAA,CAAc,QAAQ,QAAQ,GAAG;QAC3C,OAAO,aAAA,CAAc,OAAO;IAC9B;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 9852, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40tanstack/query-core/src/queriesObserver.ts"],"sourcesContent":["import { notifyManager } from './notifyManager'\nimport { QueryObserver } from './queryObserver'\nimport { Subscribable } from './subscribable'\nimport { replaceEqualDeep } from './utils'\nimport type {\n  DefaultedQueryObserverOptions,\n  QueryObserverOptions,\n  QueryObserverResult,\n} from './types'\nimport type { QueryClient } from './queryClient'\n\nfunction difference<T>(array1: Array<T>, array2: Array<T>): Array<T> {\n  const excludeSet = new Set(array2)\n  return array1.filter((x) => !excludeSet.has(x))\n}\n\nfunction replaceAt<T>(array: Array<T>, index: number, value: T): Array<T> {\n  const copy = array.slice(0)\n  copy[index] = value\n  return copy\n}\n\ntype QueriesObserverListener = (result: Array<QueryObserverResult>) => void\n\ntype CombineFn<TCombinedResult> = (\n  result: Array<QueryObserverResult>,\n) => TCombinedResult\n\nexport interface QueriesObserverOptions<\n  TCombinedResult = Array<QueryObserverResult>,\n> {\n  combine?: CombineFn<TCombinedResult>\n}\n\nexport class QueriesObserver<\n  TCombinedResult = Array<QueryObserverResult>,\n> extends Subscribable<QueriesObserverListener> {\n  #client: QueryClient\n  #result!: Array<QueryObserverResult>\n  #queries: Array<QueryObserverOptions>\n  #options?: QueriesObserverOptions<TCombinedResult>\n  #observers: Array<QueryObserver>\n  #combinedResult?: TCombinedResult\n  #lastCombine?: CombineFn<TCombinedResult>\n  #lastResult?: Array<QueryObserverResult>\n  #observerMatches: Array<QueryObserverMatch> = []\n\n  constructor(\n    client: QueryClient,\n    queries: Array<QueryObserverOptions<any, any, any, any, any>>,\n    options?: QueriesObserverOptions<TCombinedResult>,\n  ) {\n    super()\n\n    this.#client = client\n    this.#options = options\n    this.#queries = []\n    this.#observers = []\n    this.#result = []\n\n    this.setQueries(queries)\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.size === 1) {\n      this.#observers.forEach((observer) => {\n        observer.subscribe((result) => {\n          this.#onUpdate(observer, result)\n        })\n      })\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.listeners.size) {\n      this.destroy()\n    }\n  }\n\n  destroy(): void {\n    this.listeners = new Set()\n    this.#observers.forEach((observer) => {\n      observer.destroy()\n    })\n  }\n\n  setQueries(\n    queries: Array<QueryObserverOptions>,\n    options?: QueriesObserverOptions<TCombinedResult>,\n  ): void {\n    this.#queries = queries\n    this.#options = options\n\n    if (process.env.NODE_ENV !== 'production') {\n      const queryHashes = queries.map(\n        (query) => this.#client.defaultQueryOptions(query).queryHash,\n      )\n      if (new Set(queryHashes).size !== queryHashes.length) {\n        console.warn(\n          '[QueriesObserver]: Duplicate Queries found. This might result in unexpected behavior.',\n        )\n      }\n    }\n\n    notifyManager.batch(() => {\n      const prevObservers = this.#observers\n\n      const newObserverMatches = this.#findMatchingObservers(this.#queries)\n      this.#observerMatches = newObserverMatches\n\n      // set options for the new observers to notify of changes\n      newObserverMatches.forEach((match) =>\n        match.observer.setOptions(match.defaultedQueryOptions),\n      )\n\n      const newObservers = newObserverMatches.map((match) => match.observer)\n      const newResult = newObservers.map((observer) =>\n        observer.getCurrentResult(),\n      )\n\n      const hasIndexChange = newObservers.some(\n        (observer, index) => observer !== prevObservers[index],\n      )\n\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return\n      }\n\n      this.#observers = newObservers\n      this.#result = newResult\n\n      if (!this.hasListeners()) {\n        return\n      }\n\n      difference(prevObservers, newObservers).forEach((observer) => {\n        observer.destroy()\n      })\n\n      difference(newObservers, prevObservers).forEach((observer) => {\n        observer.subscribe((result) => {\n          this.#onUpdate(observer, result)\n        })\n      })\n\n      this.#notify()\n    })\n  }\n\n  getCurrentResult(): Array<QueryObserverResult> {\n    return this.#result\n  }\n\n  getQueries() {\n    return this.#observers.map((observer) => observer.getCurrentQuery())\n  }\n\n  getObservers() {\n    return this.#observers\n  }\n\n  getOptimisticResult(\n    queries: Array<QueryObserverOptions>,\n    combine: CombineFn<TCombinedResult> | undefined,\n  ): [\n    rawResult: Array<QueryObserverResult>,\n    combineResult: (r?: Array<QueryObserverResult>) => TCombinedResult,\n    trackResult: () => Array<QueryObserverResult>,\n  ] {\n    const matches = this.#findMatchingObservers(queries)\n    const result = matches.map((match) =>\n      match.observer.getOptimisticResult(match.defaultedQueryOptions),\n    )\n\n    return [\n      result,\n      (r?: Array<QueryObserverResult>) => {\n        return this.#combineResult(r ?? result, combine)\n      },\n      () => {\n        return this.#trackResult(result, matches)\n      },\n    ]\n  }\n\n  #trackResult(\n    result: Array<QueryObserverResult>,\n    matches: Array<QueryObserverMatch>,\n  ) {\n    return matches.map((match, index) => {\n      const observerResult = result[index]!\n      return !match.defaultedQueryOptions.notifyOnChangeProps\n        ? match.observer.trackResult(observerResult, (accessedProp) => {\n            // track property on all observers to ensure proper (synchronized) tracking (#7000)\n            matches.forEach((m) => {\n              m.observer.trackProp(accessedProp)\n            })\n          })\n        : observerResult\n    })\n  }\n\n  #combineResult(\n    input: Array<QueryObserverResult>,\n    combine: CombineFn<TCombinedResult> | undefined,\n  ): TCombinedResult {\n    if (combine) {\n      if (\n        !this.#combinedResult ||\n        this.#result !== this.#lastResult ||\n        combine !== this.#lastCombine\n      ) {\n        this.#lastCombine = combine\n        this.#lastResult = this.#result\n        this.#combinedResult = replaceEqualDeep(\n          this.#combinedResult,\n          combine(input),\n        )\n      }\n\n      return this.#combinedResult\n    }\n    return input as any\n  }\n\n  #findMatchingObservers(\n    queries: Array<QueryObserverOptions>,\n  ): Array<QueryObserverMatch> {\n    const prevObserversMap = new Map(\n      this.#observers.map((observer) => [observer.options.queryHash, observer]),\n    )\n\n    const observers: Array<QueryObserverMatch> = []\n\n    queries.forEach((options) => {\n      const defaultedOptions = this.#client.defaultQueryOptions(options)\n      const match = prevObserversMap.get(defaultedOptions.queryHash)\n      if (match) {\n        observers.push({\n          defaultedQueryOptions: defaultedOptions,\n          observer: match,\n        })\n      } else {\n        observers.push({\n          defaultedQueryOptions: defaultedOptions,\n          observer: new QueryObserver(this.#client, defaultedOptions),\n        })\n      }\n    })\n\n    return observers\n  }\n\n  #onUpdate(observer: QueryObserver, result: QueryObserverResult): void {\n    const index = this.#observers.indexOf(observer)\n    if (index !== -1) {\n      this.#result = replaceAt(this.#result, index, result)\n      this.#notify()\n    }\n  }\n\n  #notify(): void {\n    if (this.hasListeners()) {\n      const previousResult = this.#combinedResult\n      const newTracked = this.#trackResult(this.#result, this.#observerMatches)\n      const newResult = this.#combineResult(newTracked, this.#options?.combine)\n\n      if (previousResult !== newResult) {\n        notifyManager.batch(() => {\n          this.listeners.forEach((listener) => {\n            listener(this.#result)\n          })\n        })\n      }\n    }\n  }\n}\n\ntype QueryObserverMatch = {\n  defaultedQueryOptions: DefaultedQueryObserverOptions\n  observer: QueryObserver\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 10045, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40tanstack/react-query/src/useQueries.ts"],"sourcesContent":["'use client'\nimport * as React from 'react'\n\nimport {\n  QueriesObserver,\n  QueryObserver,\n  noop,\n  notifyManager,\n} from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport { useIsRestoring } from './IsRestoringProvider'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport {\n  ensureSuspenseTimers,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch,\n} from './suspense'\nimport type {\n  DefinedUseQueryResult,\n  UseQueryOptions,\n  UseQueryResult,\n} from './types'\nimport type {\n  DefaultError,\n  OmitKeyof,\n  QueriesObserverOptions,\n  QueriesPlaceholderDataFunction,\n  QueryClient,\n  QueryFunction,\n  QueryKey,\n  QueryObserverOptions,\n  ThrowOnError,\n} from '@tanstack/query-core'\n\n// This defines the `UseQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.\n// `placeholderData` function always gets undefined passed\ntype UseQueryOptionsForUseQueries<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = OmitKeyof<\n  UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  'placeholderData' | 'subscribed'\n> & {\n  placeholderData?: TQueryFnData | QueriesPlaceholderDataFunction<TQueryFnData>\n}\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\n// Widen the type of the symbol to enable type inference even if skipToken is not immutable.\ntype SkipTokenForUseQueries = symbol\n\ntype GetUseQueryOptionsForUseQueries<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n      ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n      : T extends { data: infer TData; error?: infer TError }\n        ? UseQueryOptionsForUseQueries<unknown, TError, TData>\n        : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n          T extends [infer TQueryFnData, infer TError, infer TData]\n          ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n          : T extends [infer TQueryFnData, infer TError]\n            ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n            : T extends [infer TQueryFnData]\n              ? UseQueryOptionsForUseQueries<TQueryFnData>\n              : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n                T extends {\n                    queryFn?:\n                      | QueryFunction<infer TQueryFnData, infer TQueryKey>\n                      | SkipTokenForUseQueries\n                    select?: (data: any) => infer TData\n                    throwOnError?: ThrowOnError<any, infer TError, any, any>\n                  }\n                ? UseQueryOptionsForUseQueries<\n                    TQueryFnData,\n                    unknown extends TError ? DefaultError : TError,\n                    unknown extends TData ? TQueryFnData : TData,\n                    TQueryKey\n                  >\n                : // Fallback\n                  UseQueryOptionsForUseQueries\n\n// A defined initialData setting should return a DefinedUseQueryResult rather than UseQueryResult\ntype GetDefinedOrUndefinedQueryResult<T, TData, TError = unknown> = T extends {\n  initialData?: infer TInitialData\n}\n  ? unknown extends TInitialData\n    ? UseQueryResult<TData, TError>\n    : TInitialData extends TData\n      ? DefinedUseQueryResult<TData, TError>\n      : TInitialData extends () => infer TInitialDataResult\n        ? unknown extends TInitialDataResult\n          ? UseQueryResult<TData, TError>\n          : TInitialDataResult extends TData\n            ? DefinedUseQueryResult<TData, TError>\n            : UseQueryResult<TData, TError>\n        : UseQueryResult<TData, TError>\n  : UseQueryResult<TData, TError>\n\ntype GetUseQueryResult<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n      ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData, TError>\n      : T extends { data: infer TData; error?: infer TError }\n        ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n        : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n          T extends [any, infer TError, infer TData]\n          ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n          : T extends [infer TQueryFnData, infer TError]\n            ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData, TError>\n            : T extends [infer TQueryFnData]\n              ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData>\n              : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n                T extends {\n                    queryFn?:\n                      | QueryFunction<infer TQueryFnData, any>\n                      | SkipTokenForUseQueries\n                    select?: (data: any) => infer TData\n                    throwOnError?: ThrowOnError<any, infer TError, any, any>\n                  }\n                ? GetDefinedOrUndefinedQueryResult<\n                    T,\n                    unknown extends TData ? TQueryFnData : TData,\n                    unknown extends TError ? DefaultError : TError\n                  >\n                : // Fallback\n                  UseQueryResult\n\n/**\n * QueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type QueriesOptions<\n  T extends Array<any>,\n  TResults extends Array<any> = [],\n  TDepth extends ReadonlyArray<number> = [],\n> = TDepth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseQueryOptionsForUseQueries>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...TResults, GetUseQueryOptionsForUseQueries<Head>]\n      : T extends [infer Head, ...infer Tails]\n        ? QueriesOptions<\n            [...Tails],\n            [...TResults, GetUseQueryOptionsForUseQueries<Head>],\n            [...TDepth, 1]\n          >\n        : ReadonlyArray<unknown> extends T\n          ? T\n          : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n            // use this to infer the param types in the case of Array.map() argument\n            T extends Array<\n                UseQueryOptionsForUseQueries<\n                  infer TQueryFnData,\n                  infer TError,\n                  infer TData,\n                  infer TQueryKey\n                >\n              >\n            ? Array<\n                UseQueryOptionsForUseQueries<\n                  TQueryFnData,\n                  TError,\n                  TData,\n                  TQueryKey\n                >\n              >\n            : // Fallback\n              Array<UseQueryOptionsForUseQueries>\n\n/**\n * QueriesResults reducer recursively maps type param to results\n */\nexport type QueriesResults<\n  T extends Array<any>,\n  TResults extends Array<any> = [],\n  TDepth extends ReadonlyArray<number> = [],\n> = TDepth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseQueryResult>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...TResults, GetUseQueryResult<Head>]\n      : T extends [infer Head, ...infer Tails]\n        ? QueriesResults<\n            [...Tails],\n            [...TResults, GetUseQueryResult<Head>],\n            [...TDepth, 1]\n          >\n        : { [K in keyof T]: GetUseQueryResult<T[K]> }\n\nexport function useQueries<\n  T extends Array<any>,\n  TCombinedResult = QueriesResults<T>,\n>(\n  {\n    queries,\n    ...options\n  }: {\n    queries:\n      | readonly [...QueriesOptions<T>]\n      | readonly [...{ [K in keyof T]: GetUseQueryOptionsForUseQueries<T[K]> }]\n    combine?: (result: QueriesResults<T>) => TCombinedResult\n    subscribed?: boolean\n  },\n  queryClient?: QueryClient,\n): TCombinedResult {\n  const client = useQueryClient(queryClient)\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n\n  const defaultedQueries = React.useMemo(\n    () =>\n      queries.map((opts) => {\n        const defaultedOptions = client.defaultQueryOptions(\n          opts as QueryObserverOptions,\n        )\n\n        // Make sure the results are already in fetching state before subscribing or updating options\n        defaultedOptions._optimisticResults = isRestoring\n          ? 'isRestoring'\n          : 'optimistic'\n\n        return defaultedOptions\n      }),\n    [queries, client, isRestoring],\n  )\n\n  defaultedQueries.forEach((query) => {\n    ensureSuspenseTimers(query)\n    ensurePreventErrorBoundaryRetry(query, errorResetBoundary)\n  })\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  const [observer] = React.useState(\n    () =>\n      new QueriesObserver<TCombinedResult>(\n        client,\n        defaultedQueries,\n        options as QueriesObserverOptions<TCombinedResult>,\n      ),\n  )\n\n  // note: this must be called before useSyncExternalStore\n  const [optimisticResult, getCombinedResult, trackResult] =\n    observer.getOptimisticResult(\n      defaultedQueries,\n      (options as QueriesObserverOptions<TCombinedResult>).combine,\n    )\n\n  const shouldSubscribe = !isRestoring && options.subscribed !== false\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        shouldSubscribe\n          ? observer.subscribe(notifyManager.batchCalls(onStoreChange))\n          : noop,\n      [observer, shouldSubscribe],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    observer.setQueries(\n      defaultedQueries,\n      options as QueriesObserverOptions<TCombinedResult>,\n    )\n  }, [defaultedQueries, options, observer])\n\n  const shouldAtLeastOneSuspend = optimisticResult.some((result, index) =>\n    shouldSuspend(defaultedQueries[index], result),\n  )\n\n  const suspensePromises = shouldAtLeastOneSuspend\n    ? optimisticResult.flatMap((result, index) => {\n        const opts = defaultedQueries[index]\n\n        if (opts) {\n          const queryObserver = new QueryObserver(client, opts)\n          if (shouldSuspend(opts, result)) {\n            return fetchOptimistic(opts, queryObserver, errorResetBoundary)\n          } else if (willFetch(result, isRestoring)) {\n            void fetchOptimistic(opts, queryObserver, errorResetBoundary)\n          }\n        }\n        return []\n      })\n    : []\n\n  if (suspensePromises.length > 0) {\n    throw Promise.all(suspensePromises)\n  }\n  const firstSingleResultWhichShouldThrow = optimisticResult.find(\n    (result, index) => {\n      const query = defaultedQueries[index]\n      return (\n        query &&\n        getHasError({\n          result,\n          errorResetBoundary,\n          throwOnError: query.throwOnError,\n          query: client.getQueryCache().get(query.queryHash),\n          suspense: query.suspense,\n        })\n      )\n    },\n  )\n\n  if (firstSingleResultWhichShouldThrow?.error) {\n    throw firstSingleResultWhichShouldThrow.error\n  }\n\n  return getCombinedResult(trackResult())\n}\n"],"names":[],"mappings":";;;;AACA,YAAY,WAAW;AAEvB;;;;AAMA,SAAS,sBAAsB;AAC/B,SAAS,sBAAsB;AAC/B,SAAS,kCAAkC;AAC3C;AAKA;;;;;;;;;AA8LO,SAAS,WAId,EACE,OAAA,EACA,GAAG,SACL,EAOA,WAAA,EACiB;IACjB,MAAM,uMAAS,iBAAA,EAAe,WAAW;IACzC,MAAM,2MAAc,kBAAA,CAAe;IACnC,MAAM,uNAAqB,6BAAA,CAA2B;IAEtD,MAAM,qLAAyB,UAAA;gDAC7B,IACE,QAAQ,GAAA;wDAAI,CAAC,SAAS;oBACpB,MAAM,mBAAmB,OAAO,mBAAA,CAC9B;oBAIF,iBAAiB,kBAAA,GAAqB,cAClC,gBACA;oBAEJ,OAAO;gBACT,CAAC;;+CACH;QAAC;QAAS;QAAQ,WAAW;KAAA;IAG/B,iBAAiB,OAAA,CAAQ,CAAC,UAAU;QAClC,CAAA,GAAA,8KAAA,CAAA,uBAAA,EAAqB,KAAK;QAC1B,CAAA,GAAA,wLAAA,CAAA,kCAAA,EAAgC,OAAO,kBAAkB;IAC3D,CAAC;IAED,CAAA,GAAA,wLAAA,CAAA,6BAAA,EAA2B,kBAAkB;IAE7C,MAAM,CAAC,QAAQ,CAAA,IAAU,4KAAA;+BACvB,IACE,yLAAI,kBAAA,CACF,QACA,kBACA;;IAKN,MAAM,CAAC,kBAAkB,mBAAmB,WAAW,CAAA,GACrD,SAAS,mBAAA,CACP,kBACC,QAAoD,OAAA;IAGzD,MAAM,kBAAkB,CAAC,eAAe,QAAQ,UAAA,KAAe;sKACzD,uBAAA,oKACE,cAAA;uDACJ,CAAC,gBACC,kBACI,SAAS,SAAA,oLAAU,gBAAA,CAAc,UAAA,CAAW,aAAa,CAAC,+KAC1D,OAAA;sDACN;QAAC;QAAU,eAAe;KAAA;2CAE5B,IAAM,SAAS,gBAAA,CAAiB;;2CAChC,IAAM,SAAS,gBAAA,CAAiB;;sKAG5B,YAAA;gCAAU,MAAM;YACpB,SAAS,UAAA,CACP,kBACA;QAEJ;+BAAG;QAAC;QAAkB;QAAS,QAAQ;KAAC;IAExC,MAAM,0BAA0B,iBAAiB,IAAA,CAAK,CAAC,QAAQ,2LAC7D,gBAAA,EAAc,gBAAA,CAAiB,KAAK,CAAA,EAAG,MAAM;IAG/C,MAAM,mBAAmB,0BACrB,iBAAiB,OAAA,CAAQ,CAAC,QAAQ,UAAU;QAC1C,MAAM,OAAO,gBAAA,CAAiB,KAAK,CAAA;QAEnC,IAAI,MAAM;YACR,MAAM,gBAAgB,uLAAI,gBAAA,CAAc,QAAQ,IAAI;YACpD,KAAI,kMAAA,EAAc,MAAM,MAAM,GAAG;gBAC/B,0LAAO,kBAAA,EAAgB,MAAM,eAAe,kBAAkB;YAChE,OAAA,IAAW,+LAAA,EAAU,QAAQ,WAAW,GAAG;gBACzC,wLAAK,kBAAA,EAAgB,MAAM,eAAe,kBAAkB;YAC9D;QACF;QACA,OAAO,CAAC,CAAA;IACV,CAAC,IACD,CAAC,CAAA;IAEL,IAAI,iBAAiB,MAAA,GAAS,GAAG;QAC/B,MAAM,QAAQ,GAAA,CAAI,gBAAgB;IACpC;IACA,MAAM,oCAAoC,iBAAiB,IAAA,CACzD,CAAC,QAAQ,UAAU;QACjB,MAAM,QAAQ,gBAAA,CAAiB,KAAK,CAAA;QACpC,OACE,sMACA,cAAA,EAAY;YACV;YACA;YACA,cAAc,MAAM,YAAA;YACpB,OAAO,OAAO,aAAA,CAAc,EAAE,GAAA,CAAI,MAAM,SAAS;YACjD,UAAU,MAAM,QAAA;QAClB,CAAC;IAEL;IAGF,IAAI,mCAAmC,OAAO;QAC5C,MAAM,kCAAkC,KAAA;IAC1C;IAEA,OAAO,kBAAkB,YAAY,CAAC;AACxC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 10152, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40tanstack/react-query/src/useQuery.ts"],"sourcesContent":["'use client'\nimport { QueryObserver } from '@tanstack/query-core'\nimport { useBaseQuery } from './useBaseQuery'\nimport type {\n  DefaultError,\n  NoInfer,\n  QueryClient,\n  QueryKey,\n} from '@tanstack/query-core'\nimport type {\n  DefinedUseQueryResult,\n  UseQueryOptions,\n  UseQueryResult,\n} from './types'\nimport type {\n  DefinedInitialDataOptions,\n  UndefinedInitialDataOptions,\n} from './queryOptions'\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n): DefinedUseQueryResult<NoInfer<TData>, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n): UseQueryResult<NoInfer<TData>, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n): UseQueryResult<NoInfer<TData>, TError>\n\nexport function useQuery(options: UseQueryOptions, queryClient?: QueryClient) {\n  return useBaseQuery(options, QueryObserver, queryClient)\n}\n"],"names":[],"mappings":";;;;AACA,SAAS,qBAAqB;AAC9B,SAAS,oBAAoB;;;;AA+CtB,SAAS,SAAS,OAAA,EAA0B,WAAA,EAA2B;IAC5E,8LAAO,eAAA,EAAa,4LAAS,gBAAA,EAAe,WAAW;AACzD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 10172, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40tanstack/react-query/src/useSuspenseInfiniteQuery.ts"],"sourcesContent":["'use client'\nimport { InfiniteQueryObserver, skipToken } from '@tanstack/query-core'\nimport { useBaseQuery } from './useBaseQuery'\nimport { defaultThrowOnError } from './suspense'\nimport type {\n  DefaultError,\n  InfiniteData,\n  InfiniteQueryObserverSuccessResult,\n  QueryClient,\n  QueryKey,\n  QueryObserver,\n} from '@tanstack/query-core'\nimport type {\n  UseSuspenseInfiniteQueryOptions,\n  UseSuspenseInfiniteQueryResult,\n} from './types'\n\nexport function useSuspenseInfiniteQuery<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: UseSuspenseInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n  queryClient?: QueryClient,\n): UseSuspenseInfiniteQueryResult<TData, TError> {\n  if (process.env.NODE_ENV !== 'production') {\n    if ((options.queryFn as any) === skipToken) {\n      console.error('skipToken is not allowed for useSuspenseInfiniteQuery')\n    }\n  }\n\n  return useBaseQuery(\n    {\n      ...options,\n      enabled: true,\n      suspense: true,\n      throwOnError: defaultThrowOnError,\n    },\n    InfiniteQueryObserver as typeof QueryObserver,\n    queryClient,\n  ) as InfiniteQueryObserverSuccessResult<TData, TError>\n}\n"],"names":[],"mappings":";;;AAiCM,QAAQ,IAAI,aAAa;;;AAhC/B,SAAS,uBAAuB,iBAAiB;AACjD,SAAS,oBAAoB;AAC7B,SAAS,2BAA2B;;;;;AAc7B,SAAS,yBAOd,OAAA,EAOA,WAAA,EAC+C;IAC/C,wCAA2C;QACzC,IAAK,QAAQ,OAAA,gLAAoB,YAAA,EAAW;YAC1C,QAAQ,KAAA,CAAM,uDAAuD;QACvE;IACF;IAEA,8LAAO,eAAA,EACL;QACE,GAAG,OAAA;QACH,SAAS;QACT,UAAU;QACV,6LAAc,sBAAA;IAChB,8LACA,wBAAA,EACA;AAEJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 10206, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40tanstack/react-query/src/useSuspenseQueries.ts"],"sourcesContent":["'use client'\nimport { skipToken } from '@tanstack/query-core'\nimport { useQueries } from './useQueries'\nimport { defaultThrowOnError } from './suspense'\nimport type { UseSuspenseQueryOptions, UseSuspenseQueryResult } from './types'\nimport type {\n  DefaultError,\n  QueryClient,\n  QueryFunction,\n  ThrowOnError,\n} from '@tanstack/query-core'\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\n// Widen the type of the symbol to enable type inference even if skipToken is not immutable.\ntype SkipTokenForUseQueries = symbol\n\ntype GetUseSuspenseQueryOptions<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseSuspenseQueryOptions<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n      ? UseSuspenseQueryOptions<TQueryFnData, TError>\n      : T extends { data: infer TData; error?: infer TError }\n        ? UseSuspenseQueryOptions<unknown, TError, TData>\n        : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n          T extends [infer TQueryFnData, infer TError, infer TData]\n          ? UseSuspenseQueryOptions<TQueryFnData, TError, TData>\n          : T extends [infer TQueryFnData, infer TError]\n            ? UseSuspenseQueryOptions<TQueryFnData, TError>\n            : T extends [infer TQueryFnData]\n              ? UseSuspenseQueryOptions<TQueryFnData>\n              : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n                T extends {\n                    queryFn?:\n                      | QueryFunction<infer TQueryFnData, infer TQueryKey>\n                      | SkipTokenForUseQueries\n                    select?: (data: any) => infer TData\n                    throwOnError?: ThrowOnError<any, infer TError, any, any>\n                  }\n                ? UseSuspenseQueryOptions<\n                    TQueryFnData,\n                    TError,\n                    TData,\n                    TQueryKey\n                  >\n                : T extends {\n                      queryFn?:\n                        | QueryFunction<infer TQueryFnData, infer TQueryKey>\n                        | SkipTokenForUseQueries\n                      throwOnError?: ThrowOnError<any, infer TError, any, any>\n                    }\n                  ? UseSuspenseQueryOptions<\n                      TQueryFnData,\n                      TError,\n                      TQueryFnData,\n                      TQueryKey\n                    >\n                  : // Fallback\n                    UseSuspenseQueryOptions\n\ntype GetUseSuspenseQueryResult<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? UseSuspenseQueryResult<TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n      ? UseSuspenseQueryResult<TQueryFnData, TError>\n      : T extends { data: infer TData; error?: infer TError }\n        ? UseSuspenseQueryResult<TData, TError>\n        : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n          T extends [any, infer TError, infer TData]\n          ? UseSuspenseQueryResult<TData, TError>\n          : T extends [infer TQueryFnData, infer TError]\n            ? UseSuspenseQueryResult<TQueryFnData, TError>\n            : T extends [infer TQueryFnData]\n              ? UseSuspenseQueryResult<TQueryFnData>\n              : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n                T extends {\n                    queryFn?:\n                      | QueryFunction<infer TQueryFnData, any>\n                      | SkipTokenForUseQueries\n                    select?: (data: any) => infer TData\n                    throwOnError?: ThrowOnError<any, infer TError, any, any>\n                  }\n                ? UseSuspenseQueryResult<\n                    unknown extends TData ? TQueryFnData : TData,\n                    unknown extends TError ? DefaultError : TError\n                  >\n                : T extends {\n                      queryFn?:\n                        | QueryFunction<infer TQueryFnData, any>\n                        | SkipTokenForUseQueries\n                      throwOnError?: ThrowOnError<any, infer TError, any, any>\n                    }\n                  ? UseSuspenseQueryResult<\n                      TQueryFnData,\n                      unknown extends TError ? DefaultError : TError\n                    >\n                  : // Fallback\n                    UseSuspenseQueryResult\n\n/**\n * SuspenseQueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type SuspenseQueriesOptions<\n  T extends Array<any>,\n  TResults extends Array<any> = [],\n  TDepth extends ReadonlyArray<number> = [],\n> = TDepth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseSuspenseQueryOptions>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...TResults, GetUseSuspenseQueryOptions<Head>]\n      : T extends [infer Head, ...infer Tails]\n        ? SuspenseQueriesOptions<\n            [...Tails],\n            [...TResults, GetUseSuspenseQueryOptions<Head>],\n            [...TDepth, 1]\n          >\n        : Array<unknown> extends T\n          ? T\n          : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n            // use this to infer the param types in the case of Array.map() argument\n            T extends Array<\n                UseSuspenseQueryOptions<\n                  infer TQueryFnData,\n                  infer TError,\n                  infer TData,\n                  infer TQueryKey\n                >\n              >\n            ? Array<\n                UseSuspenseQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n              >\n            : // Fallback\n              Array<UseSuspenseQueryOptions>\n\n/**\n * SuspenseQueriesResults reducer recursively maps type param to results\n */\nexport type SuspenseQueriesResults<\n  T extends Array<any>,\n  TResults extends Array<any> = [],\n  TDepth extends ReadonlyArray<number> = [],\n> = TDepth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseSuspenseQueryResult>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...TResults, GetUseSuspenseQueryResult<Head>]\n      : T extends [infer Head, ...infer Tails]\n        ? SuspenseQueriesResults<\n            [...Tails],\n            [...TResults, GetUseSuspenseQueryResult<Head>],\n            [...TDepth, 1]\n          >\n        : { [K in keyof T]: GetUseSuspenseQueryResult<T[K]> }\n\nexport function useSuspenseQueries<\n  T extends Array<any>,\n  TCombinedResult = SuspenseQueriesResults<T>,\n>(\n  options: {\n    queries:\n      | readonly [...SuspenseQueriesOptions<T>]\n      | readonly [...{ [K in keyof T]: GetUseSuspenseQueryOptions<T[K]> }]\n    combine?: (result: SuspenseQueriesResults<T>) => TCombinedResult\n  },\n  queryClient?: QueryClient,\n): TCombinedResult\n\nexport function useSuspenseQueries<\n  T extends Array<any>,\n  TCombinedResult = SuspenseQueriesResults<T>,\n>(\n  options: {\n    queries: readonly [...SuspenseQueriesOptions<T>]\n    combine?: (result: SuspenseQueriesResults<T>) => TCombinedResult\n  },\n  queryClient?: QueryClient,\n): TCombinedResult\n\nexport function useSuspenseQueries(options: any, queryClient?: QueryClient) {\n  return useQueries(\n    {\n      ...options,\n      queries: options.queries.map((query: any) => {\n        if (process.env.NODE_ENV !== 'production') {\n          if (query.queryFn === skipToken) {\n            console.error('skipToken is not allowed for useSuspenseQueries')\n          }\n        }\n\n        return {\n          ...query,\n          suspense: true,\n          throwOnError: defaultThrowOnError,\n          enabled: true,\n          placeholderData: undefined,\n        }\n      }),\n    },\n    queryClient,\n  )\n}\n"],"names":[],"mappings":";;;AAiMY,QAAQ,IAAI,aAAa;;AAhMrC,SAAS,iBAAiB;AAC1B,SAAS,kBAAkB;AAC3B,SAAS,2BAA2B;;;;;AAyL7B,SAAS,mBAAmB,OAAA,EAAc,WAAA,EAA2B;IAC1E,4LAAO,aAAA,EACL;QACE,GAAG,OAAA;QACH,SAAS,QAAQ,OAAA,CAAQ,GAAA;6CAAI,CAAC,UAAe;gBAC3C,wCAA2C;oBACzC,IAAI,MAAM,OAAA,KAAY,uLAAA,EAAW;wBAC/B,QAAQ,KAAA,CAAM,iDAAiD;oBACjE;gBACF;gBAEA,OAAO;oBACL,GAAG,KAAA;oBACH,UAAU;oBACV,6LAAc,sBAAA;oBACd,SAAS;oBACT,iBAAiB,KAAA;gBACnB;YACF,CAAC;;IACH,GACA;AAEJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 10247, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40tanstack/react-query/src/useSuspenseQuery.ts"],"sourcesContent":["'use client'\nimport { QueryObserver, skipToken } from '@tanstack/query-core'\nimport { useBaseQuery } from './useBaseQuery'\nimport { defaultThrowOnError } from './suspense'\nimport type { UseSuspenseQueryOptions, UseSuspenseQueryResult } from './types'\nimport type { DefaultError, QueryClient, QueryKey } from '@tanstack/query-core'\n\nexport function useSuspenseQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseSuspenseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n): UseSuspenseQueryResult<TData, TError> {\n  if (process.env.NODE_ENV !== 'production') {\n    if ((options.queryFn as any) === skipToken) {\n      console.error('skipToken is not allowed for useSuspenseQuery')\n    }\n  }\n\n  return useBaseQuery(\n    {\n      ...options,\n      enabled: true,\n      suspense: true,\n      throwOnError: defaultThrowOnError,\n      placeholderData: undefined,\n    },\n    QueryObserver,\n    queryClient,\n  ) as UseSuspenseQueryResult<TData, TError>\n}\n"],"names":[],"mappings":";;;AAgBM,QAAQ,IAAI,aAAa;;;AAf/B,SAAS,eAAe,iBAAiB;AACzC,SAAS,oBAAoB;AAC7B,SAAS,2BAA2B;;;;;AAI7B,SAAS,iBAMd,OAAA,EACA,WAAA,EACuC;IACvC,wCAA2C;QACzC,IAAK,QAAQ,OAAA,gLAAoB,YAAA,EAAW;YAC1C,QAAQ,KAAA,CAAM,+CAA+C;QAC/D;IACF;IAEA,8LAAO,eAAA,EACL;QACE,GAAG,OAAA;QACH,SAAS;QACT,UAAU;QACV,6LAAc,sBAAA;QACd,iBAAiB,KAAA;IACnB,sLACA,gBAAA,EACA;AAEJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 10282, "column": 0}, "map": {"version":3,"file":"shared-JtnEvJvB.mjs","sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/react-query/src/shared/proxy/decorationProxy.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/react-query/src/internals/context.tsx","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/react-query/src/shared/proxy/utilsProxy.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/react-query/src/shared/proxy/useQueriesProxy.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/react-query/src/internals/getClientArgs.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/asyncIterator.js","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/react-query/src/internals/trpcResult.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/react-query/src/utils/createUtilityFunctions.ts","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/react-query/src/shared/hooks/createHooksInternal.tsx","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/react-query/src/shared/queryClient.ts"],"sourcesContent":["import type { AnyRouter } from '@trpc/server/unstable-core-do-not-import';\nimport { createRecursiveProxy } from '@trpc/server/unstable-core-do-not-import';\nimport type { CreateReactQueryHooks } from '../hooks/createHooksInternal';\n\n/**\n * Create proxy for decorating procedures\n * @internal\n */\nexport function createReactDecoration<\n  TRouter extends AnyRouter,\n  TSSRContext = unknown,\n>(hooks: CreateReactQueryHooks<TRouter, TSSRContext>) {\n  return createRecursiveProxy(({ path, args }) => {\n    const pathCopy = [...path];\n\n    // The last arg is for instance `.useMutation` or `.useQuery()`\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const lastArg = pathCopy.pop()!;\n\n    if (lastArg === 'useMutation') {\n      return (hooks as any)[lastArg](pathCopy, ...args);\n    }\n\n    if (lastArg === '_def') {\n      return {\n        path: pathCopy,\n      };\n    }\n\n    const [input, ...rest] = args;\n    const opts = rest[0] ?? {};\n\n    return (hooks as any)[lastArg](pathCopy, input, opts);\n  });\n}\n","import type {\n  CancelOptions,\n  FetchInfiniteQueryOptions,\n  FetchQueryOptions,\n  InfiniteData,\n  InvalidateOptions,\n  InvalidateQueryFilters,\n  MutationOptions,\n  QueryClient,\n  QueryFilters,\n  QueryKey,\n  RefetchOptions,\n  RefetchQueryFilters,\n  ResetOptions,\n  SetDataOptions,\n  Updater,\n} from '@tanstack/react-query';\nimport type {\n  TRPCClient,\n  TRPCClientError,\n  TRPCRequestOptions,\n  TRPCUntypedClient,\n} from '@trpc/client';\nimport type {\n  AnyClientTypes,\n  AnyRouter,\n  DistributiveOmit,\n} from '@trpc/server/unstable-core-do-not-import';\nimport * as React from 'react';\nimport type {\n  DefinedTRPCInfiniteQueryOptionsIn,\n  DefinedTRPCInfiniteQueryOptionsOut,\n  DefinedTRPCQueryOptionsIn,\n  DefinedTRPCQueryOptionsOut,\n  ExtractCursorType,\n  UndefinedTRPCInfiniteQueryOptionsIn,\n  UndefinedTRPCInfiniteQueryOptionsOut,\n  UndefinedTRPCQueryOptionsIn,\n  UndefinedTRPCQueryOptionsOut,\n} from '../shared';\nimport type { TRPCMutationKey, TRPCQueryKey } from './getQueryKey';\n\ninterface TRPCUseUtilsOptions {\n  /**\n   * tRPC-related options\n   */\n  trpc?: TRPCRequestOptions;\n}\nexport interface TRPCFetchQueryOptions<TOutput, TError>\n  extends DistributiveOmit<FetchQueryOptions<TOutput, TError>, 'queryKey'>,\n    TRPCUseUtilsOptions {\n  //\n}\n\nexport type TRPCFetchInfiniteQueryOptions<TInput, TOutput, TError> =\n  DistributiveOmit<\n    FetchInfiniteQueryOptions<\n      TOutput,\n      TError,\n      TOutput,\n      TRPCQueryKey,\n      ExtractCursorType<TInput>\n    >,\n    'queryKey' | 'initialPageParam'\n  > &\n    TRPCUseUtilsOptions & {\n      initialCursor?: ExtractCursorType<TInput>;\n    };\n\n/** @internal */\nexport type SSRState = 'mounted' | 'mounting' | 'prepass' | false;\n\nexport interface TRPCContextPropsBase<TRouter extends AnyRouter, TSSRContext> {\n  /**\n   * The `TRPCClient`\n   */\n  client: TRPCUntypedClient<TRouter>;\n  /**\n   * The SSR context when server-side rendering\n   * @default null\n   */\n  ssrContext?: TSSRContext | null;\n  /**\n   * State of SSR hydration.\n   * - `false` if not using SSR.\n   * - `prepass` when doing a prepass to fetch queries' data\n   * - `mounting` before TRPCProvider has been rendered on the client\n   * - `mounted` when the TRPCProvider has been rendered on the client\n   * @default false\n   */\n  ssrState?: SSRState;\n  /**\n   * @deprecated pass abortOnUnmount to `createTRPCReact` instead\n   * Abort loading query calls when unmounting a component - usually when navigating to a new page\n   * @default false\n   */\n  abortOnUnmount?: boolean;\n}\n\n/**\n * @internal\n */\nexport type DecoratedTRPCContextProps<\n  TRouter extends AnyRouter,\n  TSSRContext,\n> = TRPCContextPropsBase<TRouter, TSSRContext> & {\n  client: TRPCClient<TRouter>;\n};\n\nexport interface TRPCContextProps<TRouter extends AnyRouter, TSSRContext>\n  extends TRPCContextPropsBase<TRouter, TSSRContext> {\n  /**\n   * The react-query `QueryClient`\n   */\n  queryClient: QueryClient;\n}\n\nexport const contextProps: (keyof TRPCContextPropsBase<any, any>)[] = [\n  'client',\n  'ssrContext',\n  'ssrState',\n  'abortOnUnmount',\n];\n\n/**\n * @internal\n */\nexport interface TRPCContextState<\n  TRouter extends AnyRouter,\n  TSSRContext = undefined,\n> extends Required<TRPCContextProps<TRouter, TSSRContext>>,\n    TRPCQueryUtils<TRouter> {}\n\n/**\n * @internal\n */\nexport interface TRPCQueryUtils<TRouter extends AnyRouter> {\n  /**\n   * @see https://tanstack.com/query/latest/docs/framework/react/reference/queryOptions#queryoptions\n   */\n  queryOptions(\n    path: readonly string[], // <-- look into if needed\n    queryKey: TRPCQueryKey,\n    opts?: UndefinedTRPCQueryOptionsIn<\n      unknown,\n      unknown,\n      TRPCClientError<AnyClientTypes>\n    >,\n  ): UndefinedTRPCQueryOptionsOut<\n    unknown,\n    unknown,\n    TRPCClientError<AnyClientTypes>\n  >;\n  queryOptions(\n    path: readonly string[], // <-- look into if needed\n    queryKey: TRPCQueryKey,\n    opts: DefinedTRPCQueryOptionsIn<\n      unknown,\n      unknown,\n      TRPCClientError<AnyClientTypes>\n    >,\n  ): DefinedTRPCQueryOptionsOut<\n    unknown,\n    unknown,\n    TRPCClientError<AnyClientTypes>\n  >;\n\n  /**\n   * @see https://tanstack.com/query/latest/docs/framework/react/reference/infiniteQueryOptions#infinitequeryoptions\n   */\n  infiniteQueryOptions(\n    path: readonly string[], // <-- look into if needed\n    queryKey: TRPCQueryKey,\n    opts: UndefinedTRPCInfiniteQueryOptionsIn<\n      unknown,\n      unknown,\n      unknown,\n      TRPCClientError<AnyClientTypes>\n    >,\n  ): UndefinedTRPCInfiniteQueryOptionsOut<\n    unknown,\n    unknown,\n    unknown,\n    TRPCClientError<AnyClientTypes>\n  >;\n  infiniteQueryOptions(\n    path: readonly string[], // <-- look into if needed\n    queryKey: TRPCQueryKey,\n    opts: DefinedTRPCInfiniteQueryOptionsIn<\n      unknown,\n      unknown,\n      unknown,\n      TRPCClientError<AnyClientTypes>\n    >,\n  ): DefinedTRPCInfiniteQueryOptionsOut<\n    unknown,\n    unknown,\n    unknown,\n    TRPCClientError<AnyClientTypes>\n  >;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientfetchquery\n   */\n  fetchQuery: (\n    queryKey: TRPCQueryKey,\n    opts?: TRPCFetchQueryOptions<unknown, TRPCClientError<TRouter>>,\n  ) => Promise<unknown>;\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientfetchinfinitequery\n   */\n  fetchInfiniteQuery: (\n    queryKey: TRPCQueryKey,\n    opts?: TRPCFetchInfiniteQueryOptions<\n      unknown,\n      unknown,\n      TRPCClientError<TRouter>\n    >,\n  ) => Promise<InfiniteData<unknown, unknown>>;\n  /**\n   * @see https://tanstack.com/query/v5/docs/framework/react/guides/prefetching\n   */\n  prefetchQuery: (\n    queryKey: TRPCQueryKey,\n    opts?: TRPCFetchQueryOptions<unknown, TRPCClientError<TRouter>>,\n  ) => Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientprefetchinfinitequery\n   */\n  prefetchInfiniteQuery: (\n    queryKey: TRPCQueryKey,\n    opts?: TRPCFetchInfiniteQueryOptions<\n      unknown,\n      unknown,\n      TRPCClientError<TRouter>\n    >,\n  ) => Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientensurequerydata\n   */\n  ensureQueryData: (\n    queryKey: TRPCQueryKey,\n    opts?: TRPCFetchQueryOptions<unknown, TRPCClientError<TRouter>>,\n  ) => Promise<unknown>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/framework/react/guides/query-invalidation\n   */\n  invalidateQueries: (\n    queryKey: TRPCQueryKey,\n    filters?: InvalidateQueryFilters<TRPCQueryKey>,\n    options?: InvalidateOptions,\n  ) => Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientresetqueries\n   */\n  resetQueries: (\n    queryKey: TRPCQueryKey,\n    filters?: QueryFilters<TRPCQueryKey>,\n    options?: ResetOptions,\n  ) => Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientrefetchqueries\n   */\n  refetchQueries: (\n    queryKey: TRPCQueryKey,\n    filters?: RefetchQueryFilters<TRPCQueryKey>,\n    options?: RefetchOptions,\n  ) => Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/framework/react/guides/query-cancellation\n   */\n  cancelQuery: (\n    queryKey: TRPCQueryKey,\n    options?: CancelOptions,\n  ) => Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientsetquerydata\n   */\n  setQueryData: (\n    queryKey: TRPCQueryKey,\n    updater: Updater<unknown, unknown>,\n    options?: SetDataOptions,\n  ) => void;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientsetqueriesdata\n   */\n  setQueriesData: (\n    queryKey: TRPCQueryKey,\n    filters: QueryFilters,\n    updater: Updater<unknown, unknown>,\n    options?: SetDataOptions,\n  ) => [QueryKey, unknown][];\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientgetquerydata\n   */\n  getQueryData: (queryKey: TRPCQueryKey) => unknown;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientsetquerydata\n   */\n  setInfiniteQueryData: (\n    queryKey: TRPCQueryKey,\n    updater: Updater<\n      InfiniteData<unknown> | undefined,\n      InfiniteData<unknown> | undefined\n    >,\n    options?: SetDataOptions,\n  ) => void;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientgetquerydata\n   */\n  getInfiniteQueryData: (\n    queryKey: TRPCQueryKey,\n  ) => InfiniteData<unknown> | undefined;\n\n  /**\n   * @see https://tanstack.com/query/latest/docs/reference/QueryClient/#queryclientsetmutationdefaults\n   */\n  setMutationDefaults: (\n    mutationKey: TRPCMutationKey,\n    options:\n      | MutationOptions\n      | ((args: {\n          canonicalMutationFn: (input: unknown) => Promise<unknown>;\n        }) => MutationOptions),\n  ) => void;\n\n  /**\n   * @see https://tanstack.com/query/latest/docs/reference/QueryClient#queryclientgetmutationdefaults\n   */\n  getMutationDefaults: (\n    mutationKey: TRPCMutationKey,\n  ) => MutationOptions | undefined;\n\n  /**\n   * @see https://tanstack.com/query/latest/docs/reference/QueryClient#queryclientismutating\n   */\n  isMutating: (filters: { mutationKey: TRPCMutationKey }) => number;\n}\nexport const TRPCContext = React.createContext?.(null as any);\n","import type {\n  CancelOptions,\n  InfiniteData,\n  InvalidateOptions,\n  InvalidateQueryFilters,\n  Query,\n  QueryFilters,\n  QueryKey,\n  RefetchOptions,\n  RefetchQueryFilters,\n  ResetOptions,\n  SetDataOptions,\n  SkipToken,\n  Updater,\n} from '@tanstack/react-query';\nimport type { TRPCClientError } from '@trpc/client';\nimport { createTRPCClientProxy } from '@trpc/client';\nimport type {\n  AnyMutationProcedure,\n  AnyQueryProcedure,\n  AnyRootTypes,\n  AnyRouter,\n  DeepPartial,\n  inferProcedureInput,\n  inferProcedureOutput,\n  inferTransformedProcedureOutput,\n  ProtectedIntersection,\n  RouterRecord,\n} from '@trpc/server/unstable-core-do-not-import';\nimport {\n  createFlatProxy,\n  createRecursiveProxy,\n} from '@trpc/server/unstable-core-do-not-import';\nimport type {\n  DecoratedTRPCContextProps,\n  TRPCContextState,\n  TRPCFetchInfiniteQueryOptions,\n  TRPCFetchQueryOptions,\n  TRPCQueryUtils,\n} from '../../internals/context';\nimport { contextProps } from '../../internals/context';\nimport type { QueryKeyKnown, QueryType } from '../../internals/getQueryKey';\nimport {\n  getMutationKeyInternal,\n  getQueryKeyInternal,\n} from '../../internals/getQueryKey';\nimport type { InferMutationOptions } from '../../utils/inferReactQueryProcedure';\nimport type { ExtractCursorType } from '../hooks/types';\nimport type {\n  DefinedTRPCInfiniteQueryOptionsIn,\n  DefinedTRPCInfiniteQueryOptionsOut,\n  DefinedTRPCQueryOptionsIn,\n  DefinedTRPCQueryOptionsOut,\n  UndefinedTRPCInfiniteQueryOptionsIn,\n  UndefinedTRPCInfiniteQueryOptionsOut,\n  UndefinedTRPCQueryOptionsIn,\n  UndefinedTRPCQueryOptionsOut,\n  UnusedSkipTokenTRPCInfiniteQueryOptionsIn,\n  UnusedSkipTokenTRPCInfiniteQueryOptionsOut,\n  UnusedSkipTokenTRPCQueryOptionsIn,\n  UnusedSkipTokenTRPCQueryOptionsOut,\n} from '../types';\n\nexport type DecorateQueryProcedure<\n  TRoot extends AnyRootTypes,\n  TProcedure extends AnyQueryProcedure,\n> = {\n  /**\n   * @see https://tanstack.com/query/latest/docs/framework/react/reference/queryOptions#queryoptions\n   */\n  queryOptions<\n    TQueryFnData extends inferTransformedProcedureOutput<TRoot, TProcedure>,\n    TData = TQueryFnData,\n  >(\n    input: inferProcedureInput<TProcedure> | SkipToken,\n    opts: DefinedTRPCQueryOptionsIn<\n      TQueryFnData,\n      TData,\n      TRPCClientError<TRoot>\n    >,\n  ): DefinedTRPCQueryOptionsOut<TQueryFnData, TData, TRPCClientError<TRoot>>;\n  /**\n   * @see https://tanstack.com/query/latest/docs/framework/react/reference/queryOptions#queryoptions\n   */\n  queryOptions<\n    TQueryFnData extends inferTransformedProcedureOutput<TRoot, TProcedure>,\n    TData = TQueryFnData,\n  >(\n    input: inferProcedureInput<TProcedure> | SkipToken,\n    opts?: UnusedSkipTokenTRPCQueryOptionsIn<\n      TQueryFnData,\n      TData,\n      TRPCClientError<TRoot>\n    >,\n  ): UnusedSkipTokenTRPCQueryOptionsOut<\n    TQueryFnData,\n    TData,\n    TRPCClientError<TRoot>\n  >;\n  /**\n   * @see https://tanstack.com/query/latest/docs/framework/react/reference/queryOptions#queryoptions\n   */\n  queryOptions<\n    TQueryFnData extends inferTransformedProcedureOutput<TRoot, TProcedure>,\n    TData = TQueryFnData,\n  >(\n    input: inferProcedureInput<TProcedure> | SkipToken,\n    opts?: UndefinedTRPCQueryOptionsIn<\n      TQueryFnData,\n      TData,\n      TRPCClientError<TRoot>\n    >,\n  ): UndefinedTRPCQueryOptionsOut<TQueryFnData, TData, TRPCClientError<TRoot>>;\n\n  /**\n   * @see https://tanstack.com/query/latest/docs/framework/react/reference/infiniteQueryOptions#infinitequeryoptions\n   */\n  infiniteQueryOptions<\n    TQueryFnData extends inferTransformedProcedureOutput<TRoot, TProcedure>,\n    TData = TQueryFnData,\n  >(\n    input: inferProcedureInput<TProcedure> | SkipToken,\n    opts: DefinedTRPCInfiniteQueryOptionsIn<\n      inferProcedureInput<TProcedure>,\n      TQueryFnData,\n      TData,\n      TRPCClientError<TRoot>\n    >,\n  ): DefinedTRPCInfiniteQueryOptionsOut<\n    inferProcedureInput<TProcedure>,\n    TQueryFnData,\n    TData,\n    TRPCClientError<TRoot>\n  >;\n  /**\n   * @see https://tanstack.com/query/latest/docs/framework/react/reference/infiniteQueryOptions#infinitequeryoptions\n   */\n  infiniteQueryOptions<\n    TQueryFnData extends inferTransformedProcedureOutput<TRoot, TProcedure>,\n    TData = TQueryFnData,\n  >(\n    input: inferProcedureInput<TProcedure>,\n    opts: UnusedSkipTokenTRPCInfiniteQueryOptionsIn<\n      inferProcedureInput<TProcedure>,\n      TQueryFnData,\n      TData,\n      TRPCClientError<TRoot>\n    >,\n  ): UnusedSkipTokenTRPCInfiniteQueryOptionsOut<\n    inferProcedureInput<TProcedure>,\n    TQueryFnData,\n    TData,\n    TRPCClientError<TRoot>\n  >;\n  /**\n   * @see https://tanstack.com/query/latest/docs/framework/react/reference/infiniteQueryOptions#infinitequeryoptions\n   */\n  infiniteQueryOptions<\n    TQueryFnData extends inferTransformedProcedureOutput<TRoot, TProcedure>,\n    TData = TQueryFnData,\n  >(\n    input: inferProcedureInput<TProcedure> | SkipToken,\n    opts?: UndefinedTRPCInfiniteQueryOptionsIn<\n      inferProcedureInput<TProcedure>,\n      TQueryFnData,\n      TData,\n      TRPCClientError<TRoot>\n    >,\n  ): UndefinedTRPCInfiniteQueryOptionsOut<\n    inferProcedureInput<TProcedure>,\n    TQueryFnData,\n    TData,\n    TRPCClientError<TRoot>\n  >;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientfetchquery\n   */\n  fetch(\n    input: inferProcedureInput<TProcedure>,\n    opts?: TRPCFetchQueryOptions<\n      inferTransformedProcedureOutput<TRoot, TProcedure>,\n      TRPCClientError<TRoot>\n    >,\n  ): Promise<inferTransformedProcedureOutput<TRoot, TProcedure>>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientfetchinfinitequery\n   */\n  fetchInfinite(\n    input: inferProcedureInput<TProcedure>,\n    opts?: TRPCFetchInfiniteQueryOptions<\n      inferProcedureInput<TProcedure>,\n      inferTransformedProcedureOutput<TRoot, TProcedure>,\n      TRPCClientError<TRoot>\n    >,\n  ): Promise<\n    InfiniteData<\n      inferTransformedProcedureOutput<TRoot, TProcedure>,\n      NonNullable<ExtractCursorType<inferProcedureInput<TProcedure>>> | null\n    >\n  >;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientprefetchquery\n   */\n  prefetch(\n    input: inferProcedureInput<TProcedure>,\n    opts?: TRPCFetchQueryOptions<\n      inferTransformedProcedureOutput<TRoot, TProcedure>,\n      TRPCClientError<TRoot>\n    >,\n  ): Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientprefetchinfinitequery\n   */\n  prefetchInfinite(\n    input: inferProcedureInput<TProcedure>,\n    opts?: TRPCFetchInfiniteQueryOptions<\n      inferProcedureInput<TProcedure>,\n      inferTransformedProcedureOutput<TRoot, TProcedure>,\n      TRPCClientError<TRoot>\n    >,\n  ): Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientensurequerydata\n   */\n  ensureData(\n    input: inferProcedureInput<TProcedure>,\n    opts?: TRPCFetchQueryOptions<\n      inferTransformedProcedureOutput<TRoot, TProcedure>,\n      TRPCClientError<TRoot>\n    >,\n  ): Promise<inferTransformedProcedureOutput<TRoot, TProcedure>>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientinvalidatequeries\n   */\n  invalidate(\n    input?: DeepPartial<inferProcedureInput<TProcedure>>,\n    filters?: Omit<InvalidateQueryFilters, 'predicate'> & {\n      predicate?: (\n        query: Query<\n          inferProcedureOutput<TProcedure>,\n          TRPCClientError<TRoot>,\n          inferTransformedProcedureOutput<TRoot, TProcedure>,\n          QueryKeyKnown<\n            inferProcedureInput<TProcedure>,\n            inferProcedureInput<TProcedure> extends { cursor?: any } | void\n              ? 'infinite'\n              : 'query'\n          >\n        >,\n      ) => boolean;\n    },\n    options?: InvalidateOptions,\n  ): Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientrefetchqueries\n   */\n  refetch(\n    input?: inferProcedureInput<TProcedure>,\n    filters?: RefetchQueryFilters,\n    options?: RefetchOptions,\n  ): Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientcancelqueries\n   */\n  cancel(\n    input?: inferProcedureInput<TProcedure>,\n    options?: CancelOptions,\n  ): Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientresetqueries\n   */\n  reset(\n    input?: inferProcedureInput<TProcedure>,\n    options?: ResetOptions,\n  ): Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientsetquerydata\n   */\n  setData(\n    /**\n     * The input of the procedure\n     */\n    input: inferProcedureInput<TProcedure>,\n    updater: Updater<\n      inferTransformedProcedureOutput<TRoot, TProcedure> | undefined,\n      inferTransformedProcedureOutput<TRoot, TProcedure> | undefined\n    >,\n    options?: SetDataOptions,\n  ): void;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientsetquerydata\n   */\n  setQueriesData(\n    /**\n     * The input of the procedure\n     */\n    input: inferProcedureInput<TProcedure>,\n    filters: QueryFilters,\n    updater: Updater<\n      inferTransformedProcedureOutput<TRoot, TProcedure> | undefined,\n      inferTransformedProcedureOutput<TRoot, TProcedure> | undefined\n    >,\n    options?: SetDataOptions,\n  ): [QueryKey, inferTransformedProcedureOutput<TRoot, TProcedure>];\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientsetquerydata\n   */\n  setInfiniteData(\n    input: inferProcedureInput<TProcedure>,\n    updater: Updater<\n      | InfiniteData<\n          inferTransformedProcedureOutput<TRoot, TProcedure>,\n          NonNullable<ExtractCursorType<inferProcedureInput<TProcedure>>> | null\n        >\n      | undefined,\n      | InfiniteData<\n          inferTransformedProcedureOutput<TRoot, TProcedure>,\n          NonNullable<ExtractCursorType<inferProcedureInput<TProcedure>>> | null\n        >\n      | undefined\n    >,\n    options?: SetDataOptions,\n  ): void;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientgetquerydata\n   */\n  getData(\n    input?: inferProcedureInput<TProcedure>,\n  ): inferTransformedProcedureOutput<TRoot, TProcedure> | undefined;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientgetquerydata\n   */\n  getInfiniteData(\n    input?: inferProcedureInput<TProcedure>,\n  ):\n    | InfiniteData<\n        inferTransformedProcedureOutput<TRoot, TProcedure>,\n        NonNullable<ExtractCursorType<inferProcedureInput<TProcedure>>> | null\n      >\n    | undefined;\n};\n\ntype DecorateMutationProcedure<\n  TRoot extends AnyRootTypes,\n  TProcedure extends AnyMutationProcedure,\n> = {\n  setMutationDefaults<TMeta = unknown>(\n    options:\n      | InferMutationOptions<TRoot, TProcedure, TMeta>\n      | ((args: {\n          canonicalMutationFn: NonNullable<\n            InferMutationOptions<TRoot, TProcedure>['mutationFn']\n          >;\n        }) => InferMutationOptions<TRoot, TProcedure, TMeta>),\n  ): void;\n\n  getMutationDefaults(): InferMutationOptions<TRoot, TProcedure> | undefined;\n\n  isMutating(): number;\n};\n\n/**\n * this is the type that is used to add in procedures that can be used on\n * an entire router\n */\ntype DecorateRouter = {\n  /**\n   * Invalidate the full router\n   * @see https://trpc.io/docs/v10/useContext#query-invalidation\n   * @see https://tanstack.com/query/v5/docs/framework/react/guides/query-invalidation\n   */\n  invalidate(\n    input?: undefined,\n    filters?: InvalidateQueryFilters,\n    options?: InvalidateOptions,\n  ): Promise<void>;\n};\n\n/**\n * @internal\n */\nexport type DecoratedProcedureUtilsRecord<\n  TRoot extends AnyRootTypes,\n  TRecord extends RouterRecord,\n> = DecorateRouter & {\n  [TKey in keyof TRecord]: TRecord[TKey] extends infer $Value\n    ? $Value extends AnyQueryProcedure\n      ? DecorateQueryProcedure<TRoot, $Value>\n      : $Value extends AnyMutationProcedure\n        ? DecorateMutationProcedure<TRoot, $Value>\n        : $Value extends RouterRecord\n          ? DecoratedProcedureUtilsRecord<TRoot, $Value> & DecorateRouter\n          : never\n    : never;\n}; // Add functions that should be available at utils root\n\ntype AnyDecoratedProcedure = DecorateQueryProcedure<any, any> &\n  DecorateMutationProcedure<any, any>;\n\nexport type CreateReactUtils<\n  TRouter extends AnyRouter,\n  TSSRContext,\n> = ProtectedIntersection<\n  DecoratedTRPCContextProps<TRouter, TSSRContext>,\n  DecoratedProcedureUtilsRecord<\n    TRouter['_def']['_config']['$types'],\n    TRouter['_def']['record']\n  >\n>;\n\nexport type CreateQueryUtils<TRouter extends AnyRouter> =\n  DecoratedProcedureUtilsRecord<\n    TRouter['_def']['_config']['$types'],\n    TRouter['_def']['record']\n  >;\n\nexport const getQueryType = (\n  utilName: keyof AnyDecoratedProcedure,\n): QueryType => {\n  switch (utilName) {\n    case 'queryOptions':\n    case 'fetch':\n    case 'ensureData':\n    case 'prefetch':\n    case 'getData':\n    case 'setData':\n    case 'setQueriesData':\n      return 'query';\n\n    case 'infiniteQueryOptions':\n    case 'fetchInfinite':\n    case 'prefetchInfinite':\n    case 'getInfiniteData':\n    case 'setInfiniteData':\n      return 'infinite';\n\n    case 'setMutationDefaults':\n    case 'getMutationDefaults':\n    case 'isMutating':\n    case 'cancel':\n    case 'invalidate':\n    case 'refetch':\n    case 'reset':\n      return 'any';\n  }\n};\n\n/**\n * @internal\n */\nfunction createRecursiveUtilsProxy<TRouter extends AnyRouter>(\n  context: TRPCQueryUtils<TRouter>,\n) {\n  return createRecursiveProxy<CreateQueryUtils<TRouter>>((opts) => {\n    const path = [...opts.path];\n    const utilName = path.pop() as keyof AnyDecoratedProcedure;\n    const args = [...opts.args] as Parameters<\n      AnyDecoratedProcedure[typeof utilName]\n    >;\n    const input = args.shift(); // args can now be spread when input removed\n    const queryType = getQueryType(utilName);\n    const queryKey = getQueryKeyInternal(path, input, queryType);\n\n    const contextMap: Record<keyof AnyDecoratedProcedure, () => unknown> = {\n      infiniteQueryOptions: () =>\n        context.infiniteQueryOptions(path, queryKey, args[0]),\n      queryOptions: () => context.queryOptions(path, queryKey, ...args),\n      /**\n       * DecorateQueryProcedure\n       */\n      fetch: () => context.fetchQuery(queryKey, ...args),\n      fetchInfinite: () => context.fetchInfiniteQuery(queryKey, args[0]),\n      prefetch: () => context.prefetchQuery(queryKey, ...args),\n      prefetchInfinite: () => context.prefetchInfiniteQuery(queryKey, args[0]),\n      ensureData: () => context.ensureQueryData(queryKey, ...args),\n      invalidate: () => context.invalidateQueries(queryKey, ...args),\n      reset: () => context.resetQueries(queryKey, ...args),\n      refetch: () => context.refetchQueries(queryKey, ...args),\n      cancel: () => context.cancelQuery(queryKey, ...args),\n      setData: () => {\n        context.setQueryData(queryKey, args[0], args[1]);\n      },\n      setQueriesData: () =>\n        context.setQueriesData(queryKey, args[0], args[1], args[2]),\n      setInfiniteData: () => {\n        context.setInfiniteQueryData(queryKey, args[0], args[1]);\n      },\n      getData: () => context.getQueryData(queryKey),\n      getInfiniteData: () => context.getInfiniteQueryData(queryKey),\n      /**\n       * DecorateMutationProcedure\n       */\n      setMutationDefaults: () =>\n        context.setMutationDefaults(getMutationKeyInternal(path), input),\n      getMutationDefaults: () =>\n        context.getMutationDefaults(getMutationKeyInternal(path)),\n      isMutating: () =>\n        context.isMutating({ mutationKey: getMutationKeyInternal(path) }),\n    };\n\n    return contextMap[utilName]();\n  });\n}\n\n/**\n * @internal\n */\nexport function createReactQueryUtils<TRouter extends AnyRouter, TSSRContext>(\n  context: TRPCContextState<AnyRouter, TSSRContext>,\n) {\n  type CreateReactUtilsReturnType = CreateReactUtils<TRouter, TSSRContext>;\n\n  const clientProxy = createTRPCClientProxy(context.client);\n\n  const proxy = createRecursiveUtilsProxy(\n    context,\n  ) as CreateReactUtilsReturnType;\n\n  return createFlatProxy<CreateReactUtilsReturnType>((key) => {\n    const contextName = key as (typeof contextProps)[number];\n    if (contextName === 'client') {\n      return clientProxy;\n    }\n    if (contextProps.includes(contextName)) {\n      return context[contextName];\n    }\n\n    return proxy[key];\n  });\n}\n\n/**\n * @internal\n */\nexport function createQueryUtilsProxy<TRouter extends AnyRouter>(\n  context: TRPCQueryUtils<TRouter>,\n): CreateQueryUtils<TRouter> {\n  return createRecursiveUtilsProxy(context);\n}\n","import type { QueryOptions } from '@tanstack/react-query';\nimport type { TRPCClient } from '@trpc/client';\nimport {\n  getUntypedClient,\n  TRPCUntypedClient,\n  type TRPCClientError,\n} from '@trpc/client';\nimport type {\n  AnyProcedure,\n  AnyQueryProcedure,\n  AnyRootTypes,\n  AnyRouter,\n  inferProcedureInput,\n  inferTransformedProcedureOutput,\n  RouterRecord,\n} from '@trpc/server/unstable-core-do-not-import';\nimport { createRecursiveProxy } from '@trpc/server/unstable-core-do-not-import';\nimport { getQueryKeyInternal } from '../../internals/getQueryKey';\nimport type {\n  TrpcQueryOptionsForUseQueries,\n  TrpcQueryOptionsForUseSuspenseQueries,\n} from '../../internals/useQueries';\nimport type { TRPCUseQueryBaseOptions } from '../hooks/types';\n\ntype GetQueryOptions<\n  TRoot extends AnyRootTypes,\n  TProcedure extends AnyProcedure,\n> = <TData = inferTransformedProcedureOutput<TRoot, TProcedure>>(\n  input: inferProcedureInput<TProcedure>,\n  opts?: TrpcQueryOptionsForUseQueries<\n    inferTransformedProcedureOutput<TRoot, TProcedure>,\n    TData,\n    TRPCClientError<TRoot>\n  >,\n) => TrpcQueryOptionsForUseQueries<\n  inferTransformedProcedureOutput<TRoot, TProcedure>,\n  TData,\n  TRPCClientError<TRoot>\n>;\n\n/**\n * @internal\n */\nexport type UseQueriesProcedureRecord<\n  TRoot extends AnyRootTypes,\n  TRecord extends RouterRecord,\n> = {\n  [TKey in keyof TRecord]: TRecord[TKey] extends infer $Value\n    ? $Value extends AnyQueryProcedure\n      ? GetQueryOptions<TRoot, $Value>\n      : $Value extends RouterRecord\n        ? UseQueriesProcedureRecord<TRoot, $Value>\n        : never\n    : never;\n};\n\ntype GetSuspenseQueryOptions<\n  TRoot extends AnyRootTypes,\n  TProcedure extends AnyQueryProcedure,\n> = <TData = inferTransformedProcedureOutput<TRoot, TProcedure>>(\n  input: inferProcedureInput<TProcedure>,\n  opts?: TrpcQueryOptionsForUseSuspenseQueries<\n    inferTransformedProcedureOutput<TRoot, TProcedure>,\n    TData,\n    TRPCClientError<TRoot>\n  >,\n) => TrpcQueryOptionsForUseSuspenseQueries<\n  inferTransformedProcedureOutput<TRoot, TProcedure>,\n  TData,\n  TRPCClientError<TRoot>\n>;\n\n/**\n * @internal\n */\nexport type UseSuspenseQueriesProcedureRecord<\n  TRoot extends AnyRootTypes,\n  TRecord extends RouterRecord,\n> = {\n  [TKey in keyof TRecord]: TRecord[TKey] extends infer $Value\n    ? $Value extends AnyQueryProcedure\n      ? GetSuspenseQueryOptions<TRoot, $Value>\n      : $Value extends RouterRecord\n        ? UseSuspenseQueriesProcedureRecord<TRoot, $Value>\n        : never\n    : never;\n};\n\n/**\n * Create proxy for `useQueries` options\n * @internal\n */\nexport function createUseQueries<TRouter extends AnyRouter>(\n  client: TRPCUntypedClient<TRouter> | TRPCClient<TRouter>,\n) {\n  const untypedClient: TRPCUntypedClient<TRouter> =\n    client instanceof TRPCUntypedClient ? client : getUntypedClient(client);\n\n  return createRecursiveProxy<\n    UseQueriesProcedureRecord<\n      TRouter['_def']['_config']['$types'],\n      TRouter['_def']['record']\n    >\n  >((opts) => {\n    const arrayPath = opts.path;\n    const dotPath = arrayPath.join('.');\n    const [input, _opts] = opts.args as [\n      unknown,\n      Partial<QueryOptions> & TRPCUseQueryBaseOptions,\n    ];\n\n    const options: QueryOptions = {\n      queryKey: getQueryKeyInternal(arrayPath, input, 'query'),\n      queryFn: () => {\n        return untypedClient.query(dotPath, input, _opts?.trpc);\n      },\n      ..._opts,\n    };\n\n    return options;\n  });\n}\n","import type { TRPCQueryKey } from './getQueryKey';\n\n/**\n * @internal\n */\nexport function getClientArgs<TOptions>(\n  queryKey: TRPCQueryKey,\n  opts: TOptions,\n  infiniteParams?: {\n    pageParam: any;\n    direction: 'forward' | 'backward';\n  },\n) {\n  const path = queryKey[0];\n  let input = queryKey[1]?.input;\n  if (infiniteParams) {\n    input = {\n      ...(input ?? {}),\n      ...(infiniteParams.pageParam ? { cursor: infiniteParams.pageParam } : {}),\n      direction: infiniteParams.direction,\n    };\n  }\n  return [path.join('.'), input, (opts as any)?.trpc] as const;\n}\n","function _asyncIterator(r) {\n  var n,\n    t,\n    o,\n    e = 2;\n  for (\"undefined\" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;) {\n    if (t && null != (n = r[t])) return n.call(r);\n    if (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r));\n    t = \"@@asyncIterator\", o = \"@@iterator\";\n  }\n  throw new TypeError(\"Object is not async iterable\");\n}\nfunction AsyncFromSyncIterator(r) {\n  function AsyncFromSyncIteratorContinuation(r) {\n    if (Object(r) !== r) return Promise.reject(new TypeError(r + \" is not an object.\"));\n    var n = r.done;\n    return Promise.resolve(r.value).then(function (r) {\n      return {\n        value: r,\n        done: n\n      };\n    });\n  }\n  return AsyncFromSyncIterator = function AsyncFromSyncIterator(r) {\n    this.s = r, this.n = r.next;\n  }, AsyncFromSyncIterator.prototype = {\n    s: null,\n    n: null,\n    next: function next() {\n      return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));\n    },\n    \"return\": function _return(r) {\n      var n = this.s[\"return\"];\n      return void 0 === n ? Promise.resolve({\n        value: r,\n        done: !0\n      }) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));\n    },\n    \"throw\": function _throw(r) {\n      var n = this.s[\"return\"];\n      return void 0 === n ? Promise.reject(r) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));\n    }\n  }, new AsyncFromSyncIterator(r);\n}\nmodule.exports = _asyncIterator, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","import type { QueryClient } from '@tanstack/react-query';\nimport * as React from 'react';\nimport type { TRPCQueryOptionsResult } from '../shared';\nimport type { TRPCHookResult } from '../shared/hooks/types';\nimport type { TRPCQueryKey } from './getQueryKey';\n\nexport function createTRPCOptionsResult(value: {\n  path: readonly string[];\n}): TRPCQueryOptionsResult['trpc'] {\n  const path = value.path.join('.');\n\n  return {\n    path,\n  };\n}\n\n/**\n * Makes a stable reference of the `trpc` prop\n */\nexport function useHookResult(value: {\n  path: readonly string[];\n}): TRPCHookResult['trpc'] {\n  const result = createTRPCOptionsResult(value);\n  return React.useMemo(() => result, [result]);\n}\n\n/**\n * @internal\n */\nexport async function buildQueryFromAsyncIterable(\n  asyncIterable: AsyncIterable<unknown>,\n  queryClient: QueryClient,\n  queryKey: TRPCQueryKey,\n) {\n  const queryCache = queryClient.getQueryCache();\n\n  const query = queryCache.build(queryClient, {\n    queryKey,\n  });\n\n  query.setState({\n    data: [],\n    status: 'success',\n  });\n\n  const aggregate: unknown[] = [];\n  for await (const value of asyncIterable) {\n    aggregate.push(value);\n\n    query.setState({\n      data: [...aggregate],\n    });\n  }\n  return aggregate;\n}\n","import type { QueryFunctionContext } from '@tanstack/react-query';\nimport {\n  infiniteQueryOptions,\n  queryOptions,\n  skipToken,\n  type QueryClient,\n} from '@tanstack/react-query';\nimport type { TRPCClient, TRPCClientError } from '@trpc/client';\nimport { getUntypedClient, TRPCUntypedClient } from '@trpc/client';\nimport type { AnyRouter } from '@trpc/server/unstable-core-do-not-import';\nimport { isAsyncIterable } from '@trpc/server/unstable-core-do-not-import';\nimport type { AnyClientTypes } from '@trpc/server/unstable-core-do-not-import/clientish/inferrable';\nimport { getClientArgs } from '../internals/getClientArgs';\nimport type { TRPCQueryKey } from '../internals/getQueryKey';\nimport {\n  buildQueryFromAsyncIterable,\n  createTRPCOptionsResult,\n} from '../internals/trpcResult';\nimport type { DefinedTRPCQueryOptionsOut } from '../shared';\nimport { type TRPCQueryUtils } from '../shared';\n\nexport interface CreateQueryUtilsOptions<TRouter extends AnyRouter> {\n  /**\n   * The `TRPCClient`\n   */\n  client: TRPCClient<TRouter> | TRPCUntypedClient<TRouter>;\n  /**\n   * The `QueryClient` from `react-query`\n   */\n  queryClient: QueryClient;\n}\n\n/**\n * Creates a set of utility functions that can be used to interact with `react-query`\n * @param opts the `TRPCClient` and `QueryClient` to use\n * @returns a set of utility functions that can be used to interact with `react-query`\n * @internal\n */\nexport function createUtilityFunctions<TRouter extends AnyRouter>(\n  opts: CreateQueryUtilsOptions<TRouter>,\n): TRPCQueryUtils<TRouter> {\n  const { client, queryClient } = opts;\n  const untypedClient =\n    client instanceof TRPCUntypedClient ? client : getUntypedClient(client);\n\n  return {\n    infiniteQueryOptions: (path, queryKey, opts) => {\n      const inputIsSkipToken = queryKey[1]?.input === skipToken;\n\n      const queryFn = async (\n        queryFnContext: QueryFunctionContext<TRPCQueryKey, unknown>,\n      ): Promise<unknown> => {\n        const actualOpts = {\n          ...opts,\n          trpc: {\n            ...opts?.trpc,\n            ...(opts?.trpc?.abortOnUnmount\n              ? { signal: queryFnContext.signal }\n              : { signal: null }),\n          },\n        };\n\n        const result = await untypedClient.query(\n          ...getClientArgs(queryKey, actualOpts, {\n            direction: queryFnContext.direction,\n            pageParam: queryFnContext.pageParam,\n          }),\n        );\n\n        return result;\n      };\n\n      return Object.assign(\n        infiniteQueryOptions({\n          ...opts,\n          initialData: opts?.initialData as any,\n          queryKey,\n          queryFn: inputIsSkipToken ? skipToken : queryFn,\n          initialPageParam: (opts?.initialCursor as any) ?? null,\n        }),\n        { trpc: createTRPCOptionsResult({ path }) },\n      );\n    },\n\n    queryOptions: (path, queryKey, opts) => {\n      const inputIsSkipToken = queryKey[1]?.input === skipToken;\n\n      const queryFn = async (\n        queryFnContext: QueryFunctionContext<TRPCQueryKey>,\n      ): Promise<unknown> => {\n        const actualOpts = {\n          ...opts,\n          trpc: {\n            ...opts?.trpc,\n            ...(opts?.trpc?.abortOnUnmount\n              ? { signal: queryFnContext.signal }\n              : { signal: null }),\n          },\n        };\n\n        const result = await untypedClient.query(\n          ...getClientArgs(queryKey, actualOpts),\n        );\n\n        if (isAsyncIterable(result)) {\n          return buildQueryFromAsyncIterable(result, queryClient, queryKey);\n        }\n\n        return result;\n      };\n\n      return Object.assign(\n        queryOptions({\n          ...opts,\n          initialData: opts?.initialData,\n          queryKey,\n          queryFn: inputIsSkipToken ? skipToken : queryFn,\n        }),\n        { trpc: createTRPCOptionsResult({ path }) },\n      ) as DefinedTRPCQueryOptionsOut<\n        unknown,\n        unknown,\n        TRPCClientError<AnyClientTypes>\n      >;\n    },\n\n    fetchQuery: (queryKey, opts) => {\n      return queryClient.fetchQuery({\n        ...opts,\n        queryKey,\n        queryFn: () => untypedClient.query(...getClientArgs(queryKey, opts)),\n      });\n    },\n\n    fetchInfiniteQuery: (queryKey, opts) => {\n      return queryClient.fetchInfiniteQuery({\n        ...opts,\n        queryKey,\n        queryFn: ({ pageParam, direction }) => {\n          return untypedClient.query(\n            ...getClientArgs(queryKey, opts, { pageParam, direction }),\n          );\n        },\n        initialPageParam: opts?.initialCursor ?? null,\n      });\n    },\n\n    prefetchQuery: (queryKey, opts) => {\n      return queryClient.prefetchQuery({\n        ...opts,\n        queryKey,\n        queryFn: () => untypedClient.query(...getClientArgs(queryKey, opts)),\n      });\n    },\n\n    prefetchInfiniteQuery: (queryKey, opts) => {\n      return queryClient.prefetchInfiniteQuery({\n        ...opts,\n        queryKey,\n        queryFn: ({ pageParam, direction }) => {\n          return untypedClient.query(\n            ...getClientArgs(queryKey, opts, { pageParam, direction }),\n          );\n        },\n        initialPageParam: opts?.initialCursor ?? null,\n      });\n    },\n\n    ensureQueryData: (queryKey, opts) => {\n      return queryClient.ensureQueryData({\n        ...opts,\n        queryKey,\n        queryFn: () => untypedClient.query(...getClientArgs(queryKey, opts)),\n      });\n    },\n\n    invalidateQueries: (queryKey, filters, options) => {\n      return queryClient.invalidateQueries(\n        {\n          ...filters,\n          queryKey,\n        },\n        options,\n      );\n    },\n    resetQueries: (queryKey, filters, options) => {\n      return queryClient.resetQueries(\n        {\n          ...filters,\n          queryKey,\n        },\n        options,\n      );\n    },\n\n    refetchQueries: (queryKey, filters, options) => {\n      return queryClient.refetchQueries(\n        {\n          ...filters,\n          queryKey,\n        },\n        options,\n      );\n    },\n\n    cancelQuery: (queryKey, options) => {\n      return queryClient.cancelQueries(\n        {\n          queryKey,\n        },\n        options,\n      );\n    },\n\n    setQueryData: (queryKey, updater, options) => {\n      return queryClient.setQueryData(queryKey, updater as any, options);\n    },\n\n    // eslint-disable-next-line max-params\n    setQueriesData: (queryKey, filters, updater, options) => {\n      return queryClient.setQueriesData(\n        {\n          ...filters,\n          queryKey,\n        },\n        updater,\n        options,\n      );\n    },\n\n    getQueryData: (queryKey) => {\n      return queryClient.getQueryData(queryKey);\n    },\n\n    setInfiniteQueryData: (queryKey, updater, options) => {\n      return queryClient.setQueryData(queryKey, updater as any, options);\n    },\n\n    getInfiniteQueryData: (queryKey) => {\n      return queryClient.getQueryData(queryKey);\n    },\n\n    setMutationDefaults: (mutationKey, options) => {\n      const path = mutationKey[0];\n      const canonicalMutationFn = (input: unknown) => {\n        return untypedClient.mutation(\n          ...getClientArgs([path, { input }], opts),\n        );\n      };\n      return queryClient.setMutationDefaults(\n        mutationKey,\n        typeof options === 'function'\n          ? options({ canonicalMutationFn })\n          : options,\n      );\n    },\n\n    getMutationDefaults: (mutationKey) => {\n      return queryClient.getMutationDefaults(mutationKey);\n    },\n\n    isMutating: (filters) => {\n      return queryClient.isMutating({\n        ...filters,\n        exact: true,\n      });\n    },\n  };\n}\n","// TODO: Look into fixing react-compiler support\n/* eslint-disable react-hooks/react-compiler */\nimport {\n  useInfiniteQuery as __useInfiniteQuery,\n  useMutation as __useMutation,\n  usePrefetchInfiniteQuery as __usePrefetchInfiniteQuery,\n  useQueries as __useQueries,\n  useQuery as __useQuery,\n  useSuspenseInfiniteQuery as __useSuspenseInfiniteQuery,\n  useSuspenseQueries as __useSuspenseQueries,\n  useSuspenseQuery as __useSuspenseQuery,\n  usePrefetchQuery as _usePrefetchQuery,\n  hashKey,\n  skipToken,\n} from '@tanstack/react-query';\nimport type { TRPCClientErrorLike } from '@trpc/client';\nimport {\n  createTRPCClient,\n  getUntypedClient,\n  TRPCUntypedClient,\n} from '@trpc/client';\nimport type { Unsubscribable } from '@trpc/server/observable';\nimport type { AnyRouter } from '@trpc/server/unstable-core-do-not-import';\nimport { isAsyncIterable } from '@trpc/server/unstable-core-do-not-import';\nimport * as React from 'react';\nimport type { SSRState, TRPCContextState } from '../../internals/context';\nimport { TRPCContext } from '../../internals/context';\nimport { getClientArgs } from '../../internals/getClientArgs';\nimport type { TRPCQueryKey } from '../../internals/getQueryKey';\nimport {\n  getMutationKeyInternal,\n  getQueryKeyInternal,\n} from '../../internals/getQueryKey';\nimport {\n  buildQueryFromAsyncIterable,\n  useHookResult,\n} from '../../internals/trpcResult';\nimport type {\n  TRPCUseQueries,\n  TRPCUseSuspenseQueries,\n} from '../../internals/useQueries';\nimport { createUtilityFunctions } from '../../utils/createUtilityFunctions';\nimport { createUseQueries } from '../proxy/useQueriesProxy';\nimport type { CreateTRPCReactOptions, UseMutationOverride } from '../types';\nimport type {\n  TRPCProvider,\n  TRPCQueryOptions,\n  TRPCSubscriptionConnectingResult,\n  TRPCSubscriptionIdleResult,\n  TRPCSubscriptionResult,\n  UseTRPCInfiniteQueryOptions,\n  UseTRPCInfiniteQueryResult,\n  UseTRPCMutationOptions,\n  UseTRPCMutationResult,\n  UseTRPCPrefetchInfiniteQueryOptions,\n  UseTRPCPrefetchQueryOptions,\n  UseTRPCQueryOptions,\n  UseTRPCQueryResult,\n  UseTRPCSubscriptionOptions,\n  UseTRPCSuspenseInfiniteQueryOptions,\n  UseTRPCSuspenseInfiniteQueryResult,\n  UseTRPCSuspenseQueryOptions,\n  UseTRPCSuspenseQueryResult,\n} from './types';\n\nconst trackResult = <T extends object>(\n  result: T,\n  onTrackResult: (key: keyof T) => void,\n): T => {\n  const trackedResult = new Proxy(result, {\n    get(target, prop) {\n      onTrackResult(prop as keyof T);\n      return target[prop as keyof T];\n    },\n  });\n\n  return trackedResult;\n};\n\n/**\n * @internal\n */\nexport function createRootHooks<\n  TRouter extends AnyRouter,\n  TSSRContext = unknown,\n>(config?: CreateTRPCReactOptions<TRouter>) {\n  const mutationSuccessOverride: UseMutationOverride['onSuccess'] =\n    config?.overrides?.useMutation?.onSuccess ??\n    ((options) => options.originalFn());\n\n  type TError = TRPCClientErrorLike<TRouter>;\n\n  type ProviderContext = TRPCContextState<TRouter, TSSRContext>;\n\n  const Context = (config?.context ??\n    TRPCContext) as React.Context<ProviderContext>;\n\n  const createClient = createTRPCClient<TRouter>;\n\n  const TRPCProvider: TRPCProvider<TRouter, TSSRContext> = (props) => {\n    const { abortOnUnmount = false, queryClient, ssrContext } = props;\n    const [ssrState, setSSRState] = React.useState<SSRState>(\n      props.ssrState ?? false,\n    );\n\n    const client: TRPCUntypedClient<TRouter> =\n      props.client instanceof TRPCUntypedClient\n        ? props.client\n        : getUntypedClient(props.client);\n\n    const fns = React.useMemo(\n      () =>\n        createUtilityFunctions({\n          client,\n          queryClient,\n        }),\n      [client, queryClient],\n    );\n\n    const contextValue = React.useMemo<ProviderContext>(\n      () => ({\n        abortOnUnmount,\n        queryClient,\n        client,\n        ssrContext: ssrContext ?? null,\n        ssrState,\n        ...fns,\n      }),\n      [abortOnUnmount, client, fns, queryClient, ssrContext, ssrState],\n    );\n\n    React.useEffect(() => {\n      // Only updating state to `mounted` if we are using SSR.\n      // This makes it so we don't have an unnecessary re-render when opting out of SSR.\n      setSSRState((state) => (state ? 'mounted' : false));\n    }, []);\n    return (\n      <Context.Provider value={contextValue}>{props.children}</Context.Provider>\n    );\n  };\n\n  function useContext() {\n    const context = React.useContext(Context);\n\n    if (!context) {\n      throw new Error(\n        'Unable to find tRPC Context. Did you forget to wrap your App inside `withTRPC` HoC?',\n      );\n    }\n    return context;\n  }\n\n  /**\n   * Hack to make sure errors return `status`='error` when doing SSR\n   * @see https://github.com/trpc/trpc/pull/1645\n   */\n  function useSSRQueryOptionsIfNeeded<\n    TOptions extends { retryOnMount?: boolean } | undefined,\n  >(queryKey: TRPCQueryKey, opts: TOptions): TOptions {\n    const { queryClient, ssrState } = useContext();\n    return ssrState &&\n      ssrState !== 'mounted' &&\n      queryClient.getQueryCache().find({ queryKey })?.state.status === 'error'\n      ? {\n          retryOnMount: false,\n          ...opts,\n        }\n      : opts;\n  }\n\n  function useQuery(\n    path: readonly string[],\n    input: unknown,\n    opts?: UseTRPCQueryOptions<unknown, unknown, TError>,\n  ): UseTRPCQueryResult<unknown, TError> {\n    const context = useContext();\n    const { abortOnUnmount, client, ssrState, queryClient, prefetchQuery } =\n      context;\n    const queryKey = getQueryKeyInternal(path, input, 'query');\n\n    const defaultOpts = queryClient.getQueryDefaults(queryKey);\n\n    const isInputSkipToken = input === skipToken;\n\n    if (\n      typeof window === 'undefined' &&\n      ssrState === 'prepass' &&\n      opts?.trpc?.ssr !== false &&\n      (opts?.enabled ?? defaultOpts?.enabled) !== false &&\n      !isInputSkipToken &&\n      !queryClient.getQueryCache().find({ queryKey })\n    ) {\n      void prefetchQuery(queryKey, opts as any);\n    }\n    const ssrOpts = useSSRQueryOptionsIfNeeded(queryKey, {\n      ...defaultOpts,\n      ...opts,\n    });\n\n    const shouldAbortOnUnmount =\n      opts?.trpc?.abortOnUnmount ?? config?.abortOnUnmount ?? abortOnUnmount;\n\n    const hook = __useQuery(\n      {\n        ...ssrOpts,\n        queryKey: queryKey as any,\n        queryFn: isInputSkipToken\n          ? input\n          : async (queryFunctionContext) => {\n              const actualOpts = {\n                ...ssrOpts,\n                trpc: {\n                  ...ssrOpts?.trpc,\n                  ...(shouldAbortOnUnmount\n                    ? { signal: queryFunctionContext.signal }\n                    : { signal: null }),\n                },\n              };\n\n              const result = await client.query(\n                ...getClientArgs(queryKey, actualOpts),\n              );\n\n              if (isAsyncIterable(result)) {\n                return buildQueryFromAsyncIterable(\n                  result,\n                  queryClient,\n                  queryKey,\n                );\n              }\n              return result;\n            },\n      },\n      queryClient,\n    ) as UseTRPCQueryResult<unknown, TError>;\n\n    hook.trpc = useHookResult({\n      path,\n    });\n\n    return hook;\n  }\n\n  function usePrefetchQuery(\n    path: string[],\n    input: unknown,\n    opts?: UseTRPCPrefetchQueryOptions<unknown, unknown, TError>,\n  ): void {\n    const context = useContext();\n    const queryKey = getQueryKeyInternal(path, input, 'query');\n\n    const isInputSkipToken = input === skipToken;\n\n    const shouldAbortOnUnmount =\n      opts?.trpc?.abortOnUnmount ??\n      config?.abortOnUnmount ??\n      context.abortOnUnmount;\n\n    _usePrefetchQuery({\n      ...opts,\n      queryKey: queryKey as any,\n      queryFn: isInputSkipToken\n        ? input\n        : (queryFunctionContext) => {\n            const actualOpts = {\n              trpc: {\n                ...opts?.trpc,\n                ...(shouldAbortOnUnmount\n                  ? { signal: queryFunctionContext.signal }\n                  : {}),\n              },\n            };\n\n            return context.client.query(...getClientArgs(queryKey, actualOpts));\n          },\n    });\n  }\n\n  function useSuspenseQuery(\n    path: readonly string[],\n    input: unknown,\n    opts?: UseTRPCSuspenseQueryOptions<unknown, unknown, TError>,\n  ): UseTRPCSuspenseQueryResult<unknown, TError> {\n    const context = useContext();\n    const queryKey = getQueryKeyInternal(path, input, 'query');\n\n    const shouldAbortOnUnmount =\n      opts?.trpc?.abortOnUnmount ??\n      config?.abortOnUnmount ??\n      context.abortOnUnmount;\n\n    const hook = __useSuspenseQuery(\n      {\n        ...opts,\n        queryKey: queryKey as any,\n        queryFn: (queryFunctionContext) => {\n          const actualOpts = {\n            ...opts,\n            trpc: {\n              ...opts?.trpc,\n              ...(shouldAbortOnUnmount\n                ? { signal: queryFunctionContext.signal }\n                : { signal: null }),\n            },\n          };\n\n          return context.client.query(...getClientArgs(queryKey, actualOpts));\n        },\n      },\n      context.queryClient,\n    ) as UseTRPCQueryResult<unknown, TError>;\n\n    hook.trpc = useHookResult({\n      path,\n    });\n\n    return [hook.data, hook as any];\n  }\n\n  function useMutation(\n    path: readonly string[],\n    opts?: UseTRPCMutationOptions<unknown, TError, unknown, unknown>,\n  ): UseTRPCMutationResult<unknown, TError, unknown, unknown> {\n    const { client, queryClient } = useContext();\n\n    const mutationKey = getMutationKeyInternal(path);\n\n    const defaultOpts = queryClient.defaultMutationOptions(\n      queryClient.getMutationDefaults(mutationKey),\n    );\n\n    const hook = __useMutation(\n      {\n        ...opts,\n        mutationKey: mutationKey,\n        mutationFn: (input) => {\n          return client.mutation(...getClientArgs([path, { input }], opts));\n        },\n        onSuccess(...args) {\n          const originalFn = () =>\n            opts?.onSuccess?.(...args) ?? defaultOpts?.onSuccess?.(...args);\n\n          return mutationSuccessOverride({\n            originalFn,\n            queryClient,\n            meta: opts?.meta ?? defaultOpts?.meta ?? {},\n          });\n        },\n      },\n      queryClient,\n    ) as UseTRPCMutationResult<unknown, TError, unknown, unknown>;\n\n    hook.trpc = useHookResult({\n      path,\n    });\n\n    return hook;\n  }\n  const initialStateIdle: Omit<TRPCSubscriptionIdleResult<unknown>, 'reset'> = {\n    data: undefined,\n    error: null,\n    status: 'idle',\n  };\n\n  const initialStateConnecting: Omit<\n    TRPCSubscriptionConnectingResult<unknown, TError>,\n    'reset'\n  > = {\n    data: undefined,\n    error: null,\n    status: 'connecting',\n  };\n\n  /* istanbul ignore next -- @preserve */\n  function useSubscription(\n    path: readonly string[],\n    input: unknown,\n    opts: UseTRPCSubscriptionOptions<unknown, TError>,\n  ) {\n    const enabled = opts?.enabled ?? input !== skipToken;\n    const queryKey = hashKey(getQueryKeyInternal(path, input, 'any'));\n    const { client } = useContext();\n\n    const optsRef = React.useRef<typeof opts>(opts);\n    React.useEffect(() => {\n      optsRef.current = opts;\n    });\n\n    type $Result = TRPCSubscriptionResult<unknown, TError>;\n\n    const [trackedProps] = React.useState(new Set<keyof $Result>([]));\n\n    const addTrackedProp = React.useCallback(\n      (key: keyof $Result) => {\n        trackedProps.add(key);\n      },\n      [trackedProps],\n    );\n\n    const currentSubscriptionRef = React.useRef<Unsubscribable>(null);\n\n    const updateState = React.useCallback(\n      (callback: (prevState: $Result) => $Result) => {\n        const prev = resultRef.current;\n        const next = (resultRef.current = callback(prev));\n\n        let shouldUpdate = false;\n        for (const key of trackedProps) {\n          if (prev[key] !== next[key]) {\n            shouldUpdate = true;\n            break;\n          }\n        }\n        if (shouldUpdate) {\n          setState(trackResult(next, addTrackedProp));\n        }\n      },\n      [addTrackedProp, trackedProps],\n    );\n\n    const reset = React.useCallback((): void => {\n      // unsubscribe from the previous subscription\n      currentSubscriptionRef.current?.unsubscribe();\n\n      if (!enabled) {\n        updateState(() => ({ ...initialStateIdle, reset }));\n        return;\n      }\n      updateState(() => ({ ...initialStateConnecting, reset }));\n      const subscription = client.subscription(\n        path.join('.'),\n        input ?? undefined,\n        {\n          onStarted: () => {\n            optsRef.current.onStarted?.();\n            updateState((prev) => ({\n              ...prev,\n              status: 'pending',\n              error: null,\n            }));\n          },\n          onData: (data) => {\n            optsRef.current.onData?.(data);\n            updateState((prev) => ({\n              ...prev,\n              status: 'pending',\n              data,\n              error: null,\n            }));\n          },\n          onError: (error) => {\n            optsRef.current.onError?.(error);\n            updateState((prev) => ({\n              ...prev,\n              status: 'error',\n              error,\n            }));\n          },\n          onConnectionStateChange: (result) => {\n            updateState((prev) => {\n              switch (result.state) {\n                case 'idle':\n                  return {\n                    ...prev,\n                    status: result.state,\n                    error: null,\n                    data: undefined,\n                  };\n                case 'connecting':\n                  return {\n                    ...prev,\n                    error: result.error,\n                    status: result.state,\n                  };\n\n                case 'pending':\n                  // handled when data is / onStarted\n                  return prev;\n              }\n            });\n          },\n          onComplete: () => {\n            optsRef.current.onComplete?.();\n\n            // In the case of WebSockets, the connection might not be idle so `onConnectionStateChange` will not be called until the connection is closed.\n            // In this case, we need to set the state to idle manually.\n            updateState((prev) => ({\n              ...prev,\n              status: 'idle',\n              error: null,\n              data: undefined,\n            }));\n\n            // (We might want to add a `connectionState` to the state to track the connection state separately)\n          },\n        },\n      );\n\n      currentSubscriptionRef.current = subscription;\n\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [client, queryKey, enabled, updateState]);\n    React.useEffect(() => {\n      reset();\n\n      return () => {\n        currentSubscriptionRef.current?.unsubscribe();\n      };\n    }, [reset]);\n\n    const resultRef = React.useRef<$Result>(\n      enabled\n        ? { ...initialStateConnecting, reset }\n        : { ...initialStateIdle, reset },\n    );\n\n    const [state, setState] = React.useState<$Result>(\n      trackResult(resultRef.current, addTrackedProp),\n    );\n\n    return state;\n  }\n\n  function useInfiniteQuery(\n    path: readonly string[],\n    input: unknown,\n    opts: UseTRPCInfiniteQueryOptions<unknown, unknown, TError>,\n  ): UseTRPCInfiniteQueryResult<unknown, TError, unknown> {\n    const {\n      client,\n      ssrState,\n      prefetchInfiniteQuery,\n      queryClient,\n      abortOnUnmount,\n    } = useContext();\n    const queryKey = getQueryKeyInternal(path, input, 'infinite');\n\n    const defaultOpts = queryClient.getQueryDefaults(queryKey);\n\n    const isInputSkipToken = input === skipToken;\n\n    if (\n      typeof window === 'undefined' &&\n      ssrState === 'prepass' &&\n      opts?.trpc?.ssr !== false &&\n      (opts?.enabled ?? defaultOpts?.enabled) !== false &&\n      !isInputSkipToken &&\n      !queryClient.getQueryCache().find({ queryKey })\n    ) {\n      void prefetchInfiniteQuery(queryKey, { ...defaultOpts, ...opts } as any);\n    }\n\n    const ssrOpts = useSSRQueryOptionsIfNeeded(queryKey, {\n      ...defaultOpts,\n      ...opts,\n    });\n\n    // request option should take priority over global\n    const shouldAbortOnUnmount = opts?.trpc?.abortOnUnmount ?? abortOnUnmount;\n\n    const hook = __useInfiniteQuery(\n      {\n        ...ssrOpts,\n        initialPageParam: opts.initialCursor ?? null,\n        persister: opts.persister,\n        queryKey: queryKey as any,\n        queryFn: isInputSkipToken\n          ? input\n          : (queryFunctionContext) => {\n              const actualOpts = {\n                ...ssrOpts,\n                trpc: {\n                  ...ssrOpts?.trpc,\n                  ...(shouldAbortOnUnmount\n                    ? { signal: queryFunctionContext.signal }\n                    : { signal: null }),\n                },\n              };\n\n              return client.query(\n                ...getClientArgs(queryKey, actualOpts, {\n                  pageParam:\n                    queryFunctionContext.pageParam ?? opts.initialCursor,\n                  direction: queryFunctionContext.direction,\n                }),\n              );\n            },\n      },\n      queryClient,\n    ) as UseTRPCInfiniteQueryResult<unknown, TError, unknown>;\n\n    hook.trpc = useHookResult({\n      path,\n    });\n    return hook;\n  }\n\n  function usePrefetchInfiniteQuery(\n    path: string[],\n    input: unknown,\n    opts: UseTRPCPrefetchInfiniteQueryOptions<unknown, unknown, TError>,\n  ): void {\n    const context = useContext();\n    const queryKey = getQueryKeyInternal(path, input, 'infinite');\n\n    const defaultOpts = context.queryClient.getQueryDefaults(queryKey);\n\n    const isInputSkipToken = input === skipToken;\n\n    const ssrOpts = useSSRQueryOptionsIfNeeded(queryKey, {\n      ...defaultOpts,\n      ...opts,\n    });\n\n    // request option should take priority over global\n    const shouldAbortOnUnmount =\n      opts?.trpc?.abortOnUnmount ?? context.abortOnUnmount;\n\n    __usePrefetchInfiniteQuery({\n      ...opts,\n      initialPageParam: opts.initialCursor ?? null,\n      queryKey,\n      queryFn: isInputSkipToken\n        ? input\n        : (queryFunctionContext) => {\n            const actualOpts = {\n              ...ssrOpts,\n              trpc: {\n                ...ssrOpts?.trpc,\n                ...(shouldAbortOnUnmount\n                  ? { signal: queryFunctionContext.signal }\n                  : {}),\n              },\n            };\n\n            return context.client.query(\n              ...getClientArgs(queryKey, actualOpts, {\n                pageParam: queryFunctionContext.pageParam ?? opts.initialCursor,\n                direction: queryFunctionContext.direction,\n              }),\n            );\n          },\n    });\n  }\n\n  function useSuspenseInfiniteQuery(\n    path: readonly string[],\n    input: unknown,\n    opts: UseTRPCSuspenseInfiniteQueryOptions<unknown, unknown, TError>,\n  ): UseTRPCSuspenseInfiniteQueryResult<unknown, TError, unknown> {\n    const context = useContext();\n    const queryKey = getQueryKeyInternal(path, input, 'infinite');\n\n    const defaultOpts = context.queryClient.getQueryDefaults(queryKey);\n\n    const ssrOpts = useSSRQueryOptionsIfNeeded(queryKey, {\n      ...defaultOpts,\n      ...opts,\n    });\n\n    // request option should take priority over global\n    const shouldAbortOnUnmount =\n      opts?.trpc?.abortOnUnmount ?? context.abortOnUnmount;\n\n    const hook = __useSuspenseInfiniteQuery(\n      {\n        ...opts,\n        initialPageParam: opts.initialCursor ?? null,\n        queryKey,\n        queryFn: (queryFunctionContext) => {\n          const actualOpts = {\n            ...ssrOpts,\n            trpc: {\n              ...ssrOpts?.trpc,\n              ...(shouldAbortOnUnmount\n                ? { signal: queryFunctionContext.signal }\n                : {}),\n            },\n          };\n\n          return context.client.query(\n            ...getClientArgs(queryKey, actualOpts, {\n              pageParam: queryFunctionContext.pageParam ?? opts.initialCursor,\n              direction: queryFunctionContext.direction,\n            }),\n          );\n        },\n      },\n      context.queryClient,\n    ) as UseTRPCInfiniteQueryResult<unknown, TError, unknown>;\n\n    hook.trpc = useHookResult({\n      path,\n    });\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return [hook.data!, hook as any];\n  }\n\n  const useQueries: TRPCUseQueries<TRouter> = (queriesCallback, options) => {\n    const { ssrState, queryClient, prefetchQuery, client } = useContext();\n\n    const proxy = createUseQueries(client);\n\n    const queries = queriesCallback(proxy);\n\n    if (typeof window === 'undefined' && ssrState === 'prepass') {\n      for (const query of queries) {\n        const queryOption = query as TRPCQueryOptions<any, any>;\n        if (\n          queryOption.trpc?.ssr !== false &&\n          !queryClient.getQueryCache().find({ queryKey: queryOption.queryKey })\n        ) {\n          void prefetchQuery(queryOption.queryKey, queryOption as any);\n        }\n      }\n    }\n\n    return __useQueries(\n      {\n        queries: queries.map((query) => ({\n          ...query,\n          queryKey: (query as TRPCQueryOptions<any, any>).queryKey,\n        })),\n        combine: options?.combine as any,\n      },\n      queryClient,\n    );\n  };\n\n  const useSuspenseQueries: TRPCUseSuspenseQueries<TRouter> = (\n    queriesCallback,\n  ) => {\n    const { queryClient, client } = useContext();\n\n    const proxy = createUseQueries(client);\n\n    const queries = queriesCallback(proxy);\n\n    const hook = __useSuspenseQueries(\n      {\n        queries: queries.map((query) => ({\n          ...query,\n          queryFn: query.queryFn,\n          queryKey: (query as TRPCQueryOptions<any, any>).queryKey,\n        })),\n      },\n      queryClient,\n    );\n\n    return [hook.map((h) => h.data), hook] as any;\n  };\n\n  return {\n    Provider: TRPCProvider,\n    createClient,\n    useContext,\n    useUtils: useContext,\n    useQuery,\n    usePrefetchQuery,\n    useSuspenseQuery,\n    useQueries,\n    useSuspenseQueries,\n    useMutation,\n    useSubscription,\n    useInfiniteQuery,\n    usePrefetchInfiniteQuery,\n    useSuspenseInfiniteQuery,\n  };\n}\n\n/**\n * Infer the type of a `createReactQueryHooks` function\n * @internal\n */\nexport type CreateReactQueryHooks<\n  TRouter extends AnyRouter,\n  TSSRContext = unknown,\n> = ReturnType<typeof createRootHooks<TRouter, TSSRContext>>;\n","import type { QueryClientConfig } from '@tanstack/react-query';\nimport { QueryClient } from '@tanstack/react-query';\n\n/**\n * @internal\n */\nexport type CreateTRPCReactQueryClientConfig =\n  | {\n      queryClient?: QueryClient;\n      queryClientConfig?: never;\n    }\n  | {\n      queryClientConfig?: QueryClientConfig;\n      queryClient?: never;\n    };\n\n/**\n * @internal\n */\nexport const getQueryClient = (config: CreateTRPCReactQueryClientConfig) =>\n  config.queryClient ?? new QueryClient(config.queryClientConfig);\n"],"names":["hooks: CreateReactQueryHooks<TRouter, TSSRContext>","contextProps: (keyof TRPCContextPropsBase<any, any>)[]","React","utilName: keyof AnyDecoratedProcedure","context: TRPCQueryUtils<TRouter>","contextMap: Record<keyof AnyDecoratedProcedure, () => unknown>","context: TRPCContextState<AnyRouter, TSSRContext>","client: TRPCUntypedClient<TRouter> | TRPCClient<TRouter>","untypedClient: TRPCUntypedClient<TRouter>","options: QueryOptions","queryKey: TRPCQueryKey","opts: TOptions","infiniteParams?: {\n    pageParam: any;\n    direction: 'forward' | 'backward';\n  }","_asyncIterator","r","AsyncFromSyncIterator","value: {\n  path: readonly string[];\n}","asyncIterable: AsyncIterable<unknown>","queryClient: QueryClient","queryKey: TRPCQueryKey","aggregate: unknown[]","opts: CreateQueryUtilsOptions<TRouter>","opts","queryFnContext: QueryFunctionContext<TRPCQueryKey, unknown>","queryFnContext: QueryFunctionContext<TRPCQueryKey>","input: unknown","result: T","onTrackResult: (key: keyof T) => void","config?: CreateTRPCReactOptions<TRouter>","mutationSuccessOverride: UseMutationOverride['onSuccess']","TRPCProvider: TRPCProvider<TRouter, TSSRContext>","client: TRPCUntypedClient<TRouter>","queryKey: TRPCQueryKey","opts: TOptions","useQuery","path: readonly string[]","input: unknown","opts?: UseTRPCQueryOptions<unknown, unknown, TError>","usePrefetchQuery","path: string[]","opts?: UseTRPCPrefetchQueryOptions<unknown, unknown, TError>","useSuspenseQuery","opts?: UseTRPCSuspenseQueryOptions<unknown, unknown, TError>","useMutation","opts?: UseTRPCMutationOptions<unknown, TError, unknown, unknown>","initialStateIdle: Omit<TRPCSubscriptionIdleResult<unknown>, 'reset'>","initialStateConnecting: Omit<\n    TRPCSubscriptionConnectingResult<unknown, TError>,\n    'reset'\n  >","opts: UseTRPCSubscriptionOptions<unknown, TError>","key: keyof $Result","callback: (prevState: $Result) => $Result","useInfiniteQuery","opts: UseTRPCInfiniteQueryOptions<unknown, unknown, TError>","usePrefetchInfiniteQuery","opts: UseTRPCPrefetchInfiniteQueryOptions<unknown, unknown, TError>","useSuspenseInfiniteQuery","opts: UseTRPCSuspenseInfiniteQueryOptions<unknown, unknown, TError>","useQueries: TRPCUseQueries<TRouter>","useSuspenseQueries: TRPCUseSuspenseQueries<TRouter>","config: CreateTRPCReactQueryClientConfig"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAQA,SAAgB,sBAGdA,KAAAA,EAAoD;IACpD,qLAAO,uBAAA,EAAqB,CAAC,EAAE,IAAA,EAAM,IAAA,EAAM,KAAK;;QAC9C,MAAM,WAAW,CAAC;eAAG,IAAK;SAAA;QAI1B,MAAM,UAAU,SAAS,GAAA,EAAK;QAE9B,IAAI,YAAY,cACd,CAAA,OAAQ,KAAA,CAAc,QAAA,CAAS,UAAU,GAAG,KAAK;QAGnD,IAAI,YAAY,OACd,CAAA,OAAO;YACL,MAAM;QACP;QAGH,MAAM,CAAC,OAAO,GAAG,KAAK,GAAG;QACzB,MAAM,OAAA,CAAA,SAAO,IAAA,CAAK,EAAA,MAAA,QAAA,WAAA,KAAA,IAAA,SAAM,CAAE;QAE1B,OAAQ,KAAA,CAAc,QAAA,CAAS,UAAU,OAAO,KAAK;IACtD,EAAC;AACH;;;;ACmFD,MAAaC,eAAyD;IACpE;IACA;IACA;IACA;CACD;AAmOD,MAAa,cAAA,CAAA,uBAAcC,8JAAM,aAAA,MAAA,QAAA,yBAAA,KAAA,IAAA,KAAA,IAAN,qBAAA,IAAA,CAAA,+JAAsB,KAAY;;;ACiF7D,MAAa,eAAe,CAC1BC,aACc;IACd,OAAQ,UAAR;QACE,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK,iBACH;YAAA,OAAO;QAET,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK,kBACH;YAAA,OAAO;QAET,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK,QACH;YAAA,OAAO;IACV;AACF;;;GAKD,SAAS,0BACPC,OAAAA,EACA;IACA,qLAAO,uBAAA,EAAgD,CAAC,SAAS;QAC/D,MAAM,OAAO,CAAC;eAAG,KAAK,IAAK;SAAA;QAC3B,MAAM,WAAW,KAAK,GAAA,EAAK;QAC3B,MAAM,OAAO,CAAC;eAAG,KAAK,IAAK;SAAA;QAG3B,MAAM,QAAQ,KAAK,KAAA,EAAO;QAC1B,MAAM,YAAY,aAAa,SAAS;QACxC,MAAM,+LAAW,sBAAA,EAAoB,MAAM,OAAO,UAAU;QAE5D,MAAMC,aAAiE;YACrE,sBAAsB,IACpB,QAAQ,oBAAA,CAAqB,MAAM,UAAU,IAAA,CAAK,EAAA,CAAG;YACvD,cAAc,IAAM,QAAQ,YAAA,CAAa,MAAM,UAAU,GAAG,KAAK;YAIjE,OAAO,IAAM,QAAQ,UAAA,CAAW,UAAU,GAAG,KAAK;YAClD,eAAe,IAAM,QAAQ,kBAAA,CAAmB,UAAU,IAAA,CAAK,EAAA,CAAG;YAClE,UAAU,IAAM,QAAQ,aAAA,CAAc,UAAU,GAAG,KAAK;YACxD,kBAAkB,IAAM,QAAQ,qBAAA,CAAsB,UAAU,IAAA,CAAK,EAAA,CAAG;YACxE,YAAY,IAAM,QAAQ,eAAA,CAAgB,UAAU,GAAG,KAAK;YAC5D,YAAY,IAAM,QAAQ,iBAAA,CAAkB,UAAU,GAAG,KAAK;YAC9D,OAAO,IAAM,QAAQ,YAAA,CAAa,UAAU,GAAG,KAAK;YACpD,SAAS,IAAM,QAAQ,cAAA,CAAe,UAAU,GAAG,KAAK;YACxD,QAAQ,IAAM,QAAQ,WAAA,CAAY,UAAU,GAAG,KAAK;YACpD,SAAS,MAAM;gBACb,QAAQ,YAAA,CAAa,UAAU,IAAA,CAAK,EAAA,EAAI,IAAA,CAAK,EAAA,CAAG;YACjD;YACD,gBAAgB,IACd,QAAQ,cAAA,CAAe,UAAU,IAAA,CAAK,EAAA,EAAI,IAAA,CAAK,EAAA,EAAI,IAAA,CAAK,EAAA,CAAG;YAC7D,iBAAiB,MAAM;gBACrB,QAAQ,oBAAA,CAAqB,UAAU,IAAA,CAAK,EAAA,EAAI,IAAA,CAAK,EAAA,CAAG;YACzD;YACD,SAAS,IAAM,QAAQ,YAAA,CAAa,SAAS;YAC7C,iBAAiB,IAAM,QAAQ,oBAAA,CAAqB,SAAS;YAI7D,qBAAqB,IACnB,QAAQ,mBAAA,CAAoB,6MAAA,EAAuB,KAAK,EAAE,MAAM;YAClE,qBAAqB,IACnB,QAAQ,mBAAA,qLAAoB,yBAAA,EAAuB,KAAK,CAAC;YAC3D,YAAY,IACV,QAAQ,UAAA,CAAW;oBAAE,iMAAa,yBAAA,EAAuB,KAAK;gBAAE,EAAC;QACpE;QAED,OAAO,UAAA,CAAW,SAAA,EAAW;IAC9B,EAAC;AACH;;;GAKD,SAAgB,sBACdC,OAAAA,EACA;IAGA,MAAM,wLAAc,wBAAA,EAAsB,QAAQ,MAAA,CAAO;IAEzD,MAAM,QAAQ,0BACZ,QACD;IAED,qLAAO,kBAAA,EAA4C,CAAC,QAAQ;QAC1D,MAAM,cAAc;QACpB,IAAI,gBAAgB,SAClB,CAAA,OAAO;QAET,IAAI,aAAa,QAAA,CAAS,YAAY,CACpC,CAAA,OAAO,OAAA,CAAQ,YAAA;QAGjB,OAAO,KAAA,CAAM,IAAA;IACd,EAAC;AACH;;;GAKD,SAAgB,sBACdF,OAAAA,EAC2B;IAC3B,OAAO,0BAA0B,QAAQ;AAC1C;;;;;;;GC5cD,SAAgB,iBACdG,MAAAA,EACA;IACA,MAAMC,gBACJ,wLAAkB,oBAAA,GAAoB,mLAAS,mBAAA,EAAiB,OAAO;IAEzE,qLAAO,uBAAA,EAKL,CAAC,SAAS;QACV,MAAM,YAAY,KAAK,IAAA;QACvB,MAAM,UAAU,UAAU,IAAA,CAAK,IAAI;QACnC,MAAM,CAAC,OAAO,MAAM,GAAG,KAAK,IAAA;QAK5B,MAAMC,UAAAA,CAAAA,GAAAA,uBAAAA,OAAAA,EAAAA;YACJ,8LAAU,sBAAA,EAAoB,WAAW,OAAO,QAAQ;YACxD,SAAS,MAAM;gBACb,OAAO,cAAc,KAAA,CAAM,SAAS,OAAA,UAAA,QAAA,UAAA,KAAA,IAAA,KAAA,IAAO,MAAO,IAAA,CAAK;YACxD;WACE;QAGL,OAAO;IACR,EAAC;AACH;;;;;;GCpHD,SAAgB,cACdC,QAAAA,EACAC,IAAAA,EACAC,cAAAA,EAIA;;IACA,MAAM,OAAO,QAAA,CAAS,EAAA;IACtB,IAAI,QAAA,CAAA,aAAQ,QAAA,CAAS,EAAA,MAAA,QAAA,eAAA,KAAA,IAAA,KAAA,IAAA,WAAI,KAAA;IACzB,IAAI,gBAAgB;;QAClB,QAAA,CAAA,GAAA,uBAAA,OAAA,EAAA,CAAA,GAAA,uBAAA,OAAA,EAAA,CAAA,GAAA,uBAAA,OAAA,EAAA,CAAA,GAAA,CAAA,SACM,KAAA,MAAA,QAAA,WAAA,KAAA,IAAA,SAAS,CAAE,IACX,eAAe,SAAA,GAAY;YAAE,QAAQ,eAAe,SAAA;QAAW,IAAG,CAAE,IAAA,CAAA,GAAA;YACxE,WAAW,eAAe,SAAA;QAAA;IAE7B;IACD,OAAO;QAAC,KAAK,IAAA,CAAK,IAAI;QAAE;oDAAQ,KAAc,IAAA;KAAK;AACpD;;;;;QCvBD,SAASC,iBAAe,CAAA,EAAG;YACzB,IAAI,GACF,GACA,GACA,IAAI;YACN,IAAK,eAAA,OAAsB,UAAA,CAAW,IAAI,OAAO,aAAA,EAAe,IAAI,OAAO,QAAA,GAAW,KAAM;gBAC1F,IAAI,KAAK,QAAA,CAAS,IAAI,CAAA,CAAE,EAAA,EAAK,CAAA,OAAO,EAAE,IAAA,CAAK,EAAE;gBAC7C,IAAI,KAAK,QAAA,CAAS,IAAI,CAAA,CAAE,EAAA,EAAK,CAAA,OAAO,IAAI,sBAAsB,EAAE,IAAA,CAAK,EAAE;gBACvE,IAAI,mBAAmB,IAAI;YAC5B;YACD,MAAM,IAAI,UAAU;QACrB;QACD,SAAS,sBAAsB,CAAA,EAAG;YAChC,SAAS,kCAAkCC,GAAAA,EAAG;gBAC5C,IAAI,OAAOA,IAAE,KAAKA,IAAG,CAAA,OAAO,QAAQ,MAAA,CAAO,IAAI,UAAUA,MAAI,sBAAsB;gBACnF,IAAI,IAAIA,IAAE,IAAA;gBACV,OAAO,QAAQ,OAAA,CAAQA,IAAE,KAAA,CAAM,CAAC,IAAA,CAAK,SAAUA,GAAAA,EAAG;oBAChD,OAAO;wBACL,OAAOA;wBACP,MAAM;oBACP;gBACF,EAAC;YACH;YACD,OAAO,wBAAwB,SAASC,wBAAsBD,GAAAA,EAAG;gBAC/D,IAAA,CAAK,CAAA,GAAIA,KAAG,IAAA,CAAK,CAAA,GAAIA,IAAE,IAAA;YACxB,GAAE,sBAAsB,SAAA,GAAY;gBACnC,GAAG;gBACH,GAAG;gBACH,MAAM,SAAS,OAAO;oBACpB,OAAO,kCAAkC,IAAA,CAAK,CAAA,CAAE,KAAA,CAAM,IAAA,CAAK,CAAA,EAAG,UAAU,CAAC;gBAC1E;gBACD,UAAU,SAAS,QAAQA,GAAAA,EAAG;oBAC5B,IAAI,IAAI,IAAA,CAAK,CAAA,CAAE,SAAA;oBACf,OAAA,KAAY,MAAM,IAAI,QAAQ,OAAA,CAAQ;wBACpC,OAAOA;wBACP,MAAA,CAAO;oBACR,EAAC,GAAG,kCAAkC,EAAE,KAAA,CAAM,IAAA,CAAK,CAAA,EAAG,UAAU,CAAC;gBACnE;gBACD,SAAS,SAAS,OAAOA,GAAAA,EAAG;oBAC1B,IAAI,IAAI,IAAA,CAAK,CAAA,CAAE,SAAA;oBACf,OAAA,KAAY,MAAM,IAAI,QAAQ,MAAA,CAAOA,IAAE,GAAG,kCAAkC,EAAE,KAAA,CAAM,IAAA,CAAK,CAAA,EAAG,UAAU,CAAC;gBACxG;YACF,GAAE,IAAI,sBAAsB;QAC9B;QACD,OAAO,OAAA,GAAUD,kBAAgB,OAAO,OAAA,CAAQ,UAAA,GAAa,MAAM,OAAO,OAAA,CAAQ,UAAA,GAAa,OAAO,OAAA;;;;;;ACtCtG,SAAgB,wBAAwBG,KAAAA,EAEL;IACjC,MAAM,OAAO,MAAM,IAAA,CAAK,IAAA,CAAK,IAAI;IAEjC,OAAO;QACL;IACD;AACF;;;GAKD,SAAgB,cAAcA,KAAAA,EAEH;IACzB,MAAM,SAAS,wBAAwB,MAAM;IAC7C,OAAO,8JAAM,OAAA;iCAAQ,IAAM;gCAAQ;QAAC,MAAO;KAAA,CAAC;AAC7C;;;GAKD,eAAsB,4BACpBC,aAAAA,EACAC,WAAAA,EACAC,QAAAA,EACA;IACA,MAAM,aAAa,YAAY,aAAA,EAAe;IAE9C,MAAM,QAAQ,WAAW,KAAA,CAAM,aAAa;QAC1C;IACD,EAAC;IAEF,MAAM,QAAA,CAAS;QACb,MAAM,CAAE,CAAA;QACR,QAAQ;IACT,EAAC;IAEF,MAAMC,YAAuB,CAAE,CAAA;;;;;8DACL,gBAAA,OAAA,4BAAA,CAAA,CAAA,QAAA,MAAA,UAAA,IAAA,EAAA,EAAA,IAAA,EAAA,4BAAA,MAAA;kBAAT,QAAA,MAAA,KAAA;YAAwB;gBACvC,UAAU,IAAA,CAAK,MAAM;gBAErB,MAAM,QAAA,CAAS;oBACb,MAAM,CAAC;2BAAG,SAAU;qBAAA;gBACrB,EAAC;YACH;;;;;;;;;;;;IACD,OAAO;AACR;;;;;;;;;GChBD,SAAgB,uBACdC,IAAAA,EACyB;IACzB,MAAM,EAAE,MAAA,EAAQ,WAAA,EAAa,GAAG;IAChC,MAAM,gBACJ,wLAAkB,oBAAA,GAAoB,SAAS,6LAAA,EAAiB,OAAO;IAEzE,OAAO;QACL,sBAAsB,CAAC,MAAM,UAAUC,WAAS;;YAC9C,MAAM,mBAAA,CAAA,CAAA,aAAmB,QAAA,CAAS,EAAA,MAAA,QAAA,eAAA,KAAA,IAAA,KAAA,IAAA,WAAI,KAAA,iLAAU,YAAA;YAEhD,MAAM,UAAU,OACdC,mBACqB;;gBACrB,MAAM,aAAA,CAAA,GAAA,uBAAA,OAAA,EAAA,CAAA,GAAA,uBAAA,OAAA,EAAA,CAAA,GACDD,SAAAA,CAAAA,GAAAA;oBACH,MAAA,CAAA,GAAA,uBAAA,OAAA,EAAA,CAAA,GAAA,uBAAA,OAAA,EAAA,CAAA,GAAA,WAAA,QAAA,WAAA,KAAA,IAAA,KAAA,IACKA,OAAM,IAAA,GAAA,CAAA,WAAA,QAAA,WAAA,KAAA,KAAA,CAAA,aACLA,OAAM,IAAA,MAAA,QAAA,eAAA,KAAA,IAAA,KAAA,IAAA,WAAM,cAAA,IACZ;wBAAE,QAAQ,eAAe,MAAA;oBAAQ,IACjC;wBAAE,QAAQ;oBAAM;gBAAA;gBAIxB,MAAM,SAAS,MAAM,cAAc,KAAA,CACjC,GAAG,cAAc,UAAU,YAAY;oBACrC,WAAW,eAAe,SAAA;oBAC1B,WAAW,eAAe,SAAA;gBAC3B,EAAC,CACH;gBAED,OAAO;YACR;YAED,OAAO,OAAO,MAAA,gMACZ,uBAAA,EAAA,CAAA,GAAA,uBAAA,OAAA,EAAA,CAAA,GAAA,uBAAA,OAAA,EAAA,CAAA,GACKA,SAAAA,CAAAA,GAAAA;gBACH,aAAA,WAAA,QAAA,WAAA,KAAA,IAAA,KAAA,IAAaA,OAAM,WAAA;gBACnB;gBACA,SAAS,8LAAmB,YAAA,GAAY;gBACxC,kBAAA,CAAA,OAAA,WAAA,QAAA,WAAA,KAAA,IAAA,KAAA,IAAmBA,OAAM,aAAA,MAAA,QAAA,SAAA,KAAA,IAAA,OAAyB;eAClD,EACF;gBAAE,MAAM,wBAAwB;oBAAE;gBAAM,EAAC;YAAE,EAC5C;QACF;QAED,cAAc,CAAC,MAAM,UAAUA,WAAS;;YACtC,MAAM,mBAAA,CAAA,CAAA,cAAmB,QAAA,CAAS,EAAA,MAAA,QAAA,gBAAA,KAAA,IAAA,KAAA,IAAA,YAAI,KAAA,MAAU,uLAAA;YAEhD,MAAM,UAAU,OACdE,mBACqB;;gBACrB,MAAM,aAAA,CAAA,GAAA,uBAAA,OAAA,EAAA,CAAA,GAAA,uBAAA,OAAA,EAAA,CAAA,GACDF,SAAAA,CAAAA,GAAAA;oBACH,MAAA,CAAA,GAAA,uBAAA,OAAA,EAAA,CAAA,GAAA,uBAAA,OAAA,EAAA,CAAA,GAAA,WAAA,QAAA,WAAA,KAAA,IAAA,KAAA,IACKA,OAAM,IAAA,GAAA,CAAA,WAAA,QAAA,WAAA,KAAA,KAAA,CAAA,cACLA,OAAM,IAAA,MAAA,QAAA,gBAAA,KAAA,IAAA,KAAA,IAAA,YAAM,cAAA,IACZ;wBAAE,QAAQ,eAAe,MAAA;oBAAQ,IACjC;wBAAE,QAAQ;oBAAM;gBAAA;gBAIxB,MAAM,SAAS,MAAM,cAAc,KAAA,CACjC,GAAG,cAAc,UAAU,WAAW,CACvC;gBAED,0KAAI,kBAAA,EAAgB,OAAO,CACzB,CAAA,OAAO,4BAA4B,QAAQ,aAAa,SAAS;gBAGnE,OAAO;YACR;YAED,OAAO,OAAO,MAAA,wLACZ,eAAA,EAAA,CAAA,GAAA,uBAAA,OAAA,EAAA,CAAA,GAAA,uBAAA,OAAA,EAAA,CAAA,GACKA,SAAAA,CAAAA,GAAAA;gBACH,aAAA,WAAA,QAAA,WAAA,KAAA,IAAA,KAAA,IAAaA,OAAM,WAAA;gBACnB;gBACA,SAAS,8LAAmB,YAAA,GAAY;eACxC,EACF;gBAAE,MAAM,wBAAwB;oBAAE;gBAAM,EAAC;YAAE,EAC5C;QAKF;QAED,YAAY,CAAC,UAAUA,WAAS;YAC9B,OAAO,YAAY,UAAA,CAAA,CAAA,GAAA,uBAAA,OAAA,EAAA,CAAA,GAAA,uBAAA,OAAA,EAAA,CAAA,GACdA,SAAAA,CAAAA,GAAAA;gBACH;gBACA,SAAS,IAAM,cAAc,KAAA,CAAM,GAAG,cAAc,UAAUA,OAAK,CAAC;eACpE;QACH;QAED,oBAAoB,CAAC,UAAUA,WAAS;;YACtC,OAAO,YAAY,kBAAA,CAAA,CAAA,GAAA,uBAAA,OAAA,EAAA,CAAA,GAAA,uBAAA,OAAA,EAAA,CAAA,GACdA,SAAAA,CAAAA,GAAAA;gBACH;gBACA,SAAS,CAAC,EAAE,SAAA,EAAW,SAAA,EAAW,KAAK;oBACrC,OAAO,cAAc,KAAA,CACnB,GAAG,cAAc,UAAUA,QAAM;wBAAE;wBAAW;oBAAW,EAAC,CAC3D;gBACF;gBACD,kBAAA,CAAA,sBAAA,WAAA,QAAA,WAAA,KAAA,IAAA,KAAA,IAAkBA,OAAM,aAAA,MAAA,QAAA,wBAAA,KAAA,IAAA,sBAAiB;eACzC;QACH;QAED,eAAe,CAAC,UAAUA,WAAS;YACjC,OAAO,YAAY,aAAA,CAAA,CAAA,GAAA,uBAAA,OAAA,EAAA,CAAA,GAAA,uBAAA,OAAA,EAAA,CAAA,GACdA,SAAAA,CAAAA,GAAAA;gBACH;gBACA,SAAS,IAAM,cAAc,KAAA,CAAM,GAAG,cAAc,UAAUA,OAAK,CAAC;eACpE;QACH;QAED,uBAAuB,CAAC,UAAUA,WAAS;;YACzC,OAAO,YAAY,qBAAA,CAAA,CAAA,GAAA,uBAAA,OAAA,EAAA,CAAA,GAAA,uBAAA,OAAA,EAAA,CAAA,GACdA,SAAAA,CAAAA,GAAAA;gBACH;gBACA,SAAS,CAAC,EAAE,SAAA,EAAW,SAAA,EAAW,KAAK;oBACrC,OAAO,cAAc,KAAA,CACnB,GAAG,cAAc,UAAUA,QAAM;wBAAE;wBAAW;oBAAW,EAAC,CAC3D;gBACF;gBACD,kBAAA,CAAA,uBAAA,WAAA,QAAA,WAAA,KAAA,IAAA,KAAA,IAAkBA,OAAM,aAAA,MAAA,QAAA,yBAAA,KAAA,IAAA,uBAAiB;eACzC;QACH;QAED,iBAAiB,CAAC,UAAUA,WAAS;YACnC,OAAO,YAAY,eAAA,CAAA,CAAA,GAAA,uBAAA,OAAA,EAAA,CAAA,GAAA,uBAAA,OAAA,EAAA,CAAA,GACdA,SAAAA,CAAAA,GAAAA;gBACH;gBACA,SAAS,IAAM,cAAc,KAAA,CAAM,GAAG,cAAc,UAAUA,OAAK,CAAC;eACpE;QACH;QAED,mBAAmB,CAAC,UAAU,SAAS,YAAY;YACjD,OAAO,YAAY,iBAAA,CAAA,CAAA,GAAA,uBAAA,OAAA,EAAA,CAAA,GAAA,uBAAA,OAAA,EAAA,CAAA,GAEZ,UAAA,CAAA,GAAA;gBACH;YAAA,IAEF,QACD;QACF;QACD,cAAc,CAAC,UAAU,SAAS,YAAY;YAC5C,OAAO,YAAY,YAAA,CAAA,CAAA,GAAA,uBAAA,OAAA,EAAA,CAAA,GAAA,uBAAA,OAAA,EAAA,CAAA,GAEZ,UAAA,CAAA,GAAA;gBACH;YAAA,IAEF,QACD;QACF;QAED,gBAAgB,CAAC,UAAU,SAAS,YAAY;YAC9C,OAAO,YAAY,cAAA,CAAA,CAAA,GAAA,uBAAA,OAAA,EAAA,CAAA,GAAA,uBAAA,OAAA,EAAA,CAAA,GAEZ,UAAA,CAAA,GAAA;gBACH;YAAA,IAEF,QACD;QACF;QAED,aAAa,CAAC,UAAU,YAAY;YAClC,OAAO,YAAY,aAAA,CACjB;gBACE;YACD,GACD,QACD;QACF;QAED,cAAc,CAAC,UAAU,SAAS,YAAY;YAC5C,OAAO,YAAY,YAAA,CAAa,UAAU,SAAgB,QAAQ;QACnE;QAGD,gBAAgB,CAAC,UAAU,SAAS,SAAS,YAAY;YACvD,OAAO,YAAY,cAAA,CAAA,CAAA,GAAA,uBAAA,OAAA,EAAA,CAAA,GAAA,uBAAA,OAAA,EAAA,CAAA,GAEZ,UAAA,CAAA,GAAA;gBACH;YAAA,IAEF,SACA,QACD;QACF;QAED,cAAc,CAAC,aAAa;YAC1B,OAAO,YAAY,YAAA,CAAa,SAAS;QAC1C;QAED,sBAAsB,CAAC,UAAU,SAAS,YAAY;YACpD,OAAO,YAAY,YAAA,CAAa,UAAU,SAAgB,QAAQ;QACnE;QAED,sBAAsB,CAAC,aAAa;YAClC,OAAO,YAAY,YAAA,CAAa,SAAS;QAC1C;QAED,qBAAqB,CAAC,aAAa,YAAY;YAC7C,MAAM,OAAO,WAAA,CAAY,EAAA;YACzB,MAAM,sBAAsB,CAACG,UAAmB;gBAC9C,OAAO,cAAc,QAAA,CACnB,GAAG,cAAc;oBAAC;oBAAM;wBAAE;oBAAO,CAAC;iBAAA,EAAE,KAAK,CAC1C;YACF;YACD,OAAO,YAAY,mBAAA,CACjB,aAAA,OACO,YAAY,aACf,QAAQ;gBAAE;YAAqB,EAAC,GAChC,QACL;QACF;QAED,qBAAqB,CAAC,gBAAgB;YACpC,OAAO,YAAY,mBAAA,CAAoB,YAAY;QACpD;QAED,YAAY,CAAC,YAAY;YACvB,OAAO,YAAY,UAAA,CAAA,CAAA,GAAA,uBAAA,OAAA,EAAA,CAAA,GAAA,uBAAA,OAAA,EAAA,CAAA,GACd,UAAA,CAAA,GAAA;gBACH,OAAO;YAAA,GACP;QACH;IACF;AACF;;;;AC3MD,MAAM,cAAc,CAClBC,QACAC,kBACM;IACN,MAAM,gBAAgB,IAAI,MAAM,QAAQ;QACtC,KAAI,MAAA,EAAQ,IAAA,EAAM;YAChB,cAAc,KAAgB;YAC9B,OAAO,MAAA,CAAO,KAAA;QACf;IACF;IAED,OAAO;AACR;;;GAKD,SAAgB,gBAGdC,MAAAA,EAA0C;;IAC1C,MAAMC,0BAAAA,CAAAA,wBAAAA,WAAAA,QAAAA,WAAAA,KAAAA,KAAAA,CAAAA,oBACJ,OAAQ,SAAA,MAAA,QAAA,sBAAA,KAAA,KAAA,CAAA,oBAAA,kBAAW,WAAA,MAAA,QAAA,sBAAA,KAAA,IAAA,KAAA,IAAA,kBAAa,SAAA,MAAA,QAAA,0BAAA,KAAA,IAAA,wBAC/B,CAAC,UAAY,QAAQ,UAAA,EAAY;IAMpC,MAAM,UAAA,CAAA,kBAAA,WAAA,QAAA,WAAA,KAAA,IAAA,KAAA,IAAW,OAAQ,OAAA,MAAA,QAAA,oBAAA,KAAA,IAAA,kBACvB;IAEF,MAAM,qLAAe,mBAAA;IAErB,MAAMC,eAAmD,CAAC,UAAU;;QAClE,MAAM,EAAE,iBAAiB,KAAA,EAAO,WAAA,EAAa,UAAA,EAAY,GAAG;QAC5D,MAAM,CAAC,UAAU,YAAY,GAAG,8JAAM,QAAA,CAAA,CAAA,kBACpC,MAAM,QAAA,MAAA,QAAA,oBAAA,KAAA,IAAA,kBAAY,MACnB;QAED,MAAMC,SACJ,MAAM,MAAA,kLAAkB,oBAAA,GACpB,MAAM,MAAA,6KACN,mBAAA,EAAiB,MAAM,MAAA,CAAO;QAEpC,MAAM,MAAM,8JAAM,OAAA;yDAChB,IACE,uBAAuB;oBACrB;oBACA;gBACD,EAAC;wDACJ;YAAC;YAAQ,WAAY;SAAA,CACtB;QAED,MAAM,eAAe,8JAAM,OAAA;kEACzB,IAAA,CAAA,GAAA,qBAAA,OAAA,EAAA;oBACE;oBACA;oBACA;oBACA,YAAY,eAAA,QAAA,eAAA,KAAA,IAAA,aAAc;oBAC1B;mBACG;iEAEL;YAAC;YAAgB;YAAQ;YAAK;YAAa;YAAY;SAAS,CACjE;QAED,8JAAM,SAAA;sDAAU,MAAM;gBAGpB;8DAAY,CAAC,QAAW,QAAQ,YAAY,MAAO;;YACpD;qDAAE,CAAE,CAAA,CAAC;QACN,OAAA,aAAA,8KACE,MAAA,EAAC,QAAQ,QAAA,EAAA;YAAS,OAAO;sBAAe,MAAM,QAAA;UAA4B;IAE7E;IAED,SAAS,aAAa;QACpB,MAAM,UAAU,8JAAM,UAAA,CAAW,QAAQ;QAEzC,IAAA,CAAK,QACH,CAAA,MAAM,IAAI,MACR;QAGJ,OAAO;IACR;;;;IAMD,SAAS,2BAEPC,QAAAA,EAAwBC,IAAAA,EAA0B;;QAClD,MAAM,EAAE,WAAA,EAAa,QAAA,EAAU,GAAG,YAAY;QAC9C,OAAO,YACL,aAAa,aAAA,CAAA,CAAA,wBACb,YAAY,aAAA,EAAe,CAAC,IAAA,CAAK;YAAE;QAAU,EAAC,MAAA,QAAA,0BAAA,KAAA,IAAA,KAAA,IAAA,sBAAE,KAAA,CAAM,MAAA,MAAW,UAAA,CAAA,GAAA,qBAAA,OAAA,EAAA;YAE7D,cAAc;QAAA,GACX,QAEL;IACL;IAED,SAASC,WACPC,IAAAA,EACAC,KAAAA,EACAC,IAAAA,EACqC;;QACrC,MAAM,UAAU,YAAY;QAC5B,MAAM,EAAE,cAAA,EAAgB,MAAA,EAAQ,QAAA,EAAU,WAAA,EAAa,aAAA,EAAe,GACpE;QACF,MAAM,+LAAW,sBAAA,EAAoB,MAAM,OAAO,QAAQ;QAE1D,MAAM,cAAc,YAAY,gBAAA,CAAiB,SAAS;QAE1D,MAAM,mBAAmB,qLAAU,YAAA;QAEnC,IAAA,OACS,WAAW,eAClB,aAAa,aAAA,CAAA,SAAA,QAAA,SAAA,KAAA,KAAA,CAAA,aACb,KAAM,IAAA,MAAA,QAAA,eAAA,KAAA,IAAA,KAAA,IAAA,WAAM,GAAA,MAAQ,SAAA,CAAA,CAAA,gBAAA,SAAA,QAAA,SAAA,KAAA,IAAA,KAAA,IACnB,KAAM,OAAA,MAAA,QAAA,kBAAA,KAAA,IAAA,gBAAA,gBAAA,QAAA,gBAAA,KAAA,IAAA,KAAA,IAAW,YAAa,OAAA,MAAa,SAAA,CAC3C,oBAAA,CACA,YAAY,aAAA,EAAe,CAAC,IAAA,CAAK;YAAE;QAAU,EAAC,CAE/C,CAAK,cAAc,UAAU,KAAY;QAE3C,MAAM,UAAU,2BAA2B,UAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GACtC,cACA,MACH;QAEF,MAAM,uBAAA,CAAA,OAAA,CAAA,wBAAA,SAAA,QAAA,SAAA,KAAA,KAAA,CAAA,cACJ,KAAM,IAAA,MAAA,QAAA,gBAAA,KAAA,IAAA,KAAA,IAAA,YAAM,cAAA,MAAA,QAAA,0BAAA,KAAA,IAAA,wBAAA,WAAA,QAAA,WAAA,KAAA,IAAA,KAAA,IAAkB,OAAQ,cAAA,MAAA,QAAA,SAAA,KAAA,IAAA,OAAkB;QAE1D,MAAM,0LAAO,WAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAEN,UAAA,CAAA,GAAA;YACO;YACV,SAAS,mBACL;6DACA,OAAO,yBAAyB;oBAC9B,MAAM,aAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GACD,UAAA,CAAA,GAAA;wBACH,MAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,YAAA,QAAA,YAAA,KAAA,IAAA,KAAA,IACK,QAAS,IAAA,GACR,uBACA;4BAAE,QAAQ,qBAAqB,MAAA;wBAAQ,IACvC;4BAAE,QAAQ;wBAAM;oBAAA;oBAIxB,MAAM,SAAS,MAAM,OAAO,KAAA,CAC1B,GAAG,cAAc,UAAU,WAAW,CACvC;oBAED,0KAAI,kBAAA,EAAgB,OAAO,CACzB,CAAA,OAAO,4BACL,QACA,aACA,SACD;oBAEH,OAAO;gBACR;;YAEP,YACD;QAED,KAAK,IAAA,GAAO,cAAc;YACxB;QACD,EAAC;QAEF,OAAO;IACR;IAED,SAASC,mBACPC,IAAAA,EACAH,KAAAA,EACAI,IAAAA,EACM;;QACN,MAAM,UAAU,YAAY;QAC5B,MAAM,+LAAW,sBAAA,EAAoB,MAAM,OAAO,QAAQ;QAE1D,MAAM,mBAAmB,oLAAU,aAAA;QAEnC,MAAM,uBAAA,CAAA,QAAA,CAAA,yBAAA,SAAA,QAAA,SAAA,KAAA,KAAA,CAAA,cACJ,KAAM,IAAA,MAAA,QAAA,gBAAA,KAAA,IAAA,KAAA,IAAA,YAAM,cAAA,MAAA,QAAA,2BAAA,KAAA,IAAA,yBAAA,WAAA,QAAA,WAAA,KAAA,IAAA,KAAA,IACZ,OAAQ,cAAA,MAAA,QAAA,UAAA,KAAA,IAAA,QACR,QAAQ,cAAA;QAEV,CAAA,GAAA,sLAAA,CAAA,mBAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GACK,OAAA,CAAA,GAAA;YACO;YACV,SAAS,mBACL;uEACA,CAAC,yBAAyB;oBACxB,MAAM,aAAa;wBACjB,MAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,SAAA,QAAA,SAAA,KAAA,IAAA,KAAA,IACK,KAAM,IAAA,GACL,uBACA;4BAAE,QAAQ,qBAAqB,MAAA;wBAAQ,IACvC,CAAE;oBAET;oBAED,OAAO,QAAQ,MAAA,CAAO,KAAA,CAAM,GAAG,cAAc,UAAU,WAAW,CAAC;gBACpE;;WACL;IACH;IAED,SAASC,mBACPN,IAAAA,EACAC,KAAAA,EACAM,IAAAA,EAC6C;;QAC7C,MAAM,UAAU,YAAY;QAC5B,MAAM,+LAAW,sBAAA,EAAoB,MAAM,OAAO,QAAQ;QAE1D,MAAM,uBAAA,CAAA,QAAA,CAAA,yBAAA,SAAA,QAAA,SAAA,KAAA,KAAA,CAAA,cACJ,KAAM,IAAA,MAAA,QAAA,gBAAA,KAAA,IAAA,KAAA,IAAA,YAAM,cAAA,MAAA,QAAA,2BAAA,KAAA,IAAA,yBAAA,WAAA,QAAA,WAAA,KAAA,IAAA,KAAA,IACZ,OAAQ,cAAA,MAAA,QAAA,UAAA,KAAA,IAAA,QACR,QAAQ,cAAA;QAEV,MAAM,kMAAO,mBAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAEN,OAAA,CAAA,GAAA;YACO;YACV,OAAA;6EAAS,CAAC,yBAAyB;oBACjC,MAAM,aAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GACD,OAAA,CAAA,GAAA;wBACH,MAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,SAAA,QAAA,SAAA,KAAA,IAAA,KAAA,IACK,KAAM,IAAA,GACL,uBACA;4BAAE,QAAQ,qBAAqB,MAAA;wBAAQ,IACvC;4BAAE,QAAQ;wBAAM;oBAAA;oBAIxB,OAAO,QAAQ,MAAA,CAAO,KAAA,CAAM,GAAG,cAAc,UAAU,WAAW,CAAC;gBACpE;;YAEH,QAAQ,WAAA,CACT;QAED,KAAK,IAAA,GAAO,cAAc;YACxB;QACD,EAAC;QAEF,OAAO;YAAC,KAAK,IAAA;YAAM,IAAY;SAAA;IAChC;IAED,SAASC,cACPR,IAAAA,EACAS,IAAAA,EAC0D;QAC1D,MAAM,EAAE,MAAA,EAAQ,WAAA,EAAa,GAAG,YAAY;QAE5C,MAAM,cAAc,6MAAA,EAAuB,KAAK;QAEhD,MAAM,cAAc,YAAY,sBAAA,CAC9B,YAAY,mBAAA,CAAoB,YAAY,CAC7C;QAED,MAAM,OAAO,oMAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAEN,OAAA,CAAA,GAAA;YACU;YACb,UAAA;mEAAY,CAAC,UAAU;oBACrB,OAAO,OAAO,QAAA,CAAS,GAAG,cAAc;wBAAC;wBAAM;4BAAE;wBAAO,CAAC;qBAAA,EAAE,KAAK,CAAC;gBAClE;;YACD,WAAU,GAAG,IAAA,EAAM;;gBACjB,MAAM;kFAAa,MACjB;;+GAAM,SAAA,MAAA,QAAA,qBAAA,KAAA,IAAA,KAAA,IAAN,iBAAA,IAAA,CAAA,MAAkB,GAAG,KAAK,MAAA,QAAA,oBAAA,KAAA,IAAA,kBAAA,gBAAA,QAAA,gBAAA,KAAA,KAAA,CAAA,wBAAI,YAAa,SAAA,MAAA,QAAA,0BAAA,KAAA,IAAA,KAAA,IAAb,sBAAA,IAAA,CAAA,aAAyB,GAAG,KAAK;;;gBAEjE,OAAO,wBAAwB;oBAC7B;oBACA;oBACA,MAAA,CAAA,QAAA,CAAA,aAAA,SAAA,QAAA,SAAA,KAAA,IAAA,KAAA,IAAM,KAAM,IAAA,MAAA,QAAA,eAAA,KAAA,IAAA,aAAA,gBAAA,QAAA,gBAAA,KAAA,IAAA,KAAA,IAAQ,YAAa,IAAA,MAAA,QAAA,UAAA,KAAA,IAAA,QAAQ,CAAE;gBAC5C,EAAC;YACH;YAEH,YACD;QAED,KAAK,IAAA,GAAO,cAAc;YACxB;QACD,EAAC;QAEF,OAAO;IACR;IACD,MAAMC,mBAAuE;QAC3E,MAAA,KAAA;QACA,OAAO;QACP,QAAQ;IACT;IAED,MAAMC,yBAGF;QACF,MAAA,KAAA;QACA,OAAO;QACP,QAAQ;IACT;4CAGD,SAAS,gBACPX,IAAAA,EACAC,KAAAA,EACAW,IAAAA,EACA;;QACA,MAAM,UAAA,CAAA,iBAAA,SAAA,QAAA,SAAA,KAAA,IAAA,KAAA,IAAU,KAAM,OAAA,MAAA,QAAA,mBAAA,KAAA,IAAA,iBAAW,qLAAU,YAAA;QAC3C,MAAM,0LAAW,UAAA,sLAAQ,sBAAA,EAAoB,MAAM,OAAO,MAAM,CAAC;QACjE,MAAM,EAAE,MAAA,EAAQ,GAAG,YAAY;QAE/B,MAAM,UAAU,8JAAM,MAAA,CAAoB,KAAK;QAC/C,8JAAM,SAAA;yDAAU,MAAM;gBACpB,QAAQ,OAAA,GAAU;YACnB,EAAC;;QAIF,MAAM,CAAC,aAAa,GAAG,8JAAM,QAAA,CAAS,IAAI,IAAmB,CAAE,CAAA,EAAE;QAEjE,MAAM,iBAAiB,8JAAM,WAAA;2EAC3B,CAACC,QAAuB;gBACtB,aAAa,GAAA,CAAI,IAAI;YACtB;0EACD;YAAC,YAAa;SAAA,CACf;QAED,MAAM,yBAAyB,8JAAM,MAAA,CAAuB,KAAK;QAEjE,MAAM,cAAc,8JAAM,WAAA;wEACxB,CAACC,aAA8C;gBAC7C,MAAM,OAAO,UAAU,OAAA;gBACvB,MAAM,OAAQ,UAAU,OAAA,GAAU,SAAS,KAAK;gBAEhD,IAAI,eAAe;gBACnB,KAAK,MAAM,OAAO,aAChB,IAAI,IAAA,CAAK,IAAA,KAAS,IAAA,CAAK,IAAA,EAAM;oBAC3B,eAAe;oBACf;gBACD;gBAEH,IAAI,aACF,CAAA,SAAS,YAAY,MAAM,eAAe,CAAC;YAE9C;uEACD;YAAC;YAAgB,YAAa;SAAA,CAC/B;QAED,MAAM,QAAQ,8JAAM,WAAA;kEAAY,MAAY;;gBAE1C,CAAA,wBAAA,uBAAuB,OAAA,MAAA,QAAA,0BAAA,KAAA,KAAvB,sBAAgC,WAAA,EAAa;gBAE7C,IAAA,CAAK,SAAS;oBACZ;8EAAY,IAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAY,mBAAA,CAAA,GAAA;gCAAkB;4BAAA,GAAS;;oBACnD;gBACD;gBACD;0EAAY,IAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAY,yBAAA,CAAA,GAAA;4BAAwB;wBAAA,GAAS;;gBACzD,MAAM,eAAe,OAAO,YAAA,CAC1B,KAAK,IAAA,CAAK,IAAI,EACd,UAAA,QAAA,UAAA,KAAA,IAAA,QAAA,KAAA,GACA;oBACE,SAAA;2FAAW,MAAM;;4BACf,CAAA,wBAAA,CAAA,mBAAA,QAAQ,OAAA,EAAQ,SAAA,MAAA,QAAA,0BAAA,KAAA,KAAhB,sBAAA,IAAA,CAAA,iBAA6B;4BAC7B;mGAAY,CAAC,OAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GACR,OAAA,CAAA,GAAA;wCACH,QAAQ;wCACR,OAAO;uCACN;;wBACJ;;oBACD,MAAA;2FAAQ,CAAC,SAAS;;4BAChB,CAAA,wBAAA,CAAA,oBAAA,QAAQ,OAAA,EAAQ,MAAA,MAAA,QAAA,0BAAA,KAAA,KAAhB,sBAAA,IAAA,CAAA,mBAAyB,KAAK;4BAC9B;mGAAY,CAAC,OAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GACR,OAAA,CAAA,GAAA;wCACH,QAAQ;wCACR;wCACA,OAAO;uCACN;;wBACJ;;oBACD,OAAA;2FAAS,CAAC,UAAU;;4BAClB,CAAA,wBAAA,CAAA,oBAAA,QAAQ,OAAA,EAAQ,OAAA,MAAA,QAAA,0BAAA,KAAA,KAAhB,sBAAA,IAAA,CAAA,mBAA0B,MAAM;4BAChC;mGAAY,CAAC,OAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GACR,OAAA,CAAA,GAAA;wCACH,QAAQ;wCACR;uCACC;;wBACJ;;oBACD,uBAAA;2FAAyB,CAAC,WAAW;4BACnC;mGAAY,CAAC,SAAS;oCACpB,OAAQ,OAAO,KAAA,EAAf;wCACE,KAAK,OACH;4CAAA,OAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GACK,OAAA,CAAA,GAAA;gDACH,QAAQ,OAAO,KAAA;gDACf,OAAO;gDACP,MAAA,KAAA;;wCAEJ,KAAK,aACH;4CAAA,OAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GACK,OAAA,CAAA,GAAA;gDACH,OAAO,OAAO,KAAA;gDACd,QAAQ,OAAO,KAAA;;wCAGnB,KAAK,UAEH;4CAAA,OAAO;oCACV;gCACF,EAAC;;wBACH;;oBACD,UAAA;2FAAY,MAAM;;4BAChB,CAAA,wBAAA,CAAA,oBAAA,QAAQ,OAAA,EAAQ,UAAA,MAAA,QAAA,0BAAA,KAAA,KAAhB,sBAAA,IAAA,CAAA,kBAA8B;4BAI9B;mGAAY,CAAC,OAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GACR,OAAA,CAAA,GAAA;wCACH,QAAQ;wCACR,OAAO;wCACP,MAAA,KAAA;uCACC;;wBAGJ;;gBACF,EACF;gBAED,uBAAuB,OAAA,GAAU;YAGlC;iEAAE;YAAC;YAAQ;YAAU;YAAS;SAAY,CAAC;QAC5C,8JAAM,SAAA;yDAAU,MAAM;gBACpB,OAAO;gBAEP;iEAAO,MAAM;;wBACX,CAAA,yBAAA,uBAAuB,OAAA,MAAA,QAAA,2BAAA,KAAA,KAAvB,uBAAgC,WAAA,EAAa;oBAC9C;;YACF;wDAAE;YAAC,KAAM;SAAA,CAAC;QAEX,MAAM,YAAY,8JAAM,MAAA,CACtB,UAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GACS,yBAAA,CAAA,GAAA;YAAwB;QAAA,KAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GACxB,mBAAA,CAAA,GAAA;YAAkB;QAAA,GAC5B;QAED,MAAM,CAAC,OAAO,SAAS,GAAG,8JAAM,QAAA,CAC9B,YAAY,UAAU,OAAA,EAAS,eAAe,CAC/C;QAED,OAAO;IACR;IAED,SAASC,mBACPf,IAAAA,EACAC,KAAAA,EACAe,IAAAA,EACsD;;QACtD,MAAM,EACJ,MAAA,EACA,QAAA,EACA,qBAAA,EACA,WAAA,EACA,cAAA,EACD,GAAG,YAAY;QAChB,MAAM,+LAAW,sBAAA,EAAoB,MAAM,OAAO,WAAW;QAE7D,MAAM,cAAc,YAAY,gBAAA,CAAiB,SAAS;QAE1D,MAAM,mBAAmB,qLAAU,YAAA;QAEnC,IAAA,OACS,WAAW,eAClB,aAAa,aAAA,CAAA,SAAA,QAAA,SAAA,KAAA,KAAA,CAAA,cACb,KAAM,IAAA,MAAA,QAAA,gBAAA,KAAA,IAAA,KAAA,IAAA,YAAM,GAAA,MAAQ,SAAA,CAAA,CAAA,iBAAA,SAAA,QAAA,SAAA,KAAA,IAAA,KAAA,IACnB,KAAM,OAAA,MAAA,QAAA,mBAAA,KAAA,IAAA,iBAAA,gBAAA,QAAA,gBAAA,KAAA,IAAA,KAAA,IAAW,YAAa,OAAA,MAAa,SAAA,CAC3C,oBAAA,CACA,YAAY,aAAA,EAAe,CAAC,IAAA,CAAK;YAAE;QAAU,EAAC,CAE/C,CAAK,sBAAsB,UAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAe,cAAgB,MAAc;QAG1E,MAAM,UAAU,2BAA2B,UAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GACtC,cACA,MACH;QAGF,MAAM,uBAAA,CAAA,yBAAA,SAAA,QAAA,SAAA,KAAA,KAAA,CAAA,cAAuB,KAAM,IAAA,MAAA,QAAA,gBAAA,KAAA,IAAA,KAAA,IAAA,YAAM,cAAA,MAAA,QAAA,2BAAA,KAAA,IAAA,yBAAkB;QAE3D,MAAM,kMAAO,mBAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAEN,UAAA,CAAA,GAAA;YACH,kBAAA,CAAA,sBAAkB,KAAK,aAAA,MAAA,QAAA,wBAAA,KAAA,IAAA,sBAAiB;YACxC,WAAW,KAAK,SAAA;YACN;YACV,SAAS,mBACL;6EACA,CAAC,yBAAyB;;oBACxB,MAAM,aAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GACD,UAAA,CAAA,GAAA;wBACH,MAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,YAAA,QAAA,YAAA,KAAA,IAAA,KAAA,IACK,QAAS,IAAA,GACR,uBACA;4BAAE,QAAQ,qBAAqB,MAAA;wBAAQ,IACvC;4BAAE,QAAQ;wBAAM;oBAAA;oBAIxB,OAAO,OAAO,KAAA,CACZ,GAAG,cAAc,UAAU,YAAY;wBACrC,WAAA,CAAA,wBACE,qBAAqB,SAAA,MAAA,QAAA,0BAAA,KAAA,IAAA,wBAAa,KAAK,aAAA;wBACzC,WAAW,qBAAqB,SAAA;oBACjC,EAAC,CACH;gBACF;;YAEP,YACD;QAED,KAAK,IAAA,GAAO,cAAc;YACxB;QACD,EAAC;QACF,OAAO;IACR;IAED,SAASC,2BACPb,IAAAA,EACAH,KAAAA,EACAiB,IAAAA,EACM;;QACN,MAAM,UAAU,YAAY;QAC5B,MAAM,WAAW,0MAAA,EAAoB,MAAM,OAAO,WAAW;QAE7D,MAAM,cAAc,QAAQ,WAAA,CAAY,gBAAA,CAAiB,SAAS;QAElE,MAAM,mBAAmB,qLAAU,YAAA;QAEnC,MAAM,UAAU,2BAA2B,UAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GACtC,cACA,MACH;QAGF,MAAM,uBAAA,CAAA,yBAAA,SAAA,QAAA,SAAA,KAAA,KAAA,CAAA,cACJ,KAAM,IAAA,MAAA,QAAA,gBAAA,KAAA,IAAA,KAAA,IAAA,YAAM,cAAA,MAAA,QAAA,2BAAA,KAAA,IAAA,yBAAkB,QAAQ,cAAA;QAExC,CAAA,GAAA,8LAAA,CAAA,2BAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GACK,OAAA,CAAA,GAAA;YACH,kBAAA,CAAA,uBAAkB,KAAK,aAAA,MAAA,QAAA,yBAAA,KAAA,IAAA,uBAAiB;YACxC;YACA,SAAS,mBACL;uFACA,CAAC,yBAAyB;;oBACxB,MAAM,aAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GACD,UAAA,CAAA,GAAA;wBACH,MAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,YAAA,QAAA,YAAA,KAAA,IAAA,KAAA,IACK,QAAS,IAAA,GACR,uBACA;4BAAE,QAAQ,qBAAqB,MAAA;wBAAQ,IACvC,CAAE;oBAAA;oBAIV,OAAO,QAAQ,MAAA,CAAO,KAAA,CACpB,GAAG,cAAc,UAAU,YAAY;wBACrC,WAAA,CAAA,yBAAW,qBAAqB,SAAA,MAAA,QAAA,2BAAA,KAAA,IAAA,yBAAa,KAAK,aAAA;wBAClD,WAAW,qBAAqB,SAAA;oBACjC,EAAC,CACH;gBACF;;WACL;IACH;IAED,SAASC,2BACPnB,IAAAA,EACAC,KAAAA,EACAmB,IAAAA,EAC8D;;QAC9D,MAAM,UAAU,YAAY;QAC5B,MAAM,+LAAW,sBAAA,EAAoB,MAAM,OAAO,WAAW;QAE7D,MAAM,cAAc,QAAQ,WAAA,CAAY,gBAAA,CAAiB,SAAS;QAElE,MAAM,UAAU,2BAA2B,UAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GACtC,cACA,MACH;QAGF,MAAM,uBAAA,CAAA,yBAAA,SAAA,QAAA,SAAA,KAAA,KAAA,CAAA,cACJ,KAAM,IAAA,MAAA,QAAA,gBAAA,KAAA,IAAA,KAAA,IAAA,YAAM,cAAA,MAAA,QAAA,2BAAA,KAAA,IAAA,yBAAkB,QAAQ,cAAA;QAExC,MAAM,OAAO,8NAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAEN,OAAA,CAAA,GAAA;YACH,kBAAA,CAAA,uBAAkB,KAAK,aAAA,MAAA,QAAA,yBAAA,KAAA,IAAA,uBAAiB;YACxC;YACA,OAAA;6FAAS,CAAC,yBAAyB;;oBACjC,MAAM,aAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GACD,UAAA,CAAA,GAAA;wBACH,MAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,YAAA,QAAA,YAAA,KAAA,IAAA,KAAA,IACK,QAAS,IAAA,GACR,uBACA;4BAAE,QAAQ,qBAAqB,MAAA;wBAAQ,IACvC,CAAE;oBAAA;oBAIV,OAAO,QAAQ,MAAA,CAAO,KAAA,CACpB,GAAG,cAAc,UAAU,YAAY;wBACrC,WAAA,CAAA,yBAAW,qBAAqB,SAAA,MAAA,QAAA,2BAAA,KAAA,IAAA,yBAAa,KAAK,aAAA;wBAClD,WAAW,qBAAqB,SAAA;oBACjC,EAAC,CACH;gBACF;;YAEH,QAAQ,WAAA,CACT;QAED,KAAK,IAAA,GAAO,cAAc;YACxB;QACD,EAAC;QAGF,OAAO;YAAC,KAAK,IAAA;YAAO,IAAY;SAAA;IACjC;IAED,MAAMC,eAAsC,CAAC,iBAAiB,YAAY;QACxE,MAAM,EAAE,QAAA,EAAU,WAAA,EAAa,aAAA,EAAe,MAAA,EAAQ,GAAG,YAAY;QAErE,MAAM,QAAQ,iBAAiB,OAAO;QAEtC,MAAM,UAAU,gBAAgB,MAAM;QAEtC,IAAA,OAAW,WAAW,eAAe,aAAa,UAChD,CAAA,KAAK,MAAM,SAAS,QAAS;;YAC3B,MAAM,cAAc;YACpB,IAAA,CAAA,CAAA,oBACE,YAAY,IAAA,MAAA,QAAA,sBAAA,KAAA,IAAA,KAAA,IAAA,kBAAM,GAAA,MAAQ,SAAA,CACzB,YAAY,aAAA,EAAe,CAAC,IAAA,CAAK;gBAAE,UAAU,YAAY,QAAA;YAAU,EAAC,CAErE,CAAK,cAAc,YAAY,QAAA,EAAU,YAAmB;QAE/D;QAGH,4LAAO,aAAA,EACL;YACE,SAAS,QAAQ,GAAA;2DAAI,CAAC,QAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GACjB,QAAA,CAAA,GAAA;wBACH,UAAW,MAAqC,QAAA;oBAAA,GAC/C;;YACH,SAAA,YAAA,QAAA,YAAA,KAAA,IAAA,KAAA,IAAS,QAAS,OAAA;QACnB,GACD,YACD;IACF;IAED,MAAMC,uBAAsD,CAC1D,oBACG;QACH,MAAM,EAAE,WAAA,EAAa,MAAA,EAAQ,GAAG,YAAY;QAE5C,MAAM,QAAQ,iBAAiB,OAAO;QAEtC,MAAM,UAAU,gBAAgB,MAAM;QAEtC,MAAM,oMAAO,qBAAA,EACX;YACE,SAAS,QAAQ,GAAA;iFAAI,CAAC,QAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GAAA,qBAAA,OAAA,EAAA,CAAA,GACjB,QAAA,CAAA,GAAA;wBACH,SAAS,MAAM,OAAA;wBACf,UAAW,MAAqC,QAAA;uBAC/C;;QACJ,GACD,YACD;QAED,OAAO;YAAC,KAAK,GAAA,CAAI,CAAC,IAAM,EAAE,IAAA,CAAK;YAAE,IAAK;SAAA;IACvC;IAED,OAAO;QACL,UAAU;QACV;QACA;QACA,UAAU;QACV,UAAA;QACA,kBAAA;QACA,kBAAA;QACA,YAAA;QACA,oBAAA;QACA,aAAA;QACA;QACA,kBAAA;QACA,0BAAA;QACA,0BAAA;IACD;AACF;;;;;GC9uBD,MAAa,iBAAiB,CAACC,WAC7B;;yCAAO,WAAA,MAAA,QAAA,wBAAA,KAAA,IAAA,sBAAe,qLAAI,cAAA,CAAY,OAAO,iBAAA;AAAkB","ignoreList":[0,1,2,3,4,5,6,7,8,9],"debugId":null}},
    {"offset": {"line": 11293, "column": 0}, "map": {"version":3,"file":"index.mjs","sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/react-query/src/createTRPCReact.tsx","file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40trpc/react-query/src/createTRPCQueryUtils.tsx"],"sourcesContent":["import type {\n  DefinedInitialDataInfiniteOptions,\n  DefinedUseInfiniteQueryResult,\n  InfiniteData,\n  SkipToken,\n  UndefinedInitialDataInfiniteOptions,\n  UseInfiniteQueryOptions,\n  UseInfiniteQueryResult,\n  UseSuspenseInfiniteQueryOptions,\n  UseSuspenseInfiniteQueryResult,\n  UseSuspenseQueryResult,\n} from '@tanstack/react-query';\nimport type { createTRPCClient, TRPCClientErrorLike } from '@trpc/client';\nimport type {\n  AnyProcedure,\n  AnyRootTypes,\n  AnyRouter,\n  inferAsyncIterableYield,\n  inferProcedureInput,\n  inferTransformedProcedureOutput,\n  ProcedureType,\n  ProtectedIntersection,\n  RouterRecord,\n  Simplify,\n} from '@trpc/server/unstable-core-do-not-import';\nimport { createFlatProxy } from '@trpc/server/unstable-core-do-not-import';\nimport * as React from 'react';\nimport type {\n  TRPCUseQueries,\n  TRPCUseSuspenseQueries,\n} from './internals/useQueries';\nimport type {\n  CreateReactUtils,\n  TRPCFetchInfiniteQueryOptions,\n  TRPCFetchQueryOptions,\n} from './shared';\nimport { createReactDecoration, createReactQueryUtils } from './shared';\nimport type { CreateReactQueryHooks } from './shared/hooks/createHooksInternal';\nimport { createRootHooks } from './shared/hooks/createHooksInternal';\nimport type {\n  DefinedUseTRPCQueryOptions,\n  DefinedUseTRPCQueryResult,\n  TRPCHookResult,\n  TRPCProvider,\n  TRPCSubscriptionResult,\n  TRPCUseQueryBaseOptions,\n  UseTRPCMutationOptions,\n  UseTRPCMutationResult,\n  UseTRPCQueryOptions,\n  UseTRPCQueryResult,\n  UseTRPCSubscriptionOptions,\n  UseTRPCSuspenseQueryOptions,\n} from './shared/hooks/types';\nimport type { CreateTRPCReactOptions } from './shared/types';\n\ntype ResolverDef = {\n  input: any;\n  output: any;\n  transformer: boolean;\n  errorShape: any;\n};\n/**\n * @internal\n */\nexport interface ProcedureUseQuery<TDef extends ResolverDef> {\n  <TQueryFnData extends TDef['output'] = TDef['output'], TData = TQueryFnData>(\n    input: TDef['input'] | SkipToken,\n    opts: DefinedUseTRPCQueryOptions<\n      TQueryFnData,\n      TData,\n      TRPCClientErrorLike<{\n        errorShape: TDef['errorShape'];\n        transformer: TDef['transformer'];\n      }>,\n      TDef['output']\n    >,\n  ): DefinedUseTRPCQueryResult<\n    TData,\n    TRPCClientErrorLike<{\n      errorShape: TDef['errorShape'];\n      transformer: TDef['transformer'];\n    }>\n  >;\n\n  <TQueryFnData extends TDef['output'] = TDef['output'], TData = TQueryFnData>(\n    input: TDef['input'] | SkipToken,\n    opts?: UseTRPCQueryOptions<\n      TQueryFnData,\n      TData,\n      TRPCClientErrorLike<TDef>,\n      TDef['output']\n    >,\n  ): UseTRPCQueryResult<TData, TRPCClientErrorLike<TDef>>;\n}\n\n/**\n * @internal\n */\nexport type ProcedureUsePrefetchQuery<TDef extends ResolverDef> = (\n  input: TDef['input'] | SkipToken,\n  opts?: TRPCFetchQueryOptions<TDef['output'], TRPCClientErrorLike<TDef>>,\n) => void;\n\n/**\n * @remark `void` is here due to https://github.com/trpc/trpc/pull/4374\n */\ntype CursorInput = {\n  cursor?: any;\n} | void;\n\ntype ReservedInfiniteQueryKeys = 'cursor' | 'direction';\ntype InfiniteInput<TInput> =\n  | Omit<TInput, ReservedInfiniteQueryKeys>\n  | SkipToken;\n\ntype inferCursorType<TInput> = TInput extends { cursor?: any }\n  ? TInput['cursor']\n  : unknown;\n\ntype makeInfiniteQueryOptions<TCursor, TOptions> = Omit<\n  TOptions,\n  'queryKey' | 'initialPageParam' | 'queryFn' | 'queryHash' | 'queryHashFn'\n> &\n  TRPCUseQueryBaseOptions & {\n    initialCursor?: TCursor;\n  };\n\ntype trpcInfiniteData<TDef extends ResolverDef> = Simplify<\n  InfiniteData<TDef['output'], inferCursorType<TDef['input']>>\n>;\n// references from react-query\n// 1st\n// declare function useInfiniteQuery<\n//   TQueryFnData,\n//   TError = DefaultError,\n//   TData = InfiniteData<TQueryFnData>,\n//   TQueryKey extends QueryKey = QueryKey,\n//   TPageParam = unknown,\n// >(\n//   options: DefinedInitialDataInfiniteOptions<\n//     TQueryFnData,\n//     TError,\n//     TData,\n//     TQueryKey,\n//     TPageParam\n//   >,\n//   queryClient?: QueryClient,\n// ): DefinedUseInfiniteQueryResult<TData, TError>;\n// 2nd\n// declare function useInfiniteQuery<\n//   TQueryFnData,\n//   TError = DefaultError,\n//   TData = InfiniteData<TQueryFnData>,\n//   TQueryKey extends QueryKey = QueryKey,\n//   TPageParam = unknown,\n// >(\n//   options: UndefinedInitialDataInfiniteOptions<\n//     TQueryFnData,\n//     TError,\n//     TData,\n//     TQueryKey,\n//     TPageParam\n//   >,\n//   queryClient?: QueryClient,\n// ): UseInfiniteQueryResult<TData, TError>;\n// 3rd\n// declare function useInfiniteQuery<\n//   TQueryFnData,\n//   TError = DefaultError,\n//   TData = InfiniteData<TQueryFnData>,\n//   TQueryKey extends QueryKey = QueryKey,\n//   TPageParam = unknown,\n// >(\n//   options: UseInfiniteQueryOptions<\n//     TQueryFnData,\n//     TError,\n//     TData,\n//     TQueryFnData,\n//     TQueryKey,\n//     TPageParam\n//   >,\n//   queryClient?: QueryClient,\n// ): UseInfiniteQueryResult<TData, TError>;\n\nexport interface useTRPCInfiniteQuery<TDef extends ResolverDef> {\n  // 1st\n  <TData = trpcInfiniteData<TDef>>(\n    input: InfiniteInput<TDef['input']>,\n    opts: makeInfiniteQueryOptions<\n      inferCursorType<TDef['input']>,\n      DefinedInitialDataInfiniteOptions<\n        //     TQueryFnData,\n        TDef['output'],\n        //     TError,\n        TRPCClientErrorLike<TDef>,\n        //     TData,\n        TData,\n        //     TQueryKey,\n        any,\n        //     TPageParam\n        inferCursorType<TDef['input']>\n      >\n    >,\n  ): TRPCHookResult &\n    DefinedUseInfiniteQueryResult<TData, TRPCClientErrorLike<TDef>>;\n\n  // 2nd\n  <TData = trpcInfiniteData<TDef>>(\n    input: InfiniteInput<TDef['input']>,\n    opts?: makeInfiniteQueryOptions<\n      inferCursorType<TDef['input']>,\n      UndefinedInitialDataInfiniteOptions<\n        //     TQueryFnData,\n        TDef['output'],\n        //     TError,\n        TRPCClientErrorLike<TDef>,\n        //     TData,\n        TData,\n        //     TQueryKey,\n        any,\n        //     TPageParam\n        inferCursorType<TDef['input']>\n      >\n    >,\n  ): TRPCHookResult & UseInfiniteQueryResult<TData, TRPCClientErrorLike<TDef>>;\n\n  // 3rd:\n  <TData = trpcInfiniteData<TDef>>(\n    input: InfiniteInput<TDef['input']>,\n    opts?: makeInfiniteQueryOptions<\n      inferCursorType<TDef['input']>,\n      UseInfiniteQueryOptions<\n        //     TQueryFnData,\n        TDef['output'],\n        //     TError,\n        TRPCClientErrorLike<TDef>,\n        //     TData,\n        TData,\n        //     TQueryKey,\n        any,\n        //     TPageParam\n        inferCursorType<TDef['input']>\n      >\n    >,\n  ): TRPCHookResult & UseInfiniteQueryResult<TData, TRPCClientErrorLike<TDef>>;\n}\n\n// references from react-query\n// declare function useSuspenseInfiniteQuery<\n//   TQueryFnData,\n//   TError = DefaultError,\n//   TData = InfiniteData<TQueryFnData>,\n//   TQueryKey extends QueryKey = QueryKey,\n//   TPageParam = unknown,\n// >(\n//   options: UseSuspenseInfiniteQueryOptions<\n//     TQueryFnData,\n//     TError,\n//     TData,\n//     TQueryFnData,\n//     TQueryKey,\n//     TPageParam\n//   >,\n//   queryClient?: QueryClient,\n// ): UseSuspenseInfiniteQueryResult<TData, TError>;\n\nexport type useTRPCSuspenseInfiniteQuery<TDef extends ResolverDef> = (\n  input: InfiniteInput<TDef['input']>,\n  opts: makeInfiniteQueryOptions<\n    inferCursorType<TDef['input']>,\n    UseSuspenseInfiniteQueryOptions<\n      //     TQueryFnData,\n      TDef['output'],\n      //     TError,\n      TRPCClientErrorLike<TDef>,\n      //     TData,\n      trpcInfiniteData<TDef>,\n      //     TQueryKey,\n      any,\n      //     TPageParam\n      inferCursorType<TDef['input']>\n    >\n  >,\n) => [\n  trpcInfiniteData<TDef>,\n  TRPCHookResult &\n    UseSuspenseInfiniteQueryResult<\n      trpcInfiniteData<TDef>,\n      TRPCClientErrorLike<TDef>\n    >,\n];\n\n/**\n * @internal\n */\nexport type MaybeDecoratedInfiniteQuery<TDef extends ResolverDef> =\n  TDef['input'] extends CursorInput\n    ? {\n        /**\n         * @see https://trpc.io/docs/v11/client/react/useInfiniteQuery\n         */\n        useInfiniteQuery: useTRPCInfiniteQuery<TDef>;\n        /**\n         * @see https://trpc.io/docs/client/react/suspense#usesuspenseinfinitequery\n         */\n        useSuspenseInfiniteQuery: useTRPCSuspenseInfiniteQuery<TDef>;\n\n        usePrefetchInfiniteQuery: (\n          input: Omit<TDef['input'], ReservedInfiniteQueryKeys> | SkipToken,\n          opts: TRPCFetchInfiniteQueryOptions<\n            TDef['input'],\n            TDef['output'],\n            TRPCClientErrorLike<TDef>\n          >,\n        ) => void;\n      }\n    : object;\n\n/**\n * @internal\n */\nexport type DecoratedQueryMethods<TDef extends ResolverDef> = {\n  /**\n   * @see https://trpc.io/docs/v11/client/react/useQuery\n   */\n  useQuery: ProcedureUseQuery<TDef>;\n  usePrefetchQuery: ProcedureUsePrefetchQuery<TDef>;\n  /**\n   * @see https://trpc.io/docs/v11/client/react/suspense#usesuspensequery\n   */\n  useSuspenseQuery: <\n    TQueryFnData extends TDef['output'] = TDef['output'],\n    TData = TQueryFnData,\n  >(\n    input: TDef['input'],\n    opts?: UseTRPCSuspenseQueryOptions<\n      TQueryFnData,\n      TData,\n      TRPCClientErrorLike<TDef>\n    >,\n  ) => [\n    TData,\n    UseSuspenseQueryResult<TData, TRPCClientErrorLike<TDef>> & TRPCHookResult,\n  ];\n};\n\n/**\n * @internal\n */\nexport type DecoratedQuery<TDef extends ResolverDef> =\n  MaybeDecoratedInfiniteQuery<TDef> & DecoratedQueryMethods<TDef>;\n\nexport type DecoratedMutation<TDef extends ResolverDef> = {\n  /**\n   * @see https://trpc.io/docs/v11/client/react/useMutation\n   */\n  useMutation: <TContext = unknown>(\n    opts?: UseTRPCMutationOptions<\n      TDef['input'],\n      TRPCClientErrorLike<TDef>,\n      TDef['output'],\n      TContext\n    >,\n  ) => UseTRPCMutationResult<\n    TDef['output'],\n    TRPCClientErrorLike<TDef>,\n    TDef['input'],\n    TContext\n  >;\n};\n\ninterface ProcedureUseSubscription<TDef extends ResolverDef> {\n  // Without skip token\n  (\n    input: TDef['input'],\n    opts?: UseTRPCSubscriptionOptions<\n      inferAsyncIterableYield<TDef['output']>,\n      TRPCClientErrorLike<TDef>\n    >,\n  ): TRPCSubscriptionResult<\n    inferAsyncIterableYield<TDef['output']>,\n    TRPCClientErrorLike<TDef>\n  >;\n\n  // With skip token\n  (\n    input: TDef['input'] | SkipToken,\n    opts?: Omit<\n      UseTRPCSubscriptionOptions<\n        inferAsyncIterableYield<TDef['output']>,\n        TRPCClientErrorLike<TDef>\n      >,\n      'enabled'\n    >,\n  ): TRPCSubscriptionResult<\n    inferAsyncIterableYield<TDef['output']>,\n    TRPCClientErrorLike<TDef>\n  >;\n}\n/**\n * @internal\n */\nexport type DecorateProcedure<\n  TType extends ProcedureType,\n  TDef extends ResolverDef,\n> = TType extends 'query'\n  ? DecoratedQuery<TDef>\n  : TType extends 'mutation'\n    ? DecoratedMutation<TDef>\n    : TType extends 'subscription'\n      ? {\n          /**\n           * @see https://trpc.io/docs/v11/subscriptions\n           */\n          useSubscription: ProcedureUseSubscription<TDef>;\n        }\n      : never;\n\n/**\n * @internal\n */\nexport type DecorateRouterRecord<\n  TRoot extends AnyRootTypes,\n  TRecord extends RouterRecord,\n> = {\n  [TKey in keyof TRecord]: TRecord[TKey] extends infer $Value\n    ? $Value extends AnyProcedure\n      ? DecorateProcedure<\n          $Value['_def']['type'],\n          {\n            input: inferProcedureInput<$Value>;\n            output: inferTransformedProcedureOutput<TRoot, $Value>;\n            transformer: TRoot['transformer'];\n            errorShape: TRoot['errorShape'];\n          }\n        >\n      : $Value extends RouterRecord\n        ? DecorateRouterRecord<TRoot, $Value>\n        : never\n    : never;\n};\n\n/**\n * @internal\n */\nexport type CreateTRPCReactBase<TRouter extends AnyRouter, TSSRContext> = {\n  /**\n   * @deprecated renamed to `useUtils` and will be removed in a future tRPC version\n   *\n   * @see https://trpc.io/docs/v11/client/react/useUtils\n   */\n  useContext(): CreateReactUtils<TRouter, TSSRContext>;\n  /**\n   * @see https://trpc.io/docs/v11/client/react/useUtils\n   */\n  useUtils(): CreateReactUtils<TRouter, TSSRContext>;\n  Provider: TRPCProvider<TRouter, TSSRContext>;\n  createClient: typeof createTRPCClient<TRouter>;\n  useQueries: TRPCUseQueries<TRouter>;\n  useSuspenseQueries: TRPCUseSuspenseQueries<TRouter>;\n};\n\nexport type CreateTRPCReact<\n  TRouter extends AnyRouter,\n  TSSRContext,\n> = ProtectedIntersection<\n  CreateTRPCReactBase<TRouter, TSSRContext>,\n  DecorateRouterRecord<\n    TRouter['_def']['_config']['$types'],\n    TRouter['_def']['record']\n  >\n>;\n\n/**\n * @internal\n */\nexport function createHooksInternal<\n  TRouter extends AnyRouter,\n  TSSRContext = unknown,\n>(trpc: CreateReactQueryHooks<TRouter, TSSRContext>) {\n  type CreateHooksInternal = CreateTRPCReact<TRouter, TSSRContext>;\n\n  const proxy = createReactDecoration<TRouter, TSSRContext>(\n    trpc,\n  ) as DecorateRouterRecord<\n    TRouter['_def']['_config']['$types'],\n    TRouter['_def']['record']\n  >;\n  return createFlatProxy<CreateHooksInternal>((key) => {\n    if (key === 'useContext' || key === 'useUtils') {\n      return () => {\n        const context = trpc.useUtils();\n        // create a stable reference of the utils context\n        return React.useMemo(() => {\n          return (createReactQueryUtils as any)(context);\n        }, [context]);\n      };\n    }\n\n    if (trpc.hasOwnProperty(key)) {\n      return (trpc as any)[key];\n    }\n\n    return proxy[key];\n  });\n}\n\nexport function createTRPCReact<\n  TRouter extends AnyRouter,\n  TSSRContext = unknown,\n>(\n  opts?: CreateTRPCReactOptions<TRouter>,\n): CreateTRPCReact<TRouter, TSSRContext> {\n  const hooks = createRootHooks<TRouter, TSSRContext>(opts);\n  const proxy = createHooksInternal<TRouter, TSSRContext>(hooks);\n\n  return proxy as any;\n}\n","import type { AnyRouter } from '@trpc/server/unstable-core-do-not-import';\nimport { createQueryUtilsProxy } from './shared';\nimport type { CreateQueryUtilsOptions } from './utils/createUtilityFunctions';\nimport { createUtilityFunctions } from './utils/createUtilityFunctions';\n\nexport function createTRPCQueryUtils<TRouter extends AnyRouter>(\n  opts: CreateQueryUtilsOptions<TRouter>,\n) {\n  const utils = createUtilityFunctions(opts);\n  return createQueryUtilsProxy<TRouter>(utils);\n}\n"],"names":["trpc: CreateReactQueryHooks<TRouter, TSSRContext>","opts?: CreateTRPCReactOptions<TRouter>","opts: CreateQueryUtilsOptions<TRouter>"],"mappings":";;;;;;;;;;;;;;;;;GA4dA,SAAgB,oBAGdA,IAAAA,EAAmD;IAGnD,MAAM,uLAAQ,wBAAA,EACZ,KACD;IAID,OAAO,gMAAA,EAAqC,CAAC,QAAQ;QACnD,IAAI,QAAQ,gBAAgB,QAAQ,WAClC,CAAA,OAAO,MAAM;YACX,MAAM,UAAU,KAAK,QAAA,EAAU;YAE/B,yKAAO,MAAM,IAAA;+CAAQ,MAAM;oBACzB,QAAQ,sMAAA,EAA8B,QAAQ;gBAC/C;8CAAE;gBAAC,OAAQ;aAAA,CAAC;QACd;QAGH,IAAI,KAAK,cAAA,CAAe,IAAI,CAC1B,CAAA,OAAQ,IAAA,CAAa,IAAA;QAGvB,OAAO,KAAA,CAAM,IAAA;IACd,EAAC;AACH;AAED,SAAgB,gBAIdC,IAAAA,EACuC;IACvC,MAAM,uLAAQ,kBAAA,EAAsC,KAAK;IACzD,MAAM,QAAQ,oBAA0C,MAAM;IAE9D,OAAO;AACR;;;AChgBD,SAAgB,qBACdC,IAAAA,EACA;IACA,MAAM,uLAAQ,yBAAA,EAAuB,KAAK;IAC1C,sLAAO,wBAAA,EAA+B,MAAM;AAC7C","ignoreList":[0,1],"debugId":null}},
    {"offset": {"line": 11358, "column": 0}, "map": {"version":3,"file":"double-indexed-kv.js","sourceRoot":"","sources":["../src/double-indexed-kv.ts"],"names":[],"mappings":";;;AAAM,MAAO,eAAe;IAA5B,aAAA;QACE,IAAA,CAAA,UAAU,GAAG,IAAI,GAAG,EAAQ,CAAC;QAC7B,IAAA,CAAA,UAAU,GAAG,IAAI,GAAG,EAAQ,CAAC;IAmB/B,CAAC;IAjBC,GAAG,CAAC,GAAM,EAAE,KAAQ,EAAA;QAClB,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;QAChC,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;IAClC,CAAC;IAED,QAAQ,CAAC,GAAM,EAAA;QACb,OAAO,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IAClC,CAAC;IAED,UAAU,CAAC,KAAQ,EAAA;QACjB,OAAO,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;IACpC,CAAC;IAED,KAAK,GAAA;QACH,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,CAAC;QACxB,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,CAAC;IAC1B,CAAC;CACF","debugId":null}},
    {"offset": {"line": 11387, "column": 0}, "map": {"version":3,"file":"registry.js","sourceRoot":"","sources":["../src/registry.ts"],"names":[],"mappings":";;;AAAA,OAAO,EAAE,eAAe,EAAE,MAAM,wBAAwB,CAAC;;AAEnD,MAAO,QAAQ;IAGnB,YAA6B,kBAAoC,CAAA;QAApC,IAAA,CAAA,kBAAkB,GAAlB,kBAAkB,CAAkB;QAFzD,IAAA,CAAA,EAAE,GAAG,oKAAI,kBAAe,EAAa,CAAC;IAEsB,CAAC;IAErE,QAAQ,CAAC,KAAQ,EAAE,UAAmB,EAAA;QACpC,IAAI,IAAI,CAAC,EAAE,CAAC,UAAU,CAAC,KAAK,CAAC,EAAE;YAC7B,OAAO;SACR;QAED,IAAI,CAAC,UAAU,EAAE;YACf,UAAU,GAAG,IAAI,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC;SAC7C;QAED,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;IACjC,CAAC;IAED,KAAK,GAAA;QACH,IAAI,CAAC,EAAE,CAAC,KAAK,EAAE,CAAC;IAClB,CAAC;IAED,aAAa,CAAC,KAAQ,EAAA;QACpB,OAAO,IAAI,CAAC,EAAE,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;IACnC,CAAC;IAED,QAAQ,CAAC,UAAkB,EAAA;QACzB,OAAO,IAAI,CAAC,EAAE,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;IACtC,CAAC;CACF","debugId":null}},
    {"offset": {"line": 11422, "column": 0}, "map": {"version":3,"file":"class-registry.js","sourceRoot":"","sources":["../src/class-registry.ts"],"names":[],"mappings":";;;AAAA,OAAO,EAAE,QAAQ,EAAE,MAAM,eAAe,CAAC;;AAQnC,MAAO,aAAc,0JAAQ,WAAe;IAChD,aAAA;QACE,KAAK,EAAC,CAAC,CAAC,EAAE,AAAC,CAAC,CAAC,IAAI,CAAC,CAAC;QAGb,IAAA,CAAA,mBAAmB,GAAG,IAAI,GAAG,EAAmB,CAAC;IAFzD,CAAC;IAID,QAAQ,CAAC,KAAY,EAAE,OAAkC,EAAA;QACvD,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE;YAC/B,IAAI,OAAO,CAAC,UAAU,EAAE;gBACtB,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,KAAK,EAAE,OAAO,CAAC,UAAU,CAAC,CAAC;aACzD;YAED,KAAK,CAAC,QAAQ,CAAC,KAAK,EAAE,OAAO,CAAC,UAAU,CAAC,CAAC;SAC3C,MAAM;YACL,KAAK,CAAC,QAAQ,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;SAChC;IACH,CAAC;IAED,eAAe,CAAC,KAAY,EAAA;QAC1B,OAAO,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;IAC7C,CAAC;CACF","debugId":null}},
    {"offset": {"line": 11452, "column": 0}, "map": {"version":3,"file":"util.js","sourceRoot":"","sources":["../src/util.ts"],"names":[],"mappings":";;;;;;AAAA,SAAS,WAAW,CAAI,MAAyB;IAC/C,IAAI,QAAQ,IAAI,MAAM,EAAE;QACtB,8CAA8C;QAC9C,OAAO,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;KAC9B;IAED,MAAM,MAAM,GAAQ,EAAE,CAAC;IAEvB,gDAAgD;IAChD,IAAK,MAAM,GAAG,IAAI,MAAM,CAAE;QACxB,IAAI,MAAM,CAAC,cAAc,CAAC,GAAG,CAAC,EAAE;YAC9B,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;SAC1B;KACF;IAED,OAAO,MAAM,CAAC;AAChB,CAAC;AAEK,SAAU,IAAI,CAClB,MAAyB,EACzB,SAA4B;IAE5B,MAAM,MAAM,GAAG,WAAW,CAAC,MAAM,CAAC,CAAC;IACnC,IAAI,MAAM,IAAI,MAAM,EAAE;QACpB,8CAA8C;QAC9C,OAAO,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;KAC/B;IAED,MAAM,cAAc,GAAG,MAAa,CAAC;IAErC,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,cAAc,CAAC,MAAM,EAAE,CAAC,EAAE,CAAE;QAC9C,MAAM,KAAK,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC;QAChC,IAAI,SAAS,CAAC,KAAK,CAAC,EAAE;YACpB,OAAO,KAAK,CAAC;SACd;KACF;IAED,OAAO,SAAS,CAAC;AACnB,CAAC;AAEK,SAAU,OAAO,CACrB,MAAyB,EACzB,GAAgC;IAEhC,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,EAAE,KAAK,CAAC,EAAE,CAAG,CAAD,EAAI,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC,CAAC;AACpE,CAAC;AAEK,SAAU,QAAQ,CAAI,GAAQ,EAAE,KAAQ;IAC5C,OAAO,GAAG,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;AACnC,CAAC;AAEK,SAAU,OAAO,CACrB,MAAW,EACX,SAA4B;IAE5B,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,CAAE;QACtC,MAAM,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;QACxB,IAAI,SAAS,CAAC,KAAK,CAAC,EAAE;YACpB,OAAO,KAAK,CAAC;SACd;KACF;IAED,OAAO,SAAS,CAAC;AACnB,CAAC","debugId":null}},
    {"offset": {"line": 11508, "column": 0}, "map": {"version":3,"file":"custom-transformer-registry.js","sourceRoot":"","sources":["../src/custom-transformer-registry.ts"],"names":[],"mappings":";;;AACA,OAAO,EAAE,IAAI,EAAE,MAAM,WAAW,CAAC;;AAS3B,MAAO,yBAAyB;IAAtC,aAAA;QACU,IAAA,CAAA,WAAW,GAA+C,CAAA,CAAE,CAAC;IAevE,CAAC;IAbC,QAAQ,CAAyB,WAAmC,EAAA;QAClE,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,IAAI,CAAC,GAAG,WAAW,CAAC;IACnD,CAAC;IAED,cAAc,CAAI,CAAI,EAAA;QACpB,wJAAO,OAAA,AAAI,EAAC,IAAI,CAAC,WAAW,GAAE,WAAW,CAAC,EAAE,AAC1C,WAAW,CAAC,YAAY,CAAC,CAAC,CAAC,CACkB,CAAC;IAClD,CAAC;IAED,UAAU,CAAC,IAAY,EAAA;QACrB,OAAO,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;IAChC,CAAC;CACF","debugId":null}},
    {"offset": {"line": 11533, "column": 0}, "map": {"version":3,"file":"is.js","sourceRoot":"","sources":["../src/is.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,MAAM,OAAO,GAAG,CAAC,OAAY,EAAU,CACrC,CADuC,KACjC,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;AAEhD,MAAM,WAAW,GAAG,CAAC,OAAY,EAAwB,CAC9D,CADgE,MACzD,OAAO,KAAK,WAAW,CAAC;AAE1B,MAAM,MAAM,GAAG,CAAC,OAAY,EAAmB,CAAG,CAAD,MAAQ,KAAK,IAAI,CAAC;AAEnE,MAAM,aAAa,GAAG,CAC3B,OAAY,EACuB,EAAE;IACrC,IAAI,OAAO,OAAO,KAAK,QAAQ,IAAI,OAAO,KAAK,IAAI,EAAE,OAAO,KAAK,CAAC;IAClE,IAAI,OAAO,KAAK,MAAM,CAAC,SAAS,EAAE,OAAO,KAAK,CAAC;IAC/C,IAAI,MAAM,CAAC,cAAc,CAAC,OAAO,CAAC,KAAK,IAAI,EAAE,OAAO,IAAI,CAAC;IAEzD,OAAO,MAAM,CAAC,cAAc,CAAC,OAAO,CAAC,KAAK,MAAM,CAAC,SAAS,CAAC;AAC7D,CAAC,CAAC;AAEK,MAAM,aAAa,GAAG,CAAC,OAAY,EAAiB,CACzD,CAD2D,YAC9C,CAAC,OAAO,CAAC,IAAI,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC;AAEvD,MAAM,OAAO,GAAG,CAAC,OAAY,EAAoB,CACtD,CADwD,IACnD,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;AAElB,MAAM,QAAQ,GAAG,CAAC,OAAY,EAAqB,CACxD,CAD0D,MACnD,OAAO,KAAK,QAAQ,CAAC;AAEvB,MAAM,QAAQ,GAAG,CAAC,OAAY,EAAqB,CACxD,CAD0D,MACnD,OAAO,KAAK,QAAQ,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;AAE1C,MAAM,SAAS,GAAG,CAAC,OAAY,EAAsB,CAC1D,CAD4D,MACrD,OAAO,KAAK,SAAS,CAAC;AAExB,MAAM,QAAQ,GAAG,CAAC,OAAY,EAAqB,CACxD,CAD0D,MACnD,YAAY,MAAM,CAAC;AAErB,MAAM,KAAK,GAAG,CAAC,OAAY,EAA4B,CAC5D,CAD8D,MACvD,YAAY,GAAG,CAAC;AAElB,MAAM,KAAK,GAAG,CAAC,OAAY,EAAuB,CACvD,CADyD,MAClD,YAAY,GAAG,CAAC;AAElB,MAAM,QAAQ,GAAG,CAAC,OAAY,EAAqB,CACxD,CAD0D,MACnD,CAAC,OAAO,CAAC,KAAK,QAAQ,CAAC;AAEzB,MAAM,MAAM,GAAG,CAAC,OAAY,EAAmB,CACpD,CADsD,MAC/C,YAAY,IAAI,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC;AAEhD,MAAM,OAAO,GAAG,CAAC,OAAY,EAAoB,CACtD,CADwD,MACjD,YAAY,KAAK,CAAC;AAEpB,MAAM,UAAU,GAAG,CAAC,OAAY,EAAyB,CAC9D,CADgE,MACzD,OAAO,KAAK,QAAQ,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC;AAEzC,MAAM,WAAW,GAAG,CACzB,OAAY,EACsD,CAClE,CADoE,QAC3D,CAAC,OAAO,CAAC,IAClB,MAAM,CAAC,OAAO,CAAC,IACf,WAAW,CAAC,OAAO,CAAC,IACpB,QAAQ,CAAC,OAAO,CAAC,IACjB,QAAQ,CAAC,OAAO,CAAC,IACjB,QAAQ,CAAC,OAAO,CAAC,CAAC;AAEb,MAAM,QAAQ,GAAG,CAAC,OAAY,EAAqB,CACxD,CAD0D,MACnD,OAAO,KAAK,QAAQ,CAAC;AAEvB,MAAM,UAAU,GAAG,CAAC,OAAY,EAAqB,CAC1D,CAD4D,MACrD,KAAK,QAAQ,IAAI,OAAO,KAAK,CAAC,QAAQ,CAAC;AAezC,MAAM,YAAY,GAAG,CAAC,OAAY,EAAyB,CAChE,CADkE,UACvD,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,OAAO,YAAY,QAAQ,CAAC,CAAC;AAEzD,MAAM,KAAK,GAAG,CAAC,OAAY,EAAkB,CAAG,CAAD,MAAQ,YAAY,GAAG,CAAC","debugId":null}},
    {"offset": {"line": 11587, "column": 0}, "map": {"version":3,"file":"pathstringifier.js","sourceRoot":"","sources":["../src/pathstringifier.ts"],"names":[],"mappings":";;;;;AAGO,MAAM,SAAS,GAAG,CAAC,GAAW,EAAE,CAAG,CAAD,EAAI,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;AAE7D,MAAM,aAAa,GAAG,CAAC,IAAU,EAAmB,CACzD,CAD2D,GACvD,CACD,GAAG,CAAC,MAAM,CAAC,CACX,GAAG,CAAC,SAAS,CAAC,CACd,IAAI,CAAC,GAAG,CAAC,CAAC;AAER,MAAM,SAAS,GAAG,CAAC,MAAuB,EAAE,EAAE;IACnD,MAAM,MAAM,GAAa,EAAE,CAAC;IAE5B,IAAI,OAAO,GAAG,EAAE,CAAC;IACjB,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,CAAE;QACtC,IAAI,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;QAE5B,MAAM,YAAY,GAAG,IAAI,KAAK,IAAI,IAAI,MAAM,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,KAAK,GAAG,CAAC;QACnE,IAAI,YAAY,EAAE;YAChB,OAAO,IAAI,GAAG,CAAC;YACf,CAAC,EAAE,CAAC;YACJ,SAAS;SACV;QAED,MAAM,cAAc,GAAG,IAAI,KAAK,GAAG,CAAC;QACpC,IAAI,cAAc,EAAE;YAClB,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;YACrB,OAAO,GAAG,EAAE,CAAC;YACb,SAAS;SACV;QAED,OAAO,IAAI,IAAI,CAAC;KACjB;IAED,MAAM,WAAW,GAAG,OAAO,CAAC;IAC5B,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;IAEzB,OAAO,MAAM,CAAC;AAChB,CAAC,CAAC","debugId":null}},
    {"offset": {"line": 11623, "column": 0}, "map": {"version":3,"file":"transformer.js","sourceRoot":"","sources":["../src/transformer.ts"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 11854, "column": 0}, "map": {"version":3,"file":"accessDeep.js","sourceRoot":"","sources":["../src/accessDeep.ts"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 11983, "column": 0}, "map": {"version":3,"file":"plainer.js","sourceRoot":"","sources":["../src/plainer.ts"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 12174, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/is-what/dist/index.js"],"sourcesContent":["function getType(payload) {\n  return Object.prototype.toString.call(payload).slice(8, -1);\n}\n\nfunction isAnyObject(payload) {\n  return getType(payload) === \"Object\";\n}\n\nfunction isArray(payload) {\n  return getType(payload) === \"Array\";\n}\n\nfunction isBlob(payload) {\n  return getType(payload) === \"Blob\";\n}\n\nfunction isBoolean(payload) {\n  return getType(payload) === \"Boolean\";\n}\n\nfunction isDate(payload) {\n  return getType(payload) === \"Date\" && !isNaN(payload);\n}\n\nfunction isEmptyArray(payload) {\n  return isArray(payload) && payload.length === 0;\n}\n\nfunction isPlainObject(payload) {\n  if (getType(payload) !== \"Object\")\n    return false;\n  const prototype = Object.getPrototypeOf(payload);\n  return !!prototype && prototype.constructor === Object && prototype === Object.prototype;\n}\n\nfunction isEmptyObject(payload) {\n  return isPlainObject(payload) && Object.keys(payload).length === 0;\n}\n\nfunction isEmptyString(payload) {\n  return payload === \"\";\n}\n\nfunction isError(payload) {\n  return getType(payload) === \"Error\" || payload instanceof Error;\n}\n\nfunction isFile(payload) {\n  return getType(payload) === \"File\";\n}\n\nfunction isFullArray(payload) {\n  return isArray(payload) && payload.length > 0;\n}\n\nfunction isFullObject(payload) {\n  return isPlainObject(payload) && Object.keys(payload).length > 0;\n}\n\nfunction isString(payload) {\n  return getType(payload) === \"String\";\n}\n\nfunction isFullString(payload) {\n  return isString(payload) && payload !== \"\";\n}\n\nfunction isFunction(payload) {\n  return typeof payload === \"function\";\n}\n\nfunction isType(payload, type) {\n  if (!(type instanceof Function)) {\n    throw new TypeError(\"Type must be a function\");\n  }\n  if (!Object.prototype.hasOwnProperty.call(type, \"prototype\")) {\n    throw new TypeError(\"Type is not a class\");\n  }\n  const name = type.name;\n  return getType(payload) === name || Boolean(payload && payload.constructor === type);\n}\n\nfunction isInstanceOf(value, classOrClassName) {\n  if (typeof classOrClassName === \"function\") {\n    for (let p = value; p; p = Object.getPrototypeOf(p)) {\n      if (isType(p, classOrClassName)) {\n        return true;\n      }\n    }\n    return false;\n  } else {\n    for (let p = value; p; p = Object.getPrototypeOf(p)) {\n      if (getType(p) === classOrClassName) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\nfunction isMap(payload) {\n  return getType(payload) === \"Map\";\n}\n\nfunction isNaNValue(payload) {\n  return getType(payload) === \"Number\" && isNaN(payload);\n}\n\nfunction isNumber(payload) {\n  return getType(payload) === \"Number\" && !isNaN(payload);\n}\n\nfunction isNegativeNumber(payload) {\n  return isNumber(payload) && payload < 0;\n}\n\nfunction isNull(payload) {\n  return getType(payload) === \"Null\";\n}\n\nfunction isOneOf(a, b, c, d, e) {\n  return (value) => a(value) || b(value) || !!c && c(value) || !!d && d(value) || !!e && e(value);\n}\n\nfunction isUndefined(payload) {\n  return getType(payload) === \"Undefined\";\n}\n\nconst isNullOrUndefined = isOneOf(isNull, isUndefined);\n\nfunction isObject(payload) {\n  return isPlainObject(payload);\n}\n\nfunction isObjectLike(payload) {\n  return isAnyObject(payload);\n}\n\nfunction isPositiveNumber(payload) {\n  return isNumber(payload) && payload > 0;\n}\n\nfunction isSymbol(payload) {\n  return getType(payload) === \"Symbol\";\n}\n\nfunction isPrimitive(payload) {\n  return isBoolean(payload) || isNull(payload) || isUndefined(payload) || isNumber(payload) || isString(payload) || isSymbol(payload);\n}\n\nfunction isPromise(payload) {\n  return getType(payload) === \"Promise\";\n}\n\nfunction isRegExp(payload) {\n  return getType(payload) === \"RegExp\";\n}\n\nfunction isSet(payload) {\n  return getType(payload) === \"Set\";\n}\n\nfunction isWeakMap(payload) {\n  return getType(payload) === \"WeakMap\";\n}\n\nfunction isWeakSet(payload) {\n  return getType(payload) === \"WeakSet\";\n}\n\nexport { getType, isAnyObject, isArray, isBlob, isBoolean, isDate, isEmptyArray, isEmptyObject, isEmptyString, isError, isFile, isFullArray, isFullObject, isFullString, isFunction, isInstanceOf, isMap, isNaNValue, isNegativeNumber, isNull, isNullOrUndefined, isNumber, isObject, isObjectLike, isOneOf, isPlainObject, isPositiveNumber, isPrimitive, isPromise, isRegExp, isSet, isString, isSymbol, isType, isUndefined, isWeakMap, isWeakSet };\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 12352, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/copy-anything/dist/index.js"],"sourcesContent":["import { isArray, isPlainObject } from 'is-what';\n\nfunction assignProp(carry, key, newVal, originalObject, includeNonenumerable) {\n  const propType = {}.propertyIsEnumerable.call(originalObject, key) ? \"enumerable\" : \"nonenumerable\";\n  if (propType === \"enumerable\")\n    carry[key] = newVal;\n  if (includeNonenumerable && propType === \"nonenumerable\") {\n    Object.defineProperty(carry, key, {\n      value: newVal,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    });\n  }\n}\nfunction copy(target, options = {}) {\n  if (isArray(target)) {\n    return target.map((item) => copy(item, options));\n  }\n  if (!isPlainObject(target)) {\n    return target;\n  }\n  const props = Object.getOwnPropertyNames(target);\n  const symbols = Object.getOwnPropertySymbols(target);\n  return [...props, ...symbols].reduce((carry, key) => {\n    if (isArray(options.props) && !options.props.includes(key)) {\n      return carry;\n    }\n    const val = target[key];\n    const newVal = copy(val, options);\n    assignProp(carry, key, newVal, target, options.nonenumerable);\n    return carry;\n  }, {});\n}\n\nexport { copy };\n"],"names":[],"mappings":";;;AAAA;;AAEA,SAAS,WAAW,KAAK,EAAE,GAAG,EAAE,MAAM,EAAE,cAAc,EAAE,oBAAoB;IAC1E,MAAM,WAAW,CAAA,CAAC,CAAA,EAAE,oBAAoB,CAAC,IAAI,CAAC,gBAAgB,OAAO,eAAe;IACpF,IAAI,aAAa,cACf,KAAK,CAAC,IAAI,GAAG;IACf,IAAI,wBAAwB,aAAa,iBAAiB;QACxD,OAAO,cAAc,CAAC,OAAO,KAAK;YAChC,OAAO;YACP,YAAY;YACZ,UAAU;YACV,cAAc;QAChB;IACF;AACF;AACA,SAAS,KAAK,MAAM,EAAE,UAAU,CAAC,CAAC;IAChC,IAAI,CAAA,GAAA,8IAAA,CAAA,UAAO,AAAD,EAAE,SAAS;QACnB,OAAO,OAAO,GAAG,CAAC,CAAC,OAAS,KAAK,MAAM;IACzC;IACA,IAAI,CAAC,CAAA,GAAA,8IAAA,CAAA,gBAAa,AAAD,EAAE,SAAS;QAC1B,OAAO;IACT;IACA,MAAM,QAAQ,OAAO,mBAAmB,CAAC;IACzC,MAAM,UAAU,OAAO,qBAAqB,CAAC;IAC7C,OAAO;WAAI;WAAU;KAAQ,CAAC,MAAM,CAAC,CAAC,OAAO;QAC3C,IAAI,CAAA,GAAA,8IAAA,CAAA,UAAO,AAAD,EAAE,QAAQ,KAAK,KAAK,CAAC,QAAQ,KAAK,CAAC,QAAQ,CAAC,MAAM;YAC1D,OAAO;QACT;QACA,MAAM,MAAM,MAAM,CAAC,IAAI;QACvB,MAAM,SAAS,KAAK,KAAK;QACzB,WAAW,OAAO,KAAK,QAAQ,QAAQ,QAAQ,aAAa;QAC5D,OAAO;IACT,GAAG,CAAC;AACN","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 12398, "column": 0}, "map": {"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 12508, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/%40tanstack/query-core/src/hydration.ts"],"sourcesContent":["import { tryResolveSync } from './thenable'\nimport type {\n  DefaultError,\n  MutationKey,\n  MutationMeta,\n  MutationOptions,\n  MutationScope,\n  QueryKey,\n  QueryMeta,\n  QueryOptions,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport type { Query, QueryState } from './query'\nimport type { Mutation, MutationState } from './mutation'\n\n// TYPES\ntype TransformerFn = (data: any) => any\nfunction defaultTransformerFn(data: any): any {\n  return data\n}\n\nexport interface DehydrateOptions {\n  serializeData?: TransformerFn\n  shouldDehydrateMutation?: (mutation: Mutation) => boolean\n  shouldDehydrateQuery?: (query: Query) => boolean\n  shouldRedactErrors?: (error: unknown) => boolean\n}\n\nexport interface HydrateOptions {\n  defaultOptions?: {\n    deserializeData?: TransformerFn\n    queries?: QueryOptions\n    mutations?: MutationOptions<unknown, DefaultError, unknown, unknown>\n  }\n}\n\ninterface DehydratedMutation {\n  mutationKey?: MutationKey\n  state: MutationState\n  meta?: MutationMeta\n  scope?: MutationScope\n}\n\ninterface DehydratedQuery {\n  queryHash: string\n  queryKey: QueryKey\n  state: QueryState\n  promise?: Promise<unknown>\n  meta?: QueryMeta\n  // This is only optional because older versions of Query might have dehydrated\n  // without it which we need to handle for backwards compatibility.\n  // This should be changed to required in the future.\n  dehydratedAt?: number\n}\n\nexport interface DehydratedState {\n  mutations: Array<DehydratedMutation>\n  queries: Array<DehydratedQuery>\n}\n\n// FUNCTIONS\n\nfunction dehydrateMutation(mutation: Mutation): DehydratedMutation {\n  return {\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state,\n    ...(mutation.options.scope && { scope: mutation.options.scope }),\n    ...(mutation.meta && { meta: mutation.meta }),\n  }\n}\n\n// Most config is not dehydrated but instead meant to configure again when\n// consuming the de/rehydrated data, typically with useQuery on the client.\n// Sometimes it might make sense to prefetch data on the server and include\n// in the html-payload, but not consume it on the initial render.\nfunction dehydrateQuery(\n  query: Query,\n  serializeData: TransformerFn,\n  shouldRedactErrors: (error: unknown) => boolean,\n): DehydratedQuery {\n  return {\n    dehydratedAt: Date.now(),\n    state: {\n      ...query.state,\n      ...(query.state.data !== undefined && {\n        data: serializeData(query.state.data),\n      }),\n    },\n    queryKey: query.queryKey,\n    queryHash: query.queryHash,\n    ...(query.state.status === 'pending' && {\n      promise: query.promise?.then(serializeData).catch((error) => {\n        if (!shouldRedactErrors(error)) {\n          // Reject original error if it should not be redacted\n          return Promise.reject(error)\n        }\n        // If not in production, log original error before rejecting redacted error\n        if (process.env.NODE_ENV !== 'production') {\n          console.error(\n            `A query that was dehydrated as pending ended up rejecting. [${query.queryHash}]: ${error}; The error will be redacted in production builds`,\n          )\n        }\n        return Promise.reject(new Error('redacted'))\n      }),\n    }),\n    ...(query.meta && { meta: query.meta }),\n  }\n}\n\nexport function defaultShouldDehydrateMutation(mutation: Mutation) {\n  return mutation.state.isPaused\n}\n\nexport function defaultShouldDehydrateQuery(query: Query) {\n  return query.state.status === 'success'\n}\n\nfunction defaultShouldRedactErrors(_: unknown) {\n  return true\n}\n\nexport function dehydrate(\n  client: QueryClient,\n  options: DehydrateOptions = {},\n): DehydratedState {\n  const filterMutation =\n    options.shouldDehydrateMutation ??\n    client.getDefaultOptions().dehydrate?.shouldDehydrateMutation ??\n    defaultShouldDehydrateMutation\n\n  const mutations = client\n    .getMutationCache()\n    .getAll()\n    .flatMap((mutation) =>\n      filterMutation(mutation) ? [dehydrateMutation(mutation)] : [],\n    )\n\n  const filterQuery =\n    options.shouldDehydrateQuery ??\n    client.getDefaultOptions().dehydrate?.shouldDehydrateQuery ??\n    defaultShouldDehydrateQuery\n\n  const shouldRedactErrors =\n    options.shouldRedactErrors ??\n    client.getDefaultOptions().dehydrate?.shouldRedactErrors ??\n    defaultShouldRedactErrors\n\n  const serializeData =\n    options.serializeData ??\n    client.getDefaultOptions().dehydrate?.serializeData ??\n    defaultTransformerFn\n\n  const queries = client\n    .getQueryCache()\n    .getAll()\n    .flatMap((query) =>\n      filterQuery(query)\n        ? [dehydrateQuery(query, serializeData, shouldRedactErrors)]\n        : [],\n    )\n\n  return { mutations, queries }\n}\n\nexport function hydrate(\n  client: QueryClient,\n  dehydratedState: unknown,\n  options?: HydrateOptions,\n): void {\n  if (typeof dehydratedState !== 'object' || dehydratedState === null) {\n    return\n  }\n\n  const mutationCache = client.getMutationCache()\n  const queryCache = client.getQueryCache()\n  const deserializeData =\n    options?.defaultOptions?.deserializeData ??\n    client.getDefaultOptions().hydrate?.deserializeData ??\n    defaultTransformerFn\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  const mutations = (dehydratedState as DehydratedState).mutations || []\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  const queries = (dehydratedState as DehydratedState).queries || []\n\n  mutations.forEach(({ state, ...mutationOptions }) => {\n    mutationCache.build(\n      client,\n      {\n        ...client.getDefaultOptions().hydrate?.mutations,\n        ...options?.defaultOptions?.mutations,\n        ...mutationOptions,\n      },\n      state,\n    )\n  })\n\n  queries.forEach(\n    ({ queryKey, state, queryHash, meta, promise, dehydratedAt }) => {\n      const syncData = promise ? tryResolveSync(promise) : undefined\n      const rawData = state.data === undefined ? syncData?.data : state.data\n      const data = rawData === undefined ? rawData : deserializeData(rawData)\n\n      let query = queryCache.get(queryHash)\n      const existingQueryIsPending = query?.state.status === 'pending'\n      const existingQueryIsFetching = query?.state.fetchStatus === 'fetching'\n\n      // Do not hydrate if an existing query exists with newer data\n      if (query) {\n        const hasNewerSyncData =\n          syncData &&\n          // We only need this undefined check to handle older dehydration\n          // payloads that might not have dehydratedAt\n          dehydratedAt !== undefined &&\n          dehydratedAt > query.state.dataUpdatedAt\n        if (\n          state.dataUpdatedAt > query.state.dataUpdatedAt ||\n          hasNewerSyncData\n        ) {\n          // omit fetchStatus from dehydrated state\n          // so that query stays in its current fetchStatus\n          const { fetchStatus: _ignored, ...serializedState } = state\n          query.setState({\n            ...serializedState,\n            data,\n          })\n        }\n      } else {\n        // Restore query\n        query = queryCache.build(\n          client,\n          {\n            ...client.getDefaultOptions().hydrate?.queries,\n            ...options?.defaultOptions?.queries,\n            queryKey,\n            queryHash,\n            meta,\n          },\n          // Reset fetch status to idle to avoid\n          // query being stuck in fetching state upon hydration\n          {\n            ...state,\n            data,\n            fetchStatus: 'idle',\n            status: data !== undefined ? 'success' : state.status,\n          },\n        )\n      }\n\n      if (\n        promise &&\n        !existingQueryIsPending &&\n        !existingQueryIsFetching &&\n        // Only hydrate if dehydration is newer than any existing data,\n        // this is always true for new queries\n        (dehydratedAt === undefined || dehydratedAt > query.state.dataUpdatedAt)\n      ) {\n        // This doesn't actually fetch - it just creates a retryer\n        // which will re-use the passed `initialPromise`\n        // Note that we need to call these even when data was synchronously\n        // available, as we still need to set up the retryer\n        void query.fetch(undefined, {\n          // RSC transformed promises are not thenable\n          initialPromise: Promise.resolve(promise).then(deserializeData),\n        })\n      }\n    },\n  )\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 12652, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/next/src/shared/lib/router/utils/handle-smooth-scroll.ts"],"sourcesContent":["/**\n * Run function with `scroll-behavior: auto` applied to `<html/>`.\n * This css change will be reverted after the function finishes.\n */\nexport function handleSmoothScroll(\n  fn: () => void,\n  options: { dontForceLayout?: boolean; onlyHashChange?: boolean } = {}\n) {\n  // if only the hash is changed, we don't need to disable smooth scrolling\n  // we only care to prevent smooth scrolling when navigating to a new page to avoid jarring UX\n  if (options.onlyHashChange) {\n    fn()\n    return\n  }\n  const htmlElement = document.documentElement\n  const existing = htmlElement.style.scrollBehavior\n  htmlElement.style.scrollBehavior = 'auto'\n  if (!options.dontForceLayout) {\n    // In Chrome-based browsers we need to force reflow before calling `scrollTo`.\n    // Otherwise it will not pickup the change in scrollBehavior\n    // More info here: https://github.com/vercel/next.js/issues/40719#issuecomment-1336248042\n    htmlElement.getClientRects()\n  }\n  fn()\n  htmlElement.style.scrollBehavior = existing\n}\n"],"names":["handleSmoothScroll","fn","options","onlyHashChange","htmlElement","document","documentElement","existing","style","scrollBehavior","dontForceLayout","getClientRects"],"mappings":"AAAA;;;CAGC,GAAA;;;;+BACeA,sBAAAA;;;eAAAA;;;AAAT,SAASA,mBACdC,EAAc,EACdC,OAAqE;IAArEA,IAAAA,YAAAA,KAAAA,GAAAA,UAAmE,CAAC;IAEpE,yEAAyE;IACzE,6FAA6F;IAC7F,IAAIA,QAAQC,cAAc,EAAE;QAC1BF;QACA;IACF;IACA,MAAMG,cAAcC,SAASC,eAAe;IAC5C,MAAMC,WAAWH,YAAYI,KAAK,CAACC,cAAc;IACjDL,YAAYI,KAAK,CAACC,cAAc,GAAG;IACnC,IAAI,CAACP,QAAQQ,eAAe,EAAE;QAC5B,8EAA8E;QAC9E,4DAA4D;QAC5D,yFAAyF;QACzFN,YAAYO,cAAc;IAC5B;IACAV;IACAG,YAAYI,KAAK,CAACC,cAAc,GAAGF;AACrC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 12690, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/next/src/client/components/layout-router.tsx"],"sourcesContent":["'use client'\n\nimport type {\n  CacheNode,\n  LazyCacheNode,\n  LoadingModuleData,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../server/app-render/types'\nimport type { ErrorComponent } from './error-boundary'\nimport {\n  ACTION_SERVER_PATCH,\n  type FocusAndScrollRef,\n} from './router-reducer/router-reducer-types'\n\nimport React, {\n  useContext,\n  use,\n  startTransition,\n  Suspense,\n  useDeferredValue,\n  type JSX,\n} from 'react'\nimport ReactDOM from 'react-dom'\nimport {\n  LayoutRouterContext,\n  GlobalLayoutRouterContext,\n  TemplateContext,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport { fetchServerResponse } from './router-reducer/fetch-server-response'\nimport { unresolvedThenable } from './unresolved-thenable'\nimport { ErrorBoundary } from './error-boundary'\nimport { matchSegment } from './match-segments'\nimport { handleSmoothScroll } from '../../shared/lib/router/utils/handle-smooth-scroll'\nimport { RedirectBoundary } from './redirect-boundary'\nimport { HTTPAccessFallbackBoundary } from './http-access-fallback/error-boundary'\nimport { createRouterCacheKey } from './router-reducer/create-router-cache-key'\nimport { hasInterceptionRouteInCurrentTree } from './router-reducer/reducers/has-interception-route-in-current-tree'\nimport { dispatchAppRouterAction } from './use-action-queue'\n\n/**\n * Add refetch marker to router state at the point of the current layout segment.\n * This ensures the response returned is not further down than the current layout segment.\n */\nfunction walkAddRefetch(\n  segmentPathToWalk: FlightSegmentPath | undefined,\n  treeToRecreate: FlightRouterState\n): FlightRouterState {\n  if (segmentPathToWalk) {\n    const [segment, parallelRouteKey] = segmentPathToWalk\n    const isLast = segmentPathToWalk.length === 2\n\n    if (matchSegment(treeToRecreate[0], segment)) {\n      if (treeToRecreate[1].hasOwnProperty(parallelRouteKey)) {\n        if (isLast) {\n          const subTree = walkAddRefetch(\n            undefined,\n            treeToRecreate[1][parallelRouteKey]\n          )\n          return [\n            treeToRecreate[0],\n            {\n              ...treeToRecreate[1],\n              [parallelRouteKey]: [\n                subTree[0],\n                subTree[1],\n                subTree[2],\n                'refetch',\n              ],\n            },\n          ]\n        }\n\n        return [\n          treeToRecreate[0],\n          {\n            ...treeToRecreate[1],\n            [parallelRouteKey]: walkAddRefetch(\n              segmentPathToWalk.slice(2),\n              treeToRecreate[1][parallelRouteKey]\n            ),\n          },\n        ]\n      }\n    }\n  }\n\n  return treeToRecreate\n}\n\nconst __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = (\n  ReactDOM as any\n).__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE\n\n// TODO-APP: Replace with new React API for finding dom nodes without a `ref` when available\n/**\n * Wraps ReactDOM.findDOMNode with additional logic to hide React Strict Mode warning\n */\nfunction findDOMNode(\n  instance: React.ReactInstance | null | undefined\n): Element | Text | null {\n  // Tree-shake for server bundle\n  if (typeof window === 'undefined') return null\n\n  // __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode is null during module init.\n  // We need to lazily reference it.\n  const internal_reactDOMfindDOMNode =\n    __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode\n  return internal_reactDOMfindDOMNode(instance)\n}\n\nconst rectProperties = [\n  'bottom',\n  'height',\n  'left',\n  'right',\n  'top',\n  'width',\n  'x',\n  'y',\n] as const\n/**\n * Check if a HTMLElement is hidden or fixed/sticky position\n */\nfunction shouldSkipElement(element: HTMLElement) {\n  // we ignore fixed or sticky positioned elements since they'll likely pass the \"in-viewport\" check\n  // and will result in a situation we bail on scroll because of something like a fixed nav,\n  // even though the actual page content is offscreen\n  if (['sticky', 'fixed'].includes(getComputedStyle(element).position)) {\n    if (process.env.NODE_ENV === 'development') {\n      console.warn(\n        'Skipping auto-scroll behavior due to `position: sticky` or `position: fixed` on element:',\n        element\n      )\n    }\n    return true\n  }\n\n  // Uses `getBoundingClientRect` to check if the element is hidden instead of `offsetParent`\n  // because `offsetParent` doesn't consider document/body\n  const rect = element.getBoundingClientRect()\n  return rectProperties.every((item) => rect[item] === 0)\n}\n\n/**\n * Check if the top corner of the HTMLElement is in the viewport.\n */\nfunction topOfElementInViewport(element: HTMLElement, viewportHeight: number) {\n  const rect = element.getBoundingClientRect()\n  return rect.top >= 0 && rect.top <= viewportHeight\n}\n\n/**\n * Find the DOM node for a hash fragment.\n * If `top` the page has to scroll to the top of the page. This mirrors the browser's behavior.\n * If the hash fragment is an id, the page has to scroll to the element with that id.\n * If the hash fragment is a name, the page has to scroll to the first element with that name.\n */\nfunction getHashFragmentDomNode(hashFragment: string) {\n  // If the hash fragment is `top` the page has to scroll to the top of the page.\n  if (hashFragment === 'top') {\n    return document.body\n  }\n\n  // If the hash fragment is an id, the page has to scroll to the element with that id.\n  return (\n    document.getElementById(hashFragment) ??\n    // If the hash fragment is a name, the page has to scroll to the first element with that name.\n    document.getElementsByName(hashFragment)[0]\n  )\n}\ninterface ScrollAndFocusHandlerProps {\n  focusAndScrollRef: FocusAndScrollRef\n  children: React.ReactNode\n  segmentPath: FlightSegmentPath\n}\nclass InnerScrollAndFocusHandler extends React.Component<ScrollAndFocusHandlerProps> {\n  handlePotentialScroll = () => {\n    // Handle scroll and focus, it's only applied once in the first useEffect that triggers that changed.\n    const { focusAndScrollRef, segmentPath } = this.props\n\n    if (focusAndScrollRef.apply) {\n      // segmentPaths is an array of segment paths that should be scrolled to\n      // if the current segment path is not in the array, the scroll is not applied\n      // unless the array is empty, in which case the scroll is always applied\n      if (\n        focusAndScrollRef.segmentPaths.length !== 0 &&\n        !focusAndScrollRef.segmentPaths.some((scrollRefSegmentPath) =>\n          segmentPath.every((segment, index) =>\n            matchSegment(segment, scrollRefSegmentPath[index])\n          )\n        )\n      ) {\n        return\n      }\n\n      let domNode:\n        | ReturnType<typeof getHashFragmentDomNode>\n        | ReturnType<typeof findDOMNode> = null\n      const hashFragment = focusAndScrollRef.hashFragment\n\n      if (hashFragment) {\n        domNode = getHashFragmentDomNode(hashFragment)\n      }\n\n      // `findDOMNode` is tricky because it returns just the first child if the component is a fragment.\n      // This already caused a bug where the first child was a <link/> in head.\n      if (!domNode) {\n        domNode = findDOMNode(this)\n      }\n\n      // If there is no DOM node this layout-router level is skipped. It'll be handled higher-up in the tree.\n      if (!(domNode instanceof Element)) {\n        return\n      }\n\n      // Verify if the element is a HTMLElement and if we want to consider it for scroll behavior.\n      // If the element is skipped, try to select the next sibling and try again.\n      while (!(domNode instanceof HTMLElement) || shouldSkipElement(domNode)) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (domNode.parentElement?.localName === 'head') {\n            // TODO: We enter this state when metadata was rendered as part of the page or via Next.js.\n            // This is always a bug in Next.js and caused by React hoisting metadata.\n            // We need to replace `findDOMNode` in favor of Fragment Refs (when available) so that we can skip over metadata.\n          }\n        }\n\n        // No siblings found that match the criteria are found, so handle scroll higher up in the tree instead.\n        if (domNode.nextElementSibling === null) {\n          return\n        }\n        domNode = domNode.nextElementSibling\n      }\n\n      // State is mutated to ensure that the focus and scroll is applied only once.\n      focusAndScrollRef.apply = false\n      focusAndScrollRef.hashFragment = null\n      focusAndScrollRef.segmentPaths = []\n\n      handleSmoothScroll(\n        () => {\n          // In case of hash scroll, we only need to scroll the element into view\n          if (hashFragment) {\n            ;(domNode as HTMLElement).scrollIntoView()\n\n            return\n          }\n          // Store the current viewport height because reading `clientHeight` causes a reflow,\n          // and it won't change during this function.\n          const htmlElement = document.documentElement\n          const viewportHeight = htmlElement.clientHeight\n\n          // If the element's top edge is already in the viewport, exit early.\n          if (topOfElementInViewport(domNode as HTMLElement, viewportHeight)) {\n            return\n          }\n\n          // Otherwise, try scrolling go the top of the document to be backward compatible with pages\n          // scrollIntoView() called on `<html/>` element scrolls horizontally on chrome and firefox (that shouldn't happen)\n          // We could use it to scroll horizontally following RTL but that also seems to be broken - it will always scroll left\n          // scrollLeft = 0 also seems to ignore RTL and manually checking for RTL is too much hassle so we will scroll just vertically\n          htmlElement.scrollTop = 0\n\n          // Scroll to domNode if domNode is not in viewport when scrolled to top of document\n          if (!topOfElementInViewport(domNode as HTMLElement, viewportHeight)) {\n            // Scroll into view doesn't scroll horizontally by default when not needed\n            ;(domNode as HTMLElement).scrollIntoView()\n          }\n        },\n        {\n          // We will force layout by querying domNode position\n          dontForceLayout: true,\n          onlyHashChange: focusAndScrollRef.onlyHashChange,\n        }\n      )\n\n      // Mutate after scrolling so that it can be read by `handleSmoothScroll`\n      focusAndScrollRef.onlyHashChange = false\n\n      // Set focus on the element\n      domNode.focus()\n    }\n  }\n\n  componentDidMount() {\n    this.handlePotentialScroll()\n  }\n\n  componentDidUpdate() {\n    // Because this property is overwritten in handlePotentialScroll it's fine to always run it when true as it'll be set to false for subsequent renders.\n    if (this.props.focusAndScrollRef.apply) {\n      this.handlePotentialScroll()\n    }\n  }\n\n  render() {\n    return this.props.children\n  }\n}\n\nfunction ScrollAndFocusHandler({\n  segmentPath,\n  children,\n}: {\n  segmentPath: FlightSegmentPath\n  children: React.ReactNode\n}) {\n  const context = useContext(GlobalLayoutRouterContext)\n  if (!context) {\n    throw new Error('invariant global layout router not mounted')\n  }\n\n  return (\n    <InnerScrollAndFocusHandler\n      segmentPath={segmentPath}\n      focusAndScrollRef={context.focusAndScrollRef}\n    >\n      {children}\n    </InnerScrollAndFocusHandler>\n  )\n}\n\n/**\n * InnerLayoutRouter handles rendering the provided segment based on the cache.\n */\nfunction InnerLayoutRouter({\n  tree,\n  segmentPath,\n  cacheNode,\n  url,\n}: {\n  tree: FlightRouterState\n  segmentPath: FlightSegmentPath\n  cacheNode: CacheNode\n  url: string\n}) {\n  const context = useContext(GlobalLayoutRouterContext)\n  if (!context) {\n    throw new Error('invariant global layout router not mounted')\n  }\n\n  const { tree: fullTree } = context\n\n  // `rsc` represents the renderable node for this segment.\n\n  // If this segment has a `prefetchRsc`, it's the statically prefetched data.\n  // We should use that on initial render instead of `rsc`. Then we'll switch\n  // to `rsc` when the dynamic response streams in.\n  //\n  // If no prefetch data is available, then we go straight to rendering `rsc`.\n  const resolvedPrefetchRsc =\n    cacheNode.prefetchRsc !== null ? cacheNode.prefetchRsc : cacheNode.rsc\n\n  // We use `useDeferredValue` to handle switching between the prefetched and\n  // final values. The second argument is returned on initial render, then it\n  // re-renders with the first argument.\n  const rsc: any = useDeferredValue(cacheNode.rsc, resolvedPrefetchRsc)\n\n  // `rsc` is either a React node or a promise for a React node, except we\n  // special case `null` to represent that this segment's data is missing. If\n  // it's a promise, we need to unwrap it so we can determine whether or not the\n  // data is missing.\n  const resolvedRsc: React.ReactNode =\n    typeof rsc === 'object' && rsc !== null && typeof rsc.then === 'function'\n      ? use(rsc)\n      : rsc\n\n  if (!resolvedRsc) {\n    // The data for this segment is not available, and there's no pending\n    // navigation that will be able to fulfill it. We need to fetch more from\n    // the server and patch the cache.\n\n    // Check if there's already a pending request.\n    let lazyData = cacheNode.lazyData\n    if (lazyData === null) {\n      /**\n       * Router state with refetch marker added\n       */\n      // TODO-APP: remove ''\n      const refetchTree = walkAddRefetch(['', ...segmentPath], fullTree)\n      const includeNextUrl = hasInterceptionRouteInCurrentTree(fullTree)\n      const navigatedAt = Date.now()\n      cacheNode.lazyData = lazyData = fetchServerResponse(\n        new URL(url, location.origin),\n        {\n          flightRouterState: refetchTree,\n          nextUrl: includeNextUrl ? context.nextUrl : null,\n        }\n      ).then((serverResponse) => {\n        startTransition(() => {\n          dispatchAppRouterAction({\n            type: ACTION_SERVER_PATCH,\n            previousTree: fullTree,\n            serverResponse,\n            navigatedAt,\n          })\n        })\n\n        return serverResponse\n      })\n\n      // Suspend while waiting for lazyData to resolve\n      use(lazyData)\n    }\n    // Suspend infinitely as `changeByServerResponse` will cause a different part of the tree to be rendered.\n    // A falsey `resolvedRsc` indicates missing data -- we should not commit that branch, and we need to wait for the data to arrive.\n    use(unresolvedThenable) as never\n  }\n\n  // If we get to this point, then we know we have something we can render.\n  const subtree = (\n    // The layout router context narrows down tree and childNodes at each level.\n    <LayoutRouterContext.Provider\n      value={{\n        parentTree: tree,\n        parentCacheNode: cacheNode,\n        parentSegmentPath: segmentPath,\n\n        // TODO-APP: overriding of url for parallel routes\n        url: url,\n      }}\n    >\n      {resolvedRsc}\n    </LayoutRouterContext.Provider>\n  )\n  // Ensure root layout is not wrapped in a div as the root layout renders `<html>`\n  return subtree\n}\n\n/**\n * Renders suspense boundary with the provided \"loading\" property as the fallback.\n * If no loading property is provided it renders the children without a suspense boundary.\n */\nfunction LoadingBoundary({\n  loading,\n  children,\n}: {\n  loading: LoadingModuleData | Promise<LoadingModuleData>\n  children: React.ReactNode\n}): JSX.Element {\n  // If loading is a promise, unwrap it. This happens in cases where we haven't\n  // yet received the loading data from the server — which includes whether or\n  // not this layout has a loading component at all.\n  //\n  // It's OK to suspend here instead of inside the fallback because this\n  // promise will resolve simultaneously with the data for the segment itself.\n  // So it will never suspend for longer than it would have if we didn't use\n  // a Suspense fallback at all.\n  let loadingModuleData\n  if (\n    typeof loading === 'object' &&\n    loading !== null &&\n    typeof (loading as any).then === 'function'\n  ) {\n    const promiseForLoading = loading as Promise<LoadingModuleData>\n    loadingModuleData = use(promiseForLoading)\n  } else {\n    loadingModuleData = loading as LoadingModuleData\n  }\n\n  if (loadingModuleData) {\n    const loadingRsc = loadingModuleData[0]\n    const loadingStyles = loadingModuleData[1]\n    const loadingScripts = loadingModuleData[2]\n    return (\n      <Suspense\n        fallback={\n          <>\n            {loadingStyles}\n            {loadingScripts}\n            {loadingRsc}\n          </>\n        }\n      >\n        {children}\n      </Suspense>\n    )\n  }\n\n  return <>{children}</>\n}\n\n/**\n * OuterLayoutRouter handles the current segment as well as <Offscreen> rendering of other segments.\n * It can be rendered next to each other with a different `parallelRouterKey`, allowing for Parallel routes.\n */\nexport default function OuterLayoutRouter({\n  parallelRouterKey,\n  error,\n  errorStyles,\n  errorScripts,\n  templateStyles,\n  templateScripts,\n  template,\n  notFound,\n  forbidden,\n  unauthorized,\n}: {\n  parallelRouterKey: string\n  error: ErrorComponent | undefined\n  errorStyles: React.ReactNode | undefined\n  errorScripts: React.ReactNode | undefined\n  templateStyles: React.ReactNode | undefined\n  templateScripts: React.ReactNode | undefined\n  template: React.ReactNode\n  notFound: React.ReactNode | undefined\n  forbidden: React.ReactNode | undefined\n  unauthorized: React.ReactNode | undefined\n}) {\n  const context = useContext(LayoutRouterContext)\n  if (!context) {\n    throw new Error('invariant expected layout router to be mounted')\n  }\n\n  const { parentTree, parentCacheNode, parentSegmentPath, url } = context\n\n  // Get the CacheNode for this segment by reading it from the parent segment's\n  // child map.\n  const parentParallelRoutes = parentCacheNode.parallelRoutes\n  let segmentMap = parentParallelRoutes.get(parallelRouterKey)\n  // If the parallel router cache node does not exist yet, create it.\n  // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.\n  if (!segmentMap) {\n    segmentMap = new Map()\n    parentParallelRoutes.set(parallelRouterKey, segmentMap)\n  }\n\n  // Get the active segment in the tree\n  // The reason arrays are used in the data format is that these are transferred from the server to the browser so it's optimized to save bytes.\n  const parentTreeSegment = parentTree[0]\n  const tree = parentTree[1][parallelRouterKey]\n  const treeSegment = tree[0]\n\n  const segmentPath =\n    parentSegmentPath === null\n      ? // TODO: The root segment value is currently omitted from the segment\n        // path. This has led to a bunch of special cases scattered throughout\n        // the code. We should clean this up.\n        [parallelRouterKey]\n      : parentSegmentPath.concat([parentTreeSegment, parallelRouterKey])\n\n  // The \"state\" key of a segment is the one passed to React — it represents the\n  // identity of the UI tree. Whenever the state key changes, the tree is\n  // recreated and the state is reset. In the App Router model, search params do\n  // not cause state to be lost, so two segments with the same segment path but\n  // different search params should have the same state key.\n  //\n  // The \"cache\" key of a segment, however, *does* include the search params, if\n  // it's possible that the segment accessed the search params on the server.\n  // (This only applies to page segments; layout segments cannot access search\n  // params on the server.)\n  const cacheKey = createRouterCacheKey(treeSegment)\n  const stateKey = createRouterCacheKey(treeSegment, true) // no search params\n\n  // Read segment path from the parallel router cache node.\n  let cacheNode = segmentMap.get(cacheKey)\n  if (cacheNode === undefined) {\n    // When data is not available during rendering client-side we need to fetch\n    // it from the server.\n    const newLazyCacheNode: LazyCacheNode = {\n      lazyData: null,\n      rsc: null,\n      prefetchRsc: null,\n      head: null,\n      prefetchHead: null,\n      parallelRoutes: new Map(),\n      loading: null,\n      navigatedAt: -1,\n    }\n\n    // Flight data fetch kicked off during render and put into the cache.\n    cacheNode = newLazyCacheNode\n    segmentMap.set(cacheKey, newLazyCacheNode)\n  }\n\n  /*\n    - Error boundary\n      - Only renders error boundary if error component is provided.\n      - Rendered for each segment to ensure they have their own error state.\n    - Loading boundary\n      - Only renders suspense boundary if loading components is provided.\n      - Rendered for each segment to ensure they have their own loading state.\n      - Passed to the router during rendering to ensure it can be immediately rendered when suspending on a Flight fetch.\n  */\n\n  // TODO: The loading module data for a segment is stored on the parent, then\n  // applied to each of that parent segment's parallel route slots. In the\n  // simple case where there's only one parallel route (the `children` slot),\n  // this is no different from if the loading module data where stored on the\n  // child directly. But I'm not sure this actually makes sense when there are\n  // multiple parallel routes. It's not a huge issue because you always have\n  // the option to define a narrower loading boundary for a particular slot. But\n  // this sort of smells like an implementation accident to me.\n  const loadingModuleData = parentCacheNode.loading\n\n  return (\n    <TemplateContext.Provider\n      key={stateKey}\n      value={\n        <ScrollAndFocusHandler segmentPath={segmentPath}>\n          <ErrorBoundary\n            errorComponent={error}\n            errorStyles={errorStyles}\n            errorScripts={errorScripts}\n          >\n            <LoadingBoundary loading={loadingModuleData}>\n              <HTTPAccessFallbackBoundary\n                notFound={notFound}\n                forbidden={forbidden}\n                unauthorized={unauthorized}\n              >\n                <RedirectBoundary>\n                  <InnerLayoutRouter\n                    url={url}\n                    tree={tree}\n                    cacheNode={cacheNode}\n                    segmentPath={segmentPath}\n                  />\n                </RedirectBoundary>\n              </HTTPAccessFallbackBoundary>\n            </LoadingBoundary>\n          </ErrorBoundary>\n        </ScrollAndFocusHandler>\n      }\n    >\n      {templateStyles}\n      {templateScripts}\n      {template}\n    </TemplateContext.Provider>\n  )\n}\n"],"names":["OuterLayoutRouter","walkAddRefetch","segmentPathToWalk","treeToRecreate","segment","parallelRouteKey","isLast","length","matchSegment","hasOwnProperty","subTree","undefined","slice","__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE","ReactDOM","findDOMNode","instance","window","internal_reactDOMfindDOMNode","rectProperties","shouldSkipElement","element","includes","getComputedStyle","position","process","env","NODE_ENV","console","warn","rect","getBoundingClientRect","every","item","topOfElementInViewport","viewportHeight","top","getHashFragmentDomNode","hashFragment","document","body","getElementById","getElementsByName","InnerScrollAndFocusHandler","React","Component","componentDidMount","handlePotentialScroll","componentDidUpdate","props","focusAndScrollRef","apply","render","children","segmentPath","segmentPaths","some","scrollRefSegmentPath","index","domNode","Element","HTMLElement","parentElement","localName","nextElementSibling","handleSmoothScroll","scrollIntoView","htmlElement","documentElement","clientHeight","scrollTop","dontForceLayout","onlyHashChange","focus","ScrollAndFocusHandler","context","useContext","GlobalLayoutRouterContext","Error","InnerLayoutRouter","tree","cacheNode","url","fullTree","resolvedPrefetchRsc","prefetchRsc","rsc","useDeferredValue","resolvedRsc","then","use","lazyData","refetchTree","includeNextUrl","hasInterceptionRouteInCurrentTree","navigatedAt","Date","now","fetchServerResponse","URL","location","origin","flightRouterState","nextUrl","serverResponse","startTransition","dispatchAppRouterAction","type","ACTION_SERVER_PATCH","previousTree","unresolvedThenable","subtree","LayoutRouterContext","Provider","value","parentTree","parentCacheNode","parentSegmentPath","LoadingBoundary","loading","loadingModuleData","promiseForLoading","loadingRsc","loadingStyles","loadingScripts","Suspense","fallback","parallelRouterKey","error","errorStyles","errorScripts","templateStyles","templateScripts","template","notFound","forbidden","unauthorized","parentParallelRoutes","parallelRoutes","segmentMap","get","Map","set","parentTreeSegment","treeSegment","concat","cacheKey","createRouterCacheKey","stateKey","newLazyCacheNode","head","prefetchHead","TemplateContext","ErrorBoundary","errorComponent","HTTPAccessFallbackBoundary","RedirectBoundary"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 13179, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/next/src/client/components/render-from-template-context.tsx"],"sourcesContent":["'use client'\n\nimport React, { useContext, type JSX } from 'react'\nimport { TemplateContext } from '../../shared/lib/app-router-context.shared-runtime'\n\nexport default function RenderFromTemplateContext(): JSX.Element {\n  const children = useContext(TemplateContext)\n  return <>{children}</>\n}\n"],"names":["RenderFromTemplateContext","children","useContext","TemplateContext"],"mappings":"AAAA;;;;;+BAKA,WAAA;;;eAAwBA;;;;;iEAHoB;+CACZ;AAEjB,SAASA;IACtB,MAAMC,WAAWC,CAAAA,GAAAA,OAAAA,UAAU,EAACC,+BAAAA,eAAe;IAC3C,OAAA,WAAA,GAAO,CAAA,GAAA,YAAA,GAAA,EAAA,YAAA,QAAA,EAAA;kBAAGF;;AACZ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 13212, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/next/src/shared/lib/invariant-error.ts"],"sourcesContent":["export class InvariantError extends Error {\n  constructor(message: string, options?: ErrorOptions) {\n    super(\n      `Invariant: ${message.endsWith('.') ? message : message + '.'} This is a bug in Next.js.`,\n      options\n    )\n    this.name = 'InvariantError'\n  }\n}\n"],"names":["InvariantError","Error","constructor","message","options","endsWith","name"],"mappings":";;;;+BAAaA,kBAAAA;;;eAAAA;;;AAAN,MAAMA,uBAAuBC;IAClCC,YAAYC,OAAe,EAAEC,OAAsB,CAAE;QACnD,KAAK,CACF,gBAAaD,CAAAA,QAAQE,QAAQ,CAAC,OAAOF,UAAUA,UAAU,GAAE,IAAE,8BAC9DC;QAEF,IAAI,CAACE,IAAI,GAAG;IACd;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 13233, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/next/src/server/web/spec-extension/adapters/reflect.ts"],"sourcesContent":["export class ReflectAdapter {\n  static get<T extends object>(\n    target: T,\n    prop: string | symbol,\n    receiver: unknown\n  ): any {\n    const value = Reflect.get(target, prop, receiver)\n    if (typeof value === 'function') {\n      return value.bind(target)\n    }\n\n    return value\n  }\n\n  static set<T extends object>(\n    target: T,\n    prop: string | symbol,\n    value: any,\n    receiver: any\n  ): boolean {\n    return Reflect.set(target, prop, value, receiver)\n  }\n\n  static has<T extends object>(target: T, prop: string | symbol): boolean {\n    return Reflect.has(target, prop)\n  }\n\n  static deleteProperty<T extends object>(\n    target: T,\n    prop: string | symbol\n  ): boolean {\n    return Reflect.deleteProperty(target, prop)\n  }\n}\n"],"names":["ReflectAdapter","get","target","prop","receiver","value","Reflect","bind","set","has","deleteProperty"],"mappings":";;;;+BAAaA,kBAAAA;;;eAAAA;;;AAAN,MAAMA;IACX,OAAOC,IACLC,MAAS,EACTC,IAAqB,EACrBC,QAAiB,EACZ;QACL,MAAMC,QAAQC,QAAQL,GAAG,CAACC,QAAQC,MAAMC;QACxC,IAAI,OAAOC,UAAU,YAAY;YAC/B,OAAOA,MAAME,IAAI,CAACL;QACpB;QAEA,OAAOG;IACT;IAEA,OAAOG,IACLN,MAAS,EACTC,IAAqB,EACrBE,KAAU,EACVD,QAAa,EACJ;QACT,OAAOE,QAAQE,GAAG,CAACN,QAAQC,MAAME,OAAOD;IAC1C;IAEA,OAAOK,IAAsBP,MAAS,EAAEC,IAAqB,EAAW;QACtE,OAAOG,QAAQG,GAAG,CAACP,QAAQC;IAC7B;IAEA,OAAOO,eACLR,MAAS,EACTC,IAAqB,EACZ;QACT,OAAOG,QAAQI,cAAc,CAACR,QAAQC;IACxC;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 13266, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/next/src/shared/lib/utils/reflect-utils.ts"],"sourcesContent":["// This regex will have fast negatives meaning valid identifiers may not pass\n// this test. However this is only used during static generation to provide hints\n// about why a page bailed out of some or all prerendering and we can use bracket notation\n// for example while `ಠ_ಠ` is a valid identifier it's ok to print `searchParams['ಠ_ಠ']`\n// even if this would have been fine too `searchParams.ಠ_ಠ`\nconst isDefinitelyAValidIdentifier = /^[A-Za-z_$][A-Za-z0-9_$]*$/\n\nexport function describeStringPropertyAccess(target: string, prop: string) {\n  if (isDefinitelyAValidIdentifier.test(prop)) {\n    return `\\`${target}.${prop}\\``\n  }\n  return `\\`${target}[${JSON.stringify(prop)}]\\``\n}\n\nexport function describeHasCheckingStringProperty(\n  target: string,\n  prop: string\n) {\n  const stringifiedProp = JSON.stringify(prop)\n  return `\\`Reflect.has(${target}, ${stringifiedProp})\\`, \\`${stringifiedProp} in ${target}\\`, or similar`\n}\n\nexport const wellKnownProperties = new Set([\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toString',\n  'valueOf',\n  'toLocaleString',\n\n  // Promise prototype\n  // fallthrough\n  'then',\n  'catch',\n  'finally',\n\n  // React Promise extension\n  // fallthrough\n  'status',\n\n  // React introspection\n  'displayName',\n\n  // Common tested properties\n  // fallthrough\n  'toJSON',\n  '$$typeof',\n  '__esModule',\n])\n"],"names":["describeHasCheckingStringProperty","describeStringPropertyAccess","wellKnownProperties","isDefinitelyAValidIdentifier","target","prop","test","JSON","stringify","stringifiedProp","Set"],"mappings":"AAAA,6EAA6E;AAC7E,iFAAiF;AACjF,0FAA0F;AAC1F,uFAAuF;AACvF,2DAA2D;;;;;;;;;;;;;;;;;IAU3CA,iCAAiC,EAAA;eAAjCA;;IAPAC,4BAA4B,EAAA;eAA5BA;;IAeHC,mBAAmB,EAAA;eAAnBA;;;AAjBb,MAAMC,+BAA+B;AAE9B,SAASF,6BAA6BG,MAAc,EAAEC,IAAY;IACvE,IAAIF,6BAA6BG,IAAI,CAACD,OAAO;QAC3C,OAAQ,MAAID,SAAO,MAAGC,OAAK;IAC7B;IACA,OAAQ,MAAID,SAAO,MAAGG,KAAKC,SAAS,CAACH,QAAM;AAC7C;AAEO,SAASL,kCACdI,MAAc,EACdC,IAAY;IAEZ,MAAMI,kBAAkBF,KAAKC,SAAS,CAACH;IACvC,OAAQ,kBAAgBD,SAAO,OAAIK,kBAAgB,UAASA,kBAAgB,SAAML,SAAO;AAC3F;AAEO,MAAMF,sBAAsB,IAAIQ,IAAI;IACzC;IACA;IACA;IACA;IACA;IACA;IAEA,oBAAoB;IACpB,cAAc;IACd;IACA;IACA;IAEA,0BAA0B;IAC1B,cAAc;IACd;IAEA,sBAAsB;IACtB;IAEA,2BAA2B;IAC3B,cAAc;IACd;IACA;IACA;CACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 13336, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/next/src/client/request/search-params.browser.dev.ts"],"sourcesContent":["import type { SearchParams } from '../../server/request/search-params'\n\nimport { ReflectAdapter } from '../../server/web/spec-extension/adapters/reflect'\nimport {\n  describeStringPropertyAccess,\n  describeHasCheckingStringProperty,\n  wellKnownProperties,\n} from '../../shared/lib/utils/reflect-utils'\n\ninterface CacheLifetime {}\nconst CachedSearchParams = new WeakMap<CacheLifetime, Promise<SearchParams>>()\n\nexport function makeUntrackedExoticSearchParamsWithDevWarnings(\n  underlyingSearchParams: SearchParams\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const proxiedProperties = new Set<string>()\n  const unproxiedProperties: Array<string> = []\n\n  const promise = Promise.resolve(underlyingSearchParams)\n\n  Object.keys(underlyingSearchParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n      unproxiedProperties.push(prop)\n    } else {\n      proxiedProperties.add(prop)\n      ;(promise as any)[prop] = underlyingSearchParams[prop]\n    }\n  })\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string') {\n        if (\n          !wellKnownProperties.has(prop) &&\n          (proxiedProperties.has(prop) ||\n            // We are accessing a property that doesn't exist on the promise nor\n            // the underlying searchParams.\n            Reflect.has(target, prop) === false)\n        ) {\n          const expression = describeStringPropertyAccess('searchParams', prop)\n          warnForSyncAccess(expression)\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop)\n      }\n      return Reflect.set(target, prop, value, receiver)\n    },\n    has(target, prop) {\n      if (typeof prop === 'string') {\n        if (\n          !wellKnownProperties.has(prop) &&\n          (proxiedProperties.has(prop) ||\n            // We are accessing a property that doesn't exist on the promise nor\n            // the underlying searchParams.\n            Reflect.has(target, prop) === false)\n        ) {\n          const expression = describeHasCheckingStringProperty(\n            'searchParams',\n            prop\n          )\n          warnForSyncAccess(expression)\n        }\n      }\n      return Reflect.has(target, prop)\n    },\n    ownKeys(target) {\n      warnForSyncSpread()\n      return Reflect.ownKeys(target)\n    },\n  })\n\n  CachedSearchParams.set(underlyingSearchParams, proxiedPromise)\n  return proxiedPromise\n}\n\nfunction warnForSyncAccess(expression: string) {\n  console.error(\n    `A searchParam property was accessed directly with ${expression}. ` +\n      `\\`searchParams\\` should be unwrapped with \\`React.use()\\` before accessing its properties. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\nfunction warnForSyncSpread() {\n  console.error(\n    `The keys of \\`searchParams\\` were accessed directly. ` +\n      `\\`searchParams\\` should be unwrapped with \\`React.use()\\` before accessing its properties. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n"],"names":["makeUntrackedExoticSearchParamsWithDevWarnings","CachedSearchParams","WeakMap","underlyingSearchParams","cachedSearchParams","get","proxiedProperties","Set","unproxiedProperties","promise","Promise","resolve","Object","keys","forEach","prop","wellKnownProperties","has","push","add","proxiedPromise","Proxy","target","receiver","Reflect","expression","describeStringPropertyAccess","warnForSyncAccess","ReflectAdapter","set","value","delete","describeHasCheckingStringProperty","ownKeys","warnForSyncSpread","console","error"],"mappings":";;;;+BAYgBA,kDAAAA;;;eAAAA;;;yBAVe;8BAKxB;AAGP,MAAMC,qBAAqB,IAAIC;AAExB,SAASF,+CACdG,sBAAoC;IAEpC,MAAMC,qBAAqBH,mBAAmBI,GAAG,CAACF;IAClD,IAAIC,oBAAoB;QACtB,OAAOA;IACT;IAEA,MAAME,oBAAoB,IAAIC;IAC9B,MAAMC,sBAAqC,EAAE;IAE7C,MAAMC,UAAUC,QAAQC,OAAO,CAACR;IAEhCS,OAAOC,IAAI,CAACV,wBAAwBW,OAAO,CAAC,CAACC;QAC3C,IAAIC,cAAAA,mBAAmB,CAACC,GAAG,CAACF,OAAO;YACjC,kEAAkE;YAClE,kEAAkE;YAClEP,oBAAoBU,IAAI,CAACH;QAC3B,OAAO;YACLT,kBAAkBa,GAAG,CAACJ;YACpBN,OAAe,CAACM,KAAK,GAAGZ,sBAAsB,CAACY,KAAK;QACxD;IACF;IAEA,MAAMK,iBAAiB,IAAIC,MAAMZ,SAAS;QACxCJ,KAAIiB,MAAM,EAAEP,IAAI,EAAEQ,QAAQ;YACxB,IAAI,OAAOR,SAAS,UAAU;gBAC5B,IACE,CAACC,cAAAA,mBAAmB,CAACC,GAAG,CAACF,SACxBT,CAAAA,kBAAkBW,GAAG,CAACF,SACrB,oEAAoE;gBACpE,+BAA+B;gBAC/BS,QAAQP,GAAG,CAACK,QAAQP,UAAU,KAAI,GACpC;oBACA,MAAMU,aAAaC,CAAAA,GAAAA,cAAAA,4BAA4B,EAAC,gBAAgBX;oBAChEY,kBAAkBF;gBACpB;YACF;YACA,OAAOG,SAAAA,cAAc,CAACvB,GAAG,CAACiB,QAAQP,MAAMQ;QAC1C;QACAM,KAAIP,MAAM,EAAEP,IAAI,EAAEe,KAAK,EAAEP,QAAQ;YAC/B,IAAI,OAAOR,SAAS,UAAU;gBAC5BT,kBAAkByB,MAAM,CAAChB;YAC3B;YACA,OAAOS,QAAQK,GAAG,CAACP,QAAQP,MAAMe,OAAOP;QAC1C;QACAN,KAAIK,MAAM,EAAEP,IAAI;YACd,IAAI,OAAOA,SAAS,UAAU;gBAC5B,IACE,CAACC,cAAAA,mBAAmB,CAACC,GAAG,CAACF,SACxBT,CAAAA,kBAAkBW,GAAG,CAACF,SACrB,oEAAoE;gBACpE,+BAA+B;gBAC/BS,QAAQP,GAAG,CAACK,QAAQP,UAAU,KAAI,GACpC;oBACA,MAAMU,aAAaO,CAAAA,GAAAA,cAAAA,iCAAiC,EAClD,gBACAjB;oBAEFY,kBAAkBF;gBACpB;YACF;YACA,OAAOD,QAAQP,GAAG,CAACK,QAAQP;QAC7B;QACAkB,SAAQX,MAAM;YACZY;YACA,OAAOV,QAAQS,OAAO,CAACX;QACzB;IACF;IAEArB,mBAAmB4B,GAAG,CAAC1B,wBAAwBiB;IAC/C,OAAOA;AACT;AAEA,SAASO,kBAAkBF,UAAkB;IAC3CU,QAAQC,KAAK,CACV,uDAAoDX,aAAW,OAC7D,4FACA;AAEP;AAEA,SAASS;IACPC,QAAQC,KAAK,CACV,wDACE,4FACA;AAEP","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 13422, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/next/src/client/request/search-params.browser.ts"],"sourcesContent":["export const createRenderSearchParamsFromClient =\n  process.env.NODE_ENV === 'development'\n    ? (\n        require('./search-params.browser.dev') as typeof import('./search-params.browser.dev')\n      ).makeUntrackedExoticSearchParamsWithDevWarnings\n    : (\n        require('./search-params.browser.prod') as typeof import('./search-params.browser.prod')\n      ).makeUntrackedExoticSearchParams\n"],"names":["createRenderSearchParamsFromClient","process","env","NODE_ENV","require","makeUntrackedExoticSearchParamsWithDevWarnings","makeUntrackedExoticSearchParams"],"mappings":"AACEC,QAAQC,GAAG,CAACC,QAAQ,KAAK;;;;;+BADdH,sCAAAA;;;eAAAA;;;AAAN,MAAMA,4EAGLI,QAAQ,0HACRC,8CAA8C,GAChD,AACED,QAAQ,gCACRE,+BAA+B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 13446, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/next/src/client/request/params.browser.dev.ts"],"sourcesContent":["import type { Params } from '../../server/request/params'\n\nimport { ReflectAdapter } from '../../server/web/spec-extension/adapters/reflect'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport {\n  describeStringPropertyAccess,\n  wellKnownProperties,\n} from '../../shared/lib/utils/reflect-utils'\n\ninterface CacheLifetime {}\nconst CachedParams = new WeakMap<CacheLifetime, Promise<Params>>()\n\nexport function makeDynamicallyTrackedExoticParamsWithDevWarnings(\n  underlyingParams: Params\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(underlyingParams)\n\n  const proxiedProperties = new Set<string>()\n  const unproxiedProperties: Array<string> = []\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      proxiedProperties.add(prop)\n      ;(promise as any)[prop] = underlyingParams[prop]\n    }\n  })\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string') {\n        if (\n          // We are accessing a property that was proxied to the promise instance\n          proxiedProperties.has(prop)\n        ) {\n          const expression = describeStringPropertyAccess('params', prop)\n          warnForSyncAccess(expression)\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop)\n      }\n      return ReflectAdapter.set(target, prop, value, receiver)\n    },\n    ownKeys(target) {\n      warnForEnumeration(unproxiedProperties)\n      return Reflect.ownKeys(target)\n    },\n  })\n\n  CachedParams.set(underlyingParams, proxiedPromise)\n  return proxiedPromise\n}\n\nfunction warnForSyncAccess(expression: string) {\n  console.error(\n    `A param property was accessed directly with ${expression}. \\`params\\` is now a Promise and should be unwrapped with \\`React.use()\\` before accessing properties of the underlying params object. In this version of Next.js direct access to param properties is still supported to facilitate migration but in a future version you will be required to unwrap \\`params\\` with \\`React.use()\\`.`\n  )\n}\n\nfunction warnForEnumeration(missingProperties: Array<string>) {\n  if (missingProperties.length) {\n    const describedMissingProperties =\n      describeListOfPropertyNames(missingProperties)\n    console.error(\n      `params are being enumerated incompletely missing these properties: ${describedMissingProperties}. ` +\n        `\\`params\\` should be unwrapped with \\`React.use()\\` before using its value. ` +\n        `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n    )\n  } else {\n    console.error(\n      `params are being enumerated. ` +\n        `\\`params\\` should be unwrapped with \\`React.use()\\` before using its value. ` +\n        `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n    )\n  }\n}\n\nfunction describeListOfPropertyNames(properties: Array<string>) {\n  switch (properties.length) {\n    case 0:\n      throw new InvariantError(\n        'Expected describeListOfPropertyNames to be called with a non-empty list of strings.'\n      )\n    case 1:\n      return `\\`${properties[0]}\\``\n    case 2:\n      return `\\`${properties[0]}\\` and \\`${properties[1]}\\``\n    default: {\n      let description = ''\n      for (let i = 0; i < properties.length - 1; i++) {\n        description += `\\`${properties[i]}\\`, `\n      }\n      description += `, and \\`${properties[properties.length - 1]}\\``\n      return description\n    }\n  }\n}\n"],"names":["makeDynamicallyTrackedExoticParamsWithDevWarnings","CachedParams","WeakMap","underlyingParams","cachedParams","get","promise","Promise","resolve","proxiedProperties","Set","unproxiedProperties","Object","keys","forEach","prop","wellKnownProperties","has","add","proxiedPromise","Proxy","target","receiver","expression","describeStringPropertyAccess","warnForSyncAccess","ReflectAdapter","set","value","delete","ownKeys","warnForEnumeration","Reflect","console","error","missingProperties","length","describedMissingProperties","describeListOfPropertyNames","properties","InvariantError","description","i"],"mappings":";;;;+BAYgBA,qDAAAA;;;eAAAA;;;yBAVe;gCACA;8BAIxB;AAGP,MAAMC,eAAe,IAAIC;AAElB,SAASF,kDACdG,gBAAwB;IAExB,MAAMC,eAAeH,aAAaI,GAAG,CAACF;IACtC,IAAIC,cAAc;QAChB,OAAOA;IACT;IAEA,4DAA4D;IAC5D,kEAAkE;IAClE,qEAAqE;IACrE,MAAME,UAAUC,QAAQC,OAAO,CAACL;IAEhC,MAAMM,oBAAoB,IAAIC;IAC9B,MAAMC,sBAAqC,EAAE;IAE7CC,OAAOC,IAAI,CAACV,kBAAkBW,OAAO,CAAC,CAACC;QACrC,IAAIC,cAAAA,mBAAmB,CAACC,GAAG,CAACF,OAAO;QACjC,kEAAkE;QAClE,kEAAkE;QACpE,OAAO;YACLN,kBAAkBS,GAAG,CAACH;YACpBT,OAAe,CAACS,KAAK,GAAGZ,gBAAgB,CAACY,KAAK;QAClD;IACF;IAEA,MAAMI,iBAAiB,IAAIC,MAAMd,SAAS;QACxCD,KAAIgB,MAAM,EAAEN,IAAI,EAAEO,QAAQ;YACxB,IAAI,OAAOP,SAAS,UAAU;gBAC5B,IACE,AACAN,kBAAkBQ,GAAG,CAACF,OACtB,0CAFuE;oBAGvE,MAAMQ,aAAaC,CAAAA,GAAAA,cAAAA,4BAA4B,EAAC,UAAUT;oBAC1DU,kBAAkBF;gBACpB;YACF;YACA,OAAOG,SAAAA,cAAc,CAACrB,GAAG,CAACgB,QAAQN,MAAMO;QAC1C;QACAK,KAAIN,MAAM,EAAEN,IAAI,EAAEa,KAAK,EAAEN,QAAQ;YAC/B,IAAI,OAAOP,SAAS,UAAU;gBAC5BN,kBAAkBoB,MAAM,CAACd;YAC3B;YACA,OAAOW,SAAAA,cAAc,CAACC,GAAG,CAACN,QAAQN,MAAMa,OAAON;QACjD;QACAQ,SAAQT,MAAM;YACZU,mBAAmBpB;YACnB,OAAOqB,QAAQF,OAAO,CAACT;QACzB;IACF;IAEApB,aAAa0B,GAAG,CAACxB,kBAAkBgB;IACnC,OAAOA;AACT;AAEA,SAASM,kBAAkBF,UAAkB;IAC3CU,QAAQC,KAAK,CACV,iDAA8CX,aAAW;AAE9D;AAEA,SAASQ,mBAAmBI,iBAAgC;IAC1D,IAAIA,kBAAkBC,MAAM,EAAE;QAC5B,MAAMC,6BACJC,4BAA4BH;QAC9BF,QAAQC,KAAK,CACV,wEAAqEG,6BAA2B,OAC9F,6EACA;IAEP,OAAO;QACLJ,QAAQC,KAAK,CACV,kCACE,6EACA;IAEP;AACF;AAEA,SAASI,4BAA4BC,UAAyB;IAC5D,OAAQA,WAAWH,MAAM;QACvB,KAAK;YACH,MAAM,OAAA,cAEL,CAFK,IAAII,gBAAAA,cAAc,CACtB,wFADI,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QACF,KAAK;YACH,OAAQ,MAAID,UAAU,CAAC,EAAE,GAAC;QAC5B,KAAK;YACH,OAAQ,MAAIA,UAAU,CAAC,EAAE,GAAC,YAAWA,UAAU,CAAC,EAAE,GAAC;QACrD;YAAS;gBACP,IAAIE,cAAc;gBAClB,IAAK,IAAIC,IAAI,GAAGA,IAAIH,WAAWH,MAAM,GAAG,GAAGM,IAAK;oBAC9CD,eAAgB,MAAIF,UAAU,CAACG,EAAE,GAAC;gBACpC;gBACAD,eAAgB,YAAUF,UAAU,CAACA,WAAWH,MAAM,GAAG,EAAE,GAAC;gBAC5D,OAAOK;YACT;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 13550, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/next/src/client/request/params.browser.ts"],"sourcesContent":["export const createRenderParamsFromClient =\n  process.env.NODE_ENV === 'development'\n    ? (require('./params.browser.dev') as typeof import('./params.browser.dev'))\n        .makeDynamicallyTrackedExoticParamsWithDevWarnings\n    : (\n        require('./params.browser.prod') as typeof import('./params.browser.prod')\n      ).makeUntrackedExoticParams\n"],"names":["createRenderParamsFromClient","process","env","NODE_ENV","require","makeDynamicallyTrackedExoticParamsWithDevWarnings","makeUntrackedExoticParams"],"mappings":"AACEC,QAAQC,GAAG,CAACC,QAAQ,KAAK;;;;;+BADdH,gCAAAA;;;eAAAA;;;AAAN,MAAMA,sEAENI,QAAQ,mHACNC,iDAAiD,GACpD,AACED,QAAQ,yBACRE,yBAAyB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 13574, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/next/src/server/create-deduped-by-callsite-server-error-logger.ts"],"sourcesContent":["import * as React from 'react'\n\nconst errorRef: { current: null | Error } = { current: null }\n\n// React.cache is currently only available in canary/experimental React channels.\nconst cache =\n  typeof React.cache === 'function'\n    ? React.cache\n    : (fn: (key: unknown) => void) => fn\n\n// When Dynamic IO is enabled, we record these as errors so that they\n// are captured by the dev overlay as it's more critical to fix these\n// when enabled.\nconst logErrorOrWarn = process.env.__NEXT_DYNAMIC_IO\n  ? console.error\n  : console.warn\n\n// We don't want to dedupe across requests.\n// The developer might've just attempted to fix the warning so we should warn again if it still happens.\nconst flushCurrentErrorIfNew = cache(\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars -- cache key\n  (key: unknown) => {\n    try {\n      logErrorOrWarn(errorRef.current)\n    } finally {\n      errorRef.current = null\n    }\n  }\n)\n\n/**\n * Creates a function that logs an error message that is deduped by the userland\n * callsite.\n * This requires no indirection between the call of this function and the userland\n * callsite i.e. there's only a single library frame above this.\n * Do not use on the Client where sourcemaps and ignore listing might be enabled.\n * Only use that for warnings need a fix independent of the callstack.\n *\n * @param getMessage\n * @returns\n */\nexport function createDedupedByCallsiteServerErrorLoggerDev<Args extends any[]>(\n  getMessage: (...args: Args) => Error\n) {\n  return function logDedupedError(...args: Args) {\n    const message = getMessage(...args)\n\n    if (process.env.NODE_ENV !== 'production') {\n      const callStackFrames = new Error().stack?.split('\\n')\n      if (callStackFrames === undefined || callStackFrames.length < 4) {\n        logErrorOrWarn(message)\n      } else {\n        // Error:\n        //   logDedupedError\n        //   asyncApiBeingAccessedSynchronously\n        //   <userland callsite>\n        // TODO: This breaks if sourcemaps with ignore lists are enabled.\n        const key = callStackFrames[4]\n        errorRef.current = message\n        flushCurrentErrorIfNew(key)\n      }\n    } else {\n      logErrorOrWarn(message)\n    }\n  }\n}\n"],"names":["createDedupedByCallsiteServerErrorLoggerDev","errorRef","current","cache","React","fn","logErrorOrWarn","process","env","__NEXT_DYNAMIC_IO","console","error","warn","flushCurrentErrorIfNew","key","getMessage","logDedupedError","args","message","NODE_ENV","callStackFrames","Error","stack","split","undefined","length"],"mappings":"AAauBO,QAAQC,GAAG,CAACC,iBAAiB,GAChDC,QAAQC,KAAK;;;;;+BA2BDX,+CAAAA;;;eAAAA;;;+DAzCO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEvB,MAAMC,WAAsC;IAAEC,SAAS;AAAK;AAE5D,iFAAiF;AACjF,MAAMC,QACJ,OAAOC,OAAMD,KAAK,KAAK,aACnBC,OAAMD,KAAK,GACX,CAACE,KAA+BA;AAEtC,qEAAqE;AACrE,qEAAqE;AACrE,gBAAgB;AAChB,MAAMC,8FAEFI,QAAQE,IAAI;AAEhB,2CAA2C;AAC3C,wGAAwG;AACxG,MAAMC,yBAAyBV,MAC7B,AACA,CAACW,yEADyE;IAExE,IAAI;QACFR,eAAeL,SAASC,OAAO;IACjC,SAAU;QACRD,SAASC,OAAO,GAAG;IACrB;AACF;AAcK,SAASF,4CACde,UAAoC;IAEpC,OAAO,SAASC,gBAAgB,GAAGC,IAAU;QAC3C,MAAMC,UAAUH,cAAcE;QAE9B,IAAIV,QAAQC,GAAG,CAACW,QAAQ,KAAK,WAAc;gBACjB;YAAxB,MAAMC,kBAAAA,CAAkB,SAAA,IAAIC,QAAQC,KAAK,KAAA,OAAA,KAAA,IAAjB,OAAmBC,KAAK,CAAC;YACjD,IAAIH,oBAAoBI,aAAaJ,gBAAgBK,MAAM,GAAG,GAAG;gBAC/DnB,eAAeY;YACjB,OAAO;gBACL,SAAS;gBACT,oBAAoB;gBACpB,uCAAuC;gBACvC,wBAAwB;gBACxB,iEAAiE;gBACjE,MAAMJ,MAAMM,eAAe,CAAC,EAAE;gBAC9BnB,SAASC,OAAO,GAAGgB;gBACnBL,uBAAuBC;YACzB;QACF,OAAO;;QAEP;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 13673, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/next/src/server/app-render/after-task-async-storage-instance.ts"],"sourcesContent":["import type { AfterTaskAsyncStorage } from './after-task-async-storage.external'\nimport { createAsyncLocalStorage } from './async-local-storage'\n\nexport const afterTaskAsyncStorageInstance: AfterTaskAsyncStorage =\n  createAsyncLocalStorage()\n"],"names":["afterTaskAsyncStorageInstance","createAsyncLocalStorage"],"mappings":";;;;+BAGaA,iCAAAA;;;eAAAA;;;mCAF2B;AAEjC,MAAMA,gCACXC,CAAAA,GAAAA,mBAAAA,uBAAuB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 13690, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/next/src/server/app-render/after-task-async-storage.external.ts"],"sourcesContent":["import type { AsyncLocalStorage } from 'async_hooks'\n\n// Share the instance module in the next-shared layer\nimport { afterTaskAsyncStorageInstance as afterTaskAsyncStorage } from './after-task-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\nimport type { WorkUnitStore } from './work-unit-async-storage.external'\n\nexport interface AfterTaskStore {\n  /** The phase in which the topmost `after` was called.\n   *\n   * NOTE: Can be undefined when running `generateStaticParams`,\n   * where we only have a `workStore`, no `workUnitStore`.\n   */\n  readonly rootTaskSpawnPhase: WorkUnitStore['phase'] | undefined\n}\n\nexport type AfterTaskAsyncStorage = AsyncLocalStorage<AfterTaskStore>\n\nexport { afterTaskAsyncStorage }\n"],"names":["afterTaskAsyncStorage"],"mappings":";;;;+BAiBSA,yBAAAA;;;eAAAA,+BAAAA,6BAAqB;;;+CAdyC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 13706, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/next/src/server/request/utils.ts"],"sourcesContent":["import { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { afterTaskAsyncStorage } from '../app-render/after-task-async-storage.external'\nimport type { WorkStore } from '../app-render/work-async-storage.external'\n\nexport function throwWithStaticGenerationBailoutError(\n  route: string,\n  expression: string\n): never {\n  throw new StaticGenBailoutError(\n    `Route ${route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n  )\n}\n\nexport function throwWithStaticGenerationBailoutErrorWithDynamicError(\n  route: string,\n  expression: string\n): never {\n  throw new StaticGenBailoutError(\n    `Route ${route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n  )\n}\n\nexport function throwForSearchParamsAccessInUseCache(\n  workStore: WorkStore\n): never {\n  const error = new Error(\n    `Route ${workStore.route} used \"searchParams\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"searchParams\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n  )\n\n  workStore.invalidUsageError ??= error\n\n  throw error\n}\n\nexport function isRequestAPICallableInsideAfter() {\n  const afterTaskStore = afterTaskAsyncStorage.getStore()\n  return afterTaskStore?.rootTaskSpawnPhase === 'action'\n}\n"],"names":["isRequestAPICallableInsideAfter","throwForSearchParamsAccessInUseCache","throwWithStaticGenerationBailoutError","throwWithStaticGenerationBailoutErrorWithDynamicError","route","expression","StaticGenBailoutError","workStore","error","Error","invalidUsageError","afterTaskStore","afterTaskAsyncStorage","getStore","rootTaskSpawnPhase"],"mappings":";;;;;;;;;;;;;;;;;IAkCgBA,+BAA+B,EAAA;eAA/BA;;IAZAC,oCAAoC,EAAA;eAApCA;;IAlBAC,qCAAqC,EAAA;eAArCA;;IASAC,qDAAqD,EAAA;eAArDA;;;yCAbsB;+CACA;AAG/B,SAASD,sCACdE,KAAa,EACbC,UAAkB;IAElB,MAAM,OAAA,cAEL,CAFK,IAAIC,yBAAAA,qBAAqB,CAC7B,CAAC,MAAM,EAAEF,MAAM,iDAAiD,EAAEC,WAAW,0HAA0H,CAAC,GADpM,qBAAA;eAAA;oBAAA;sBAAA;IAEN;AACF;AAEO,SAASF,sDACdC,KAAa,EACbC,UAAkB;IAElB,MAAM,OAAA,cAEL,CAFK,IAAIC,yBAAAA,qBAAqB,CAC7B,CAAC,MAAM,EAAEF,MAAM,4EAA4E,EAAEC,WAAW,0HAA0H,CAAC,GAD/N,qBAAA;eAAA;oBAAA;sBAAA;IAEN;AACF;AAEO,SAASJ,qCACdM,SAAoB;IAEpB,MAAMC,QAAQ,OAAA,cAEb,CAFa,IAAIC,MAChB,CAAC,MAAM,EAAEF,UAAUH,KAAK,CAAC,oVAAoV,CAAC,GADlW,qBAAA;eAAA;oBAAA;sBAAA;IAEd;IAEAG,UAAUG,iBAAiB,KAAKF;IAEhC,MAAMA;AACR;AAEO,SAASR;IACd,MAAMW,iBAAiBC,+BAAAA,qBAAqB,CAACC,QAAQ;IACrD,OAAOF,CAAAA,kBAAAA,OAAAA,KAAAA,IAAAA,eAAgBG,kBAAkB,MAAK;AAChD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 13770, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/next/src/server/request/search-params.ts"],"sourcesContent":["import type { WorkStore } from '../app-render/work-async-storage.external'\n\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\nimport {\n  abortAndThrowOnSynchronousRequestDataAccess,\n  throwToInterruptStaticGeneration,\n  postponeWithTracking,\n  trackDynamicDataInDynamicRender,\n  annotateDynamicAccess,\n  trackSynchronousRequestDataAccessInDev,\n} from '../app-render/dynamic-rendering'\n\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStore,\n  type PrerenderStoreLegacy,\n  type PrerenderStorePPR,\n  type PrerenderStoreModern,\n} from '../app-render/work-unit-async-storage.external'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport {\n  describeStringPropertyAccess,\n  describeHasCheckingStringProperty,\n  wellKnownProperties,\n} from '../../shared/lib/utils/reflect-utils'\nimport {\n  throwWithStaticGenerationBailoutErrorWithDynamicError,\n  throwForSearchParamsAccessInUseCache,\n} from './utils'\nimport { scheduleImmediate } from '../../lib/scheduler'\n\nexport type SearchParams = { [key: string]: string | string[] | undefined }\n\n/**\n * In this version of Next.js the `params` prop passed to Layouts, Pages, and other Segments is a Promise.\n * However to facilitate migration to this new Promise type you can currently still access params directly on the Promise instance passed to these Segments.\n * The `UnsafeUnwrappedSearchParams` type is available if you need to temporarily access the underlying params without first awaiting or `use`ing the Promise.\n *\n * In a future version of Next.js the `params` prop will be a plain Promise and this type will be removed.\n *\n * Typically instances of `params` can be updated automatically to be treated as a Promise by a codemod published alongside this Next.js version however if you\n * have not yet run the codemod of the codemod cannot detect certain instances of `params` usage you should first try to refactor your code to await `params`.\n *\n * If refactoring is not possible but you still want to be able to access params directly without typescript errors you can cast the params Promise to this type\n *\n * ```tsx\n * type Props = { searchParams: Promise<{ foo: string }> }\n *\n * export default async function Page(props: Props) {\n *  const { searchParams } = (props.searchParams as unknown as UnsafeUnwrappedSearchParams<typeof props.searchParams>)\n *  return ...\n * }\n * ```\n *\n * This type is marked deprecated to help identify it as target for refactoring away.\n *\n * @deprecated\n */\nexport type UnsafeUnwrappedSearchParams<P> =\n  P extends Promise<infer U> ? Omit<U, 'then' | 'status' | 'value'> : never\n\nexport function createSearchParamsFromClient(\n  underlyingSearchParams: SearchParams,\n  workStore: WorkStore\n) {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createPrerenderSearchParams(workStore, workUnitStore)\n      default:\n      // fallthrough\n    }\n  }\n  return createRenderSearchParams(underlyingSearchParams, workStore)\n}\n\n// generateMetadata always runs in RSC context so it is equivalent to a Server Page Component\nexport const createServerSearchParamsForMetadata =\n  createServerSearchParamsForServerPage\n\nexport function createServerSearchParamsForServerPage(\n  underlyingSearchParams: SearchParams,\n  workStore: WorkStore\n): Promise<SearchParams> {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createPrerenderSearchParams(workStore, workUnitStore)\n      default:\n      // fallthrough\n    }\n  }\n  return createRenderSearchParams(underlyingSearchParams, workStore)\n}\n\nexport function createPrerenderSearchParamsForClientPage(\n  workStore: WorkStore\n): Promise<SearchParams> {\n  if (workStore.forceStatic) {\n    // When using forceStatic we override all other logic and always just return an empty\n    // dictionary object.\n    return Promise.resolve({})\n  }\n\n  const prerenderStore = workUnitAsyncStorage.getStore()\n  if (prerenderStore && prerenderStore.type === 'prerender') {\n    // dynamicIO Prerender\n    // We're prerendering in a mode that aborts (dynamicIO) and should stall\n    // the promise to ensure the RSC side is considered dynamic\n    return makeHangingPromise(prerenderStore.renderSignal, '`searchParams`')\n  }\n  // We're prerendering in a mode that does not aborts. We resolve the promise without\n  // any tracking because we're just transporting a value from server to client where the tracking\n  // will be applied.\n  return Promise.resolve({})\n}\n\nfunction createPrerenderSearchParams(\n  workStore: WorkStore,\n  prerenderStore: PrerenderStore\n): Promise<SearchParams> {\n  if (workStore.forceStatic) {\n    // When using forceStatic we override all other logic and always just return an empty\n    // dictionary object.\n    return Promise.resolve({})\n  }\n\n  if (prerenderStore.type === 'prerender') {\n    // We are in a dynamicIO (PPR or otherwise) prerender\n    return makeAbortingExoticSearchParams(workStore.route, prerenderStore)\n  }\n\n  // The remaining cases are prerender-ppr and prerender-legacy\n  // We are in a legacy static generation and need to interrupt the prerender\n  // when search params are accessed.\n  return makeErroringExoticSearchParams(workStore, prerenderStore)\n}\n\nfunction createRenderSearchParams(\n  underlyingSearchParams: SearchParams,\n  workStore: WorkStore\n): Promise<SearchParams> {\n  if (workStore.forceStatic) {\n    // When using forceStatic we override all other logic and always just return an empty\n    // dictionary object.\n    return Promise.resolve({})\n  } else {\n    if (\n      process.env.NODE_ENV === 'development' &&\n      !workStore.isPrefetchRequest\n    ) {\n      return makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(\n        underlyingSearchParams,\n        workStore\n      )\n    } else {\n      return makeUntrackedExoticSearchParams(underlyingSearchParams, workStore)\n    }\n  }\n}\n\ninterface CacheLifetime {}\nconst CachedSearchParams = new WeakMap<CacheLifetime, Promise<SearchParams>>()\n\nconst CachedSearchParamsForUseCache = new WeakMap<\n  CacheLifetime,\n  Promise<SearchParams>\n>()\n\nfunction makeAbortingExoticSearchParams(\n  route: string,\n  prerenderStore: PrerenderStoreModern\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(prerenderStore)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const promise = makeHangingPromise<SearchParams>(\n    prerenderStore.renderSignal,\n    '`searchParams`'\n  )\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (Object.hasOwn(promise, prop)) {\n        // The promise has this property directly. we must return it.\n        // We know it isn't a dynamic access because it can only be something\n        // that was previously written to the promise and thus not an underlying searchParam value\n        return ReflectAdapter.get(target, prop, receiver)\n      }\n\n      switch (prop) {\n        case 'then': {\n          const expression =\n            '`await searchParams`, `searchParams.then`, or similar'\n          annotateDynamicAccess(expression, prerenderStore)\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n        case 'status': {\n          const expression =\n            '`use(searchParams)`, `searchParams.status`, or similar'\n          annotateDynamicAccess(expression, prerenderStore)\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n\n        default: {\n          if (typeof prop === 'string' && !wellKnownProperties.has(prop)) {\n            const expression = describeStringPropertyAccess(\n              'searchParams',\n              prop\n            )\n            const error = createSearchAccessError(route, expression)\n            abortAndThrowOnSynchronousRequestDataAccess(\n              route,\n              expression,\n              error,\n              prerenderStore\n            )\n          }\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n      }\n    },\n    has(target, prop) {\n      // We don't expect key checking to be used except for testing the existence of\n      // searchParams so we make all has tests trigger dynamic. this means that `promise.then`\n      // can resolve to the then function on the Promise prototype but 'then' in promise will assume\n      // you are testing whether the searchParams has a 'then' property.\n      if (typeof prop === 'string') {\n        const expression = describeHasCheckingStringProperty(\n          'searchParams',\n          prop\n        )\n        const error = createSearchAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      }\n      return ReflectAdapter.has(target, prop)\n    },\n    ownKeys() {\n      const expression =\n        '`{...searchParams}`, `Object.keys(searchParams)`, or similar'\n      const error = createSearchAccessError(route, expression)\n      abortAndThrowOnSynchronousRequestDataAccess(\n        route,\n        expression,\n        error,\n        prerenderStore\n      )\n    },\n  })\n\n  CachedSearchParams.set(prerenderStore, proxiedPromise)\n  return proxiedPromise\n}\n\nfunction makeErroringExoticSearchParams(\n  workStore: WorkStore,\n  prerenderStore: PrerenderStoreLegacy | PrerenderStorePPR\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(workStore)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const underlyingSearchParams = {}\n  // For search params we don't construct a ReactPromise because we want to interrupt\n  // rendering on any property access that was not set from outside and so we only want\n  // to have properties like value and status if React sets them.\n  const promise = Promise.resolve(underlyingSearchParams)\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (Object.hasOwn(promise, prop)) {\n        // The promise has this property directly. we must return it.\n        // We know it isn't a dynamic access because it can only be something\n        // that was previously written to the promise and thus not an underlying searchParam value\n        return ReflectAdapter.get(target, prop, receiver)\n      }\n\n      switch (prop) {\n        case 'then': {\n          const expression =\n            '`await searchParams`, `searchParams.then`, or similar'\n          if (workStore.dynamicShouldError) {\n            throwWithStaticGenerationBailoutErrorWithDynamicError(\n              workStore.route,\n              expression\n            )\n          } else if (prerenderStore.type === 'prerender-ppr') {\n            // PPR Prerender (no dynamicIO)\n            postponeWithTracking(\n              workStore.route,\n              expression,\n              prerenderStore.dynamicTracking\n            )\n          } else {\n            // Legacy Prerender\n            throwToInterruptStaticGeneration(\n              expression,\n              workStore,\n              prerenderStore\n            )\n          }\n          return\n        }\n        case 'status': {\n          const expression =\n            '`use(searchParams)`, `searchParams.status`, or similar'\n          if (workStore.dynamicShouldError) {\n            throwWithStaticGenerationBailoutErrorWithDynamicError(\n              workStore.route,\n              expression\n            )\n          } else if (prerenderStore.type === 'prerender-ppr') {\n            // PPR Prerender (no dynamicIO)\n            postponeWithTracking(\n              workStore.route,\n              expression,\n              prerenderStore.dynamicTracking\n            )\n          } else {\n            // Legacy Prerender\n            throwToInterruptStaticGeneration(\n              expression,\n              workStore,\n              prerenderStore\n            )\n          }\n          return\n        }\n        default: {\n          if (typeof prop === 'string' && !wellKnownProperties.has(prop)) {\n            const expression = describeStringPropertyAccess(\n              'searchParams',\n              prop\n            )\n            if (workStore.dynamicShouldError) {\n              throwWithStaticGenerationBailoutErrorWithDynamicError(\n                workStore.route,\n                expression\n              )\n            } else if (prerenderStore.type === 'prerender-ppr') {\n              // PPR Prerender (no dynamicIO)\n              postponeWithTracking(\n                workStore.route,\n                expression,\n                prerenderStore.dynamicTracking\n              )\n            } else {\n              // Legacy Prerender\n              throwToInterruptStaticGeneration(\n                expression,\n                workStore,\n                prerenderStore\n              )\n            }\n          }\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n      }\n    },\n    has(target, prop) {\n      // We don't expect key checking to be used except for testing the existence of\n      // searchParams so we make all has tests trigger dynamic. this means that `promise.then`\n      // can resolve to the then function on the Promise prototype but 'then' in promise will assume\n      // you are testing whether the searchParams has a 'then' property.\n      if (typeof prop === 'string') {\n        const expression = describeHasCheckingStringProperty(\n          'searchParams',\n          prop\n        )\n        if (workStore.dynamicShouldError) {\n          throwWithStaticGenerationBailoutErrorWithDynamicError(\n            workStore.route,\n            expression\n          )\n        } else if (prerenderStore.type === 'prerender-ppr') {\n          // PPR Prerender (no dynamicIO)\n          postponeWithTracking(\n            workStore.route,\n            expression,\n            prerenderStore.dynamicTracking\n          )\n        } else {\n          // Legacy Prerender\n          throwToInterruptStaticGeneration(\n            expression,\n            workStore,\n            prerenderStore\n          )\n        }\n        return false\n      }\n      return ReflectAdapter.has(target, prop)\n    },\n    ownKeys() {\n      const expression =\n        '`{...searchParams}`, `Object.keys(searchParams)`, or similar'\n      if (workStore.dynamicShouldError) {\n        throwWithStaticGenerationBailoutErrorWithDynamicError(\n          workStore.route,\n          expression\n        )\n      } else if (prerenderStore.type === 'prerender-ppr') {\n        // PPR Prerender (no dynamicIO)\n        postponeWithTracking(\n          workStore.route,\n          expression,\n          prerenderStore.dynamicTracking\n        )\n      } else {\n        // Legacy Prerender\n        throwToInterruptStaticGeneration(expression, workStore, prerenderStore)\n      }\n    },\n  })\n\n  CachedSearchParams.set(workStore, proxiedPromise)\n  return proxiedPromise\n}\n\n/**\n * This is a variation of `makeErroringExoticSearchParams` that always throws an\n * error on access, because accessing searchParams inside of `\"use cache\"` is\n * not allowed.\n */\nexport function makeErroringExoticSearchParamsForUseCache(\n  workStore: WorkStore\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParamsForUseCache.get(workStore)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const promise = Promise.resolve({})\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (Object.hasOwn(promise, prop)) {\n        // The promise has this property directly. we must return it. We know it\n        // isn't a dynamic access because it can only be something that was\n        // previously written to the promise and thus not an underlying\n        // searchParam value\n        return ReflectAdapter.get(target, prop, receiver)\n      }\n\n      if (\n        typeof prop === 'string' &&\n        (prop === 'then' || !wellKnownProperties.has(prop))\n      ) {\n        throwForSearchParamsAccessInUseCache(workStore)\n      }\n\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    has(target, prop) {\n      // We don't expect key checking to be used except for testing the existence of\n      // searchParams so we make all has tests throw an error. this means that `promise.then`\n      // can resolve to the then function on the Promise prototype but 'then' in promise will assume\n      // you are testing whether the searchParams has a 'then' property.\n      if (\n        typeof prop === 'string' &&\n        (prop === 'then' || !wellKnownProperties.has(prop))\n      ) {\n        throwForSearchParamsAccessInUseCache(workStore)\n      }\n\n      return ReflectAdapter.has(target, prop)\n    },\n    ownKeys() {\n      throwForSearchParamsAccessInUseCache(workStore)\n    },\n  })\n\n  CachedSearchParamsForUseCache.set(workStore, proxiedPromise)\n  return proxiedPromise\n}\n\nfunction makeUntrackedExoticSearchParams(\n  underlyingSearchParams: SearchParams,\n  store: WorkStore\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  // We don't use makeResolvedReactPromise here because searchParams\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(underlyingSearchParams)\n  CachedSearchParams.set(underlyingSearchParams, promise)\n\n  Object.keys(underlyingSearchParams).forEach((prop) => {\n    if (!wellKnownProperties.has(prop)) {\n      Object.defineProperty(promise, prop, {\n        get() {\n          const workUnitStore = workUnitAsyncStorage.getStore()\n          trackDynamicDataInDynamicRender(store, workUnitStore)\n          return underlyingSearchParams[prop]\n        },\n        set(value) {\n          Object.defineProperty(promise, prop, {\n            value,\n            writable: true,\n            enumerable: true,\n          })\n        },\n        enumerable: true,\n        configurable: true,\n      })\n    }\n  })\n\n  return promise\n}\n\nfunction makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(\n  underlyingSearchParams: SearchParams,\n  store: WorkStore\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const proxiedProperties = new Set<string>()\n  const unproxiedProperties: Array<string> = []\n\n  // We have an unfortunate sequence of events that requires this initialization logic. We want to instrument the underlying\n  // searchParams object to detect if you are accessing values in dev. This is used for warnings and for things like the static prerender\n  // indicator. However when we pass this proxy to our Promise.resolve() below the VM checks if the resolved value is a promise by looking\n  // at the `.then` property. To our dynamic tracking logic this is indistinguishable from a `then` searchParam and so we would normally trigger\n  // dynamic tracking. However we know that this .then is not real dynamic access, it's just how thenables resolve in sequence. So we introduce\n  // this initialization concept so we omit the dynamic check until after we've constructed our resolved promise.\n  let promiseInitialized = false\n  const proxiedUnderlying = new Proxy(underlyingSearchParams, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string' && promiseInitialized) {\n        if (store.dynamicShouldError) {\n          const expression = describeStringPropertyAccess('searchParams', prop)\n          throwWithStaticGenerationBailoutErrorWithDynamicError(\n            store.route,\n            expression\n          )\n        }\n        const workUnitStore = workUnitAsyncStorage.getStore()\n        trackDynamicDataInDynamicRender(store, workUnitStore)\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    has(target, prop) {\n      if (typeof prop === 'string') {\n        if (store.dynamicShouldError) {\n          const expression = describeHasCheckingStringProperty(\n            'searchParams',\n            prop\n          )\n          throwWithStaticGenerationBailoutErrorWithDynamicError(\n            store.route,\n            expression\n          )\n        }\n      }\n      return Reflect.has(target, prop)\n    },\n    ownKeys(target) {\n      if (store.dynamicShouldError) {\n        const expression =\n          '`{...searchParams}`, `Object.keys(searchParams)`, or similar'\n        throwWithStaticGenerationBailoutErrorWithDynamicError(\n          store.route,\n          expression\n        )\n      }\n      return Reflect.ownKeys(target)\n    },\n  })\n\n  // We don't use makeResolvedReactPromise here because searchParams\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = new Promise<SearchParams>((resolve) =>\n    scheduleImmediate(() => resolve(underlyingSearchParams))\n  )\n  promise.then(() => {\n    promiseInitialized = true\n  })\n\n  Object.keys(underlyingSearchParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n      unproxiedProperties.push(prop)\n    } else {\n      proxiedProperties.add(prop)\n      Object.defineProperty(promise, prop, {\n        get() {\n          return proxiedUnderlying[prop]\n        },\n        set(newValue) {\n          Object.defineProperty(promise, prop, {\n            value: newValue,\n            writable: true,\n            enumerable: true,\n          })\n        },\n        enumerable: true,\n        configurable: true,\n      })\n    }\n  })\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (prop === 'then' && store.dynamicShouldError) {\n        const expression = '`searchParams.then`'\n        throwWithStaticGenerationBailoutErrorWithDynamicError(\n          store.route,\n          expression\n        )\n      }\n      if (typeof prop === 'string') {\n        if (\n          !wellKnownProperties.has(prop) &&\n          (proxiedProperties.has(prop) ||\n            // We are accessing a property that doesn't exist on the promise nor\n            // the underlying searchParams.\n            Reflect.has(target, prop) === false)\n        ) {\n          const expression = describeStringPropertyAccess('searchParams', prop)\n          syncIODev(store.route, expression)\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop)\n      }\n      return Reflect.set(target, prop, value, receiver)\n    },\n    has(target, prop) {\n      if (typeof prop === 'string') {\n        if (\n          !wellKnownProperties.has(prop) &&\n          (proxiedProperties.has(prop) ||\n            // We are accessing a property that doesn't exist on the promise nor\n            // the underlying searchParams.\n            Reflect.has(target, prop) === false)\n        ) {\n          const expression = describeHasCheckingStringProperty(\n            'searchParams',\n            prop\n          )\n          syncIODev(store.route, expression)\n        }\n      }\n      return Reflect.has(target, prop)\n    },\n    ownKeys(target) {\n      const expression = '`Object.keys(searchParams)` or similar'\n      syncIODev(store.route, expression, unproxiedProperties)\n      return Reflect.ownKeys(target)\n    },\n  })\n\n  CachedSearchParams.set(underlyingSearchParams, proxiedPromise)\n  return proxiedPromise\n}\n\nfunction syncIODev(\n  route: string | undefined,\n  expression: string,\n  missingProperties?: Array<string>\n) {\n  // In all cases we warn normally\n  if (missingProperties && missingProperties.length > 0) {\n    warnForIncompleteEnumeration(route, expression, missingProperties)\n  } else {\n    warnForSyncAccess(route, expression)\n  }\n\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (\n    workUnitStore &&\n    workUnitStore.type === 'request' &&\n    workUnitStore.prerenderPhase === true\n  ) {\n    // When we're rendering dynamically in dev we need to advance out of the\n    // Prerender environment when we read Request data synchronously\n    const requestStore = workUnitStore\n    trackSynchronousRequestDataAccessInDev(requestStore)\n  }\n}\n\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createSearchAccessError\n)\n\nconst warnForIncompleteEnumeration =\n  createDedupedByCallsiteServerErrorLoggerDev(createIncompleteEnumerationError)\n\nfunction createSearchAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`searchParams\\` should be awaited before using its properties. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\nfunction createIncompleteEnumerationError(\n  route: string | undefined,\n  expression: string,\n  missingProperties: Array<string>\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`searchParams\\` should be awaited before using its properties. ` +\n      `The following properties were not available through enumeration ` +\n      `because they conflict with builtin or well-known property names: ` +\n      `${describeListOfPropertyNames(missingProperties)}. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\nfunction describeListOfPropertyNames(properties: Array<string>) {\n  switch (properties.length) {\n    case 0:\n      throw new InvariantError(\n        'Expected describeListOfPropertyNames to be called with a non-empty list of strings.'\n      )\n    case 1:\n      return `\\`${properties[0]}\\``\n    case 2:\n      return `\\`${properties[0]}\\` and \\`${properties[1]}\\``\n    default: {\n      let description = ''\n      for (let i = 0; i < properties.length - 1; i++) {\n        description += `\\`${properties[i]}\\`, `\n      }\n      description += `, and \\`${properties[properties.length - 1]}\\``\n      return description\n    }\n  }\n}\n"],"names":["createPrerenderSearchParamsForClientPage","createSearchParamsFromClient","createServerSearchParamsForMetadata","createServerSearchParamsForServerPage","makeErroringExoticSearchParamsForUseCache","underlyingSearchParams","workStore","workUnitStore","workUnitAsyncStorage","getStore","type","createPrerenderSearchParams","createRenderSearchParams","forceStatic","Promise","resolve","prerenderStore","makeHangingPromise","renderSignal","makeAbortingExoticSearchParams","route","makeErroringExoticSearchParams","process","env","NODE_ENV","isPrefetchRequest","makeDynamicallyTrackedExoticSearchParamsWithDevWarnings","makeUntrackedExoticSearchParams","CachedSearchParams","WeakMap","CachedSearchParamsForUseCache","cachedSearchParams","get","promise","proxiedPromise","Proxy","target","prop","receiver","Object","hasOwn","ReflectAdapter","expression","annotateDynamicAccess","wellKnownProperties","has","describeStringPropertyAccess","error","createSearchAccessError","abortAndThrowOnSynchronousRequestDataAccess","describeHasCheckingStringProperty","ownKeys","set","dynamicShouldError","throwWithStaticGenerationBailoutErrorWithDynamicError","postponeWithTracking","dynamicTracking","throwToInterruptStaticGeneration","throwForSearchParamsAccessInUseCache","store","keys","forEach","defineProperty","trackDynamicDataInDynamicRender","value","writable","enumerable","configurable","proxiedProperties","Set","unproxiedProperties","promiseInitialized","proxiedUnderlying","Reflect","scheduleImmediate","then","push","add","newValue","syncIODev","delete","missingProperties","length","warnForIncompleteEnumeration","warnForSyncAccess","prerenderPhase","requestStore","trackSynchronousRequestDataAccessInDev","createDedupedByCallsiteServerErrorLoggerDev","createIncompleteEnumerationError","prefix","Error","describeListOfPropertyNames","properties","InvariantError","description","i"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 14294, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/next/src/server/request/params.ts"],"sourcesContent":["import type { WorkStore } from '../app-render/work-async-storage.external'\nimport type { FallbackRouteParams } from './fallback-params'\n\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\nimport {\n  abortAndThrowOnSynchronousRequestDataAccess,\n  throwToInterruptStaticGeneration,\n  postponeWithTracking,\n  trackSynchronousRequestDataAccessInDev,\n} from '../app-render/dynamic-rendering'\n\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStore,\n  type PrerenderStorePPR,\n  type PrerenderStoreLegacy,\n  type PrerenderStoreModern,\n} from '../app-render/work-unit-async-storage.external'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport {\n  describeStringPropertyAccess,\n  wellKnownProperties,\n} from '../../shared/lib/utils/reflect-utils'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport { scheduleImmediate } from '../../lib/scheduler'\n\nexport type ParamValue = string | Array<string> | undefined\nexport type Params = Record<string, ParamValue>\n\n/**\n * In this version of Next.js the `params` prop passed to Layouts, Pages, and other Segments is a Promise.\n * However to facilitate migration to this new Promise type you can currently still access params directly on the Promise instance passed to these Segments.\n * The `UnsafeUnwrappedParams` type is available if you need to temporarily access the underlying params without first awaiting or `use`ing the Promise.\n *\n * In a future version of Next.js the `params` prop will be a plain Promise and this type will be removed.\n *\n * Typically instances of `params` can be updated automatically to be treated as a Promise by a codemod published alongside this Next.js version however if you\n * have not yet run the codemod of the codemod cannot detect certain instances of `params` usage you should first try to refactor your code to await `params`.\n *\n * If refactoring is not possible but you still want to be able to access params directly without typescript errors you can cast the params Promise to this type\n *\n * ```tsx\n * type Props = { params: Promise<{ id: string }>}\n *\n * export default async function Layout(props: Props) {\n *  const directParams = (props.params as unknown as UnsafeUnwrappedParams<typeof props.params>)\n *  return ...\n * }\n * ```\n *\n * This type is marked deprecated to help identify it as target for refactoring away.\n *\n * @deprecated\n */\nexport type UnsafeUnwrappedParams<P> =\n  P extends Promise<infer U> ? Omit<U, 'then' | 'status' | 'value'> : never\n\nexport function createParamsFromClient(\n  underlyingParams: Params,\n  workStore: WorkStore\n) {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createPrerenderParams(underlyingParams, workStore, workUnitStore)\n      default:\n      // fallthrough\n    }\n  }\n  return createRenderParams(underlyingParams, workStore)\n}\n\n// generateMetadata always runs in RSC context so it is equivalent to a Server Page Component\nexport type CreateServerParamsForMetadata = typeof createServerParamsForMetadata\nexport const createServerParamsForMetadata = createServerParamsForServerSegment\n\n// routes always runs in RSC context so it is equivalent to a Server Page Component\nexport function createServerParamsForRoute(\n  underlyingParams: Params,\n  workStore: WorkStore\n) {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createPrerenderParams(underlyingParams, workStore, workUnitStore)\n      default:\n      // fallthrough\n    }\n  }\n  return createRenderParams(underlyingParams, workStore)\n}\n\nexport function createServerParamsForServerSegment(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createPrerenderParams(underlyingParams, workStore, workUnitStore)\n      default:\n      // fallthrough\n    }\n  }\n  return createRenderParams(underlyingParams, workStore)\n}\n\nexport function createPrerenderParamsForClientSegment(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  const prerenderStore = workUnitAsyncStorage.getStore()\n  if (prerenderStore && prerenderStore.type === 'prerender') {\n    const fallbackParams = workStore.fallbackRouteParams\n    if (fallbackParams) {\n      for (let key in underlyingParams) {\n        if (fallbackParams.has(key)) {\n          // This params object has one of more fallback params so we need to consider\n          // the awaiting of this params object \"dynamic\". Since we are in dynamicIO mode\n          // we encode this as a promise that never resolves\n          return makeHangingPromise(prerenderStore.renderSignal, '`params`')\n        }\n      }\n    }\n  }\n  // We're prerendering in a mode that does not abort. We resolve the promise without\n  // any tracking because we're just transporting a value from server to client where the tracking\n  // will be applied.\n  return Promise.resolve(underlyingParams)\n}\n\nfunction createPrerenderParams(\n  underlyingParams: Params,\n  workStore: WorkStore,\n  prerenderStore: PrerenderStore\n): Promise<Params> {\n  const fallbackParams = workStore.fallbackRouteParams\n  if (fallbackParams) {\n    let hasSomeFallbackParams = false\n    for (const key in underlyingParams) {\n      if (fallbackParams.has(key)) {\n        hasSomeFallbackParams = true\n        break\n      }\n    }\n\n    if (hasSomeFallbackParams) {\n      // params need to be treated as dynamic because we have at least one fallback param\n      if (prerenderStore.type === 'prerender') {\n        // We are in a dynamicIO (PPR or otherwise) prerender\n        return makeAbortingExoticParams(\n          underlyingParams,\n          workStore.route,\n          prerenderStore\n        )\n      }\n      // remaining cases are prerender-ppr and prerender-legacy\n      // We aren't in a dynamicIO prerender but we do have fallback params at this\n      // level so we need to make an erroring exotic params object which will postpone\n      // if you access the fallback params\n      return makeErroringExoticParams(\n        underlyingParams,\n        fallbackParams,\n        workStore,\n        prerenderStore\n      )\n    }\n  }\n\n  // We don't have any fallback params so we have an entirely static safe params object\n  return makeUntrackedExoticParams(underlyingParams)\n}\n\nfunction createRenderParams(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  if (process.env.NODE_ENV === 'development' && !workStore.isPrefetchRequest) {\n    return makeDynamicallyTrackedExoticParamsWithDevWarnings(\n      underlyingParams,\n      workStore\n    )\n  } else {\n    return makeUntrackedExoticParams(underlyingParams)\n  }\n}\n\ninterface CacheLifetime {}\nconst CachedParams = new WeakMap<CacheLifetime, Promise<Params>>()\n\nfunction makeAbortingExoticParams(\n  underlyingParams: Params,\n  route: string,\n  prerenderStore: PrerenderStoreModern\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const promise = makeHangingPromise<Params>(\n    prerenderStore.renderSignal,\n    '`params`'\n  )\n  CachedParams.set(underlyingParams, promise)\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      Object.defineProperty(promise, prop, {\n        get() {\n          const expression = describeStringPropertyAccess('params', prop)\n          const error = createParamsAccessError(route, expression)\n          abortAndThrowOnSynchronousRequestDataAccess(\n            route,\n            expression,\n            error,\n            prerenderStore\n          )\n        },\n        set(newValue) {\n          Object.defineProperty(promise, prop, {\n            value: newValue,\n            writable: true,\n            enumerable: true,\n          })\n        },\n        enumerable: true,\n        configurable: true,\n      })\n    }\n  })\n\n  return promise\n}\n\nfunction makeErroringExoticParams(\n  underlyingParams: Params,\n  fallbackParams: FallbackRouteParams,\n  workStore: WorkStore,\n  prerenderStore: PrerenderStorePPR | PrerenderStoreLegacy\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const augmentedUnderlying = { ...underlyingParams }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(augmentedUnderlying)\n  CachedParams.set(underlyingParams, promise)\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      if (fallbackParams.has(prop)) {\n        Object.defineProperty(augmentedUnderlying, prop, {\n          get() {\n            const expression = describeStringPropertyAccess('params', prop)\n            // In most dynamic APIs we also throw if `dynamic = \"error\"` however\n            // for params is only dynamic when we're generating a fallback shell\n            // and even when `dynamic = \"error\"` we still support generating dynamic\n            // fallback shells\n            // TODO remove this comment when dynamicIO is the default since there\n            // will be no `dynamic = \"error\"`\n            if (prerenderStore.type === 'prerender-ppr') {\n              // PPR Prerender (no dynamicIO)\n              postponeWithTracking(\n                workStore.route,\n                expression,\n                prerenderStore.dynamicTracking\n              )\n            } else {\n              // Legacy Prerender\n              throwToInterruptStaticGeneration(\n                expression,\n                workStore,\n                prerenderStore\n              )\n            }\n          },\n          enumerable: true,\n        })\n        Object.defineProperty(promise, prop, {\n          get() {\n            const expression = describeStringPropertyAccess('params', prop)\n            // In most dynamic APIs we also throw if `dynamic = \"error\"` however\n            // for params is only dynamic when we're generating a fallback shell\n            // and even when `dynamic = \"error\"` we still support generating dynamic\n            // fallback shells\n            // TODO remove this comment when dynamicIO is the default since there\n            // will be no `dynamic = \"error\"`\n            if (prerenderStore.type === 'prerender-ppr') {\n              // PPR Prerender (no dynamicIO)\n              postponeWithTracking(\n                workStore.route,\n                expression,\n                prerenderStore.dynamicTracking\n              )\n            } else {\n              // Legacy Prerender\n              throwToInterruptStaticGeneration(\n                expression,\n                workStore,\n                prerenderStore\n              )\n            }\n          },\n          set(newValue) {\n            Object.defineProperty(promise, prop, {\n              value: newValue,\n              writable: true,\n              enumerable: true,\n            })\n          },\n          enumerable: true,\n          configurable: true,\n        })\n      } else {\n        ;(promise as any)[prop] = underlyingParams[prop]\n      }\n    }\n  })\n\n  return promise\n}\n\nfunction makeUntrackedExoticParams(underlyingParams: Params): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(underlyingParams)\n  CachedParams.set(underlyingParams, promise)\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      ;(promise as any)[prop] = underlyingParams[prop]\n    }\n  })\n\n  return promise\n}\n\nfunction makeDynamicallyTrackedExoticParamsWithDevWarnings(\n  underlyingParams: Params,\n  store: WorkStore\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = new Promise<Params>((resolve) =>\n    scheduleImmediate(() => resolve(underlyingParams))\n  )\n\n  const proxiedProperties = new Set<string>()\n  const unproxiedProperties: Array<string> = []\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n      unproxiedProperties.push(prop)\n    } else {\n      proxiedProperties.add(prop)\n      ;(promise as any)[prop] = underlyingParams[prop]\n    }\n  })\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string') {\n        if (\n          // We are accessing a property that was proxied to the promise instance\n          proxiedProperties.has(prop)\n        ) {\n          const expression = describeStringPropertyAccess('params', prop)\n          syncIODev(store.route, expression)\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop)\n      }\n      return ReflectAdapter.set(target, prop, value, receiver)\n    },\n    ownKeys(target) {\n      const expression = '`...params` or similar expression'\n      syncIODev(store.route, expression, unproxiedProperties)\n      return Reflect.ownKeys(target)\n    },\n  })\n\n  CachedParams.set(underlyingParams, proxiedPromise)\n  return proxiedPromise\n}\n\nfunction syncIODev(\n  route: string | undefined,\n  expression: string,\n  missingProperties?: Array<string>\n) {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (\n    workUnitStore &&\n    workUnitStore.type === 'request' &&\n    workUnitStore.prerenderPhase === true\n  ) {\n    // When we're rendering dynamically in dev we need to advance out of the\n    // Prerender environment when we read Request data synchronously\n    const requestStore = workUnitStore\n    trackSynchronousRequestDataAccessInDev(requestStore)\n  }\n  // In all cases we warn normally\n  if (missingProperties && missingProperties.length > 0) {\n    warnForIncompleteEnumeration(route, expression, missingProperties)\n  } else {\n    warnForSyncAccess(route, expression)\n  }\n}\n\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createParamsAccessError\n)\n\nconst warnForIncompleteEnumeration =\n  createDedupedByCallsiteServerErrorLoggerDev(createIncompleteEnumerationError)\n\nfunction createParamsAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`params\\` should be awaited before using its properties. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\nfunction createIncompleteEnumerationError(\n  route: string | undefined,\n  expression: string,\n  missingProperties: Array<string>\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`params\\` should be awaited before using its properties. ` +\n      `The following properties were not available through enumeration ` +\n      `because they conflict with builtin property names: ` +\n      `${describeListOfPropertyNames(missingProperties)}. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\nfunction describeListOfPropertyNames(properties: Array<string>) {\n  switch (properties.length) {\n    case 0:\n      throw new InvariantError(\n        'Expected describeListOfPropertyNames to be called with a non-empty list of strings.'\n      )\n    case 1:\n      return `\\`${properties[0]}\\``\n    case 2:\n      return `\\`${properties[0]}\\` and \\`${properties[1]}\\``\n    default: {\n      let description = ''\n      for (let i = 0; i < properties.length - 1; i++) {\n        description += `\\`${properties[i]}\\`, `\n      }\n      description += `, and \\`${properties[properties.length - 1]}\\``\n      return description\n    }\n  }\n}\n"],"names":["createParamsFromClient","createPrerenderParamsForClientSegment","createServerParamsForMetadata","createServerParamsForRoute","createServerParamsForServerSegment","underlyingParams","workStore","workUnitStore","workUnitAsyncStorage","getStore","type","createPrerenderParams","createRenderParams","prerenderStore","fallbackParams","fallbackRouteParams","key","has","makeHangingPromise","renderSignal","Promise","resolve","hasSomeFallbackParams","makeAbortingExoticParams","route","makeErroringExoticParams","makeUntrackedExoticParams","process","env","NODE_ENV","isPrefetchRequest","makeDynamicallyTrackedExoticParamsWithDevWarnings","CachedParams","WeakMap","cachedParams","get","promise","set","Object","keys","forEach","prop","wellKnownProperties","defineProperty","expression","describeStringPropertyAccess","error","createParamsAccessError","abortAndThrowOnSynchronousRequestDataAccess","newValue","value","writable","enumerable","configurable","augmentedUnderlying","postponeWithTracking","dynamicTracking","throwToInterruptStaticGeneration","store","scheduleImmediate","proxiedProperties","Set","unproxiedProperties","push","add","proxiedPromise","Proxy","target","receiver","syncIODev","ReflectAdapter","delete","ownKeys","Reflect","missingProperties","prerenderPhase","requestStore","trackSynchronousRequestDataAccessInDev","length","warnForIncompleteEnumeration","warnForSyncAccess","createDedupedByCallsiteServerErrorLoggerDev","createIncompleteEnumerationError","prefix","Error","describeListOfPropertyNames","properties","InvariantError","description","i"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 14664, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/next/src/client/components/client-page.tsx"],"sourcesContent":["'use client'\n\nimport type { ParsedUrlQuery } from 'querystring'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nimport type { Params } from '../../server/request/params'\n\n/**\n * When the Page is a client component we send the params and searchParams to this client wrapper\n * where they are turned into dynamically tracked values before being passed to the actual Page component.\n *\n * additionally we may send promises representing the params and searchParams. We don't ever use these passed\n * values but it can be necessary for the sender to send a Promise that doesn't resolve in certain situations.\n * It is up to the caller to decide if the promises are needed.\n */\nexport function ClientPageRoot({\n  Component,\n  searchParams,\n  params,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  promises,\n}: {\n  Component: React.ComponentType<any>\n  searchParams: ParsedUrlQuery\n  params: Params\n  promises?: Array<Promise<any>>\n}) {\n  if (typeof window === 'undefined') {\n    const { workAsyncStorage } =\n      require('../../server/app-render/work-async-storage.external') as typeof import('../../server/app-render/work-async-storage.external')\n\n    let clientSearchParams: Promise<ParsedUrlQuery>\n    let clientParams: Promise<Params>\n    // We are going to instrument the searchParams prop with tracking for the\n    // appropriate context. We wrap differently in prerendering vs rendering\n    const store = workAsyncStorage.getStore()\n    if (!store) {\n      throw new InvariantError(\n        'Expected workStore to exist when handling searchParams in a client Page.'\n      )\n    }\n\n    const { createSearchParamsFromClient } =\n      require('../../server/request/search-params') as typeof import('../../server/request/search-params')\n    clientSearchParams = createSearchParamsFromClient(searchParams, store)\n\n    const { createParamsFromClient } =\n      require('../../server/request/params') as typeof import('../../server/request/params')\n    clientParams = createParamsFromClient(params, store)\n\n    return <Component params={clientParams} searchParams={clientSearchParams} />\n  } else {\n    const { createRenderSearchParamsFromClient } =\n      require('../request/search-params.browser') as typeof import('../request/search-params.browser')\n    const clientSearchParams = createRenderSearchParamsFromClient(searchParams)\n    const { createRenderParamsFromClient } =\n      require('../request/params.browser') as typeof import('../request/params.browser')\n    const clientParams = createRenderParamsFromClient(params)\n\n    return <Component params={clientParams} searchParams={clientSearchParams} />\n  }\n}\n"],"names":["ClientPageRoot","Component","searchParams","params","promises","window","workAsyncStorage","require","clientSearchParams","clientParams","store","getStore","InvariantError","createSearchParamsFromClient","createParamsFromClient","createRenderSearchParamsFromClient","createRenderParamsFromClient"],"mappings":"AAAA;;;;;+BAegBA,kBAAAA;;;eAAAA;;;;gCAZe;AAYxB,SAASA,eAAe,KAW9B;IAX8B,IAAA,EAC7BC,SAAS,EACTC,YAAY,EACZC,MAAM,EACN,AACAC,QAAQ,EAMT,GAX8B,gDAIgC;IAQ7D,IAAI,OAAOC,WAAW,aAAa;QACjC,MAAM,EAAEC,gBAAgB,EAAE,GACxBC,QAAQ;QAEV,IAAIC;QACJ,IAAIC;QACJ,yEAAyE;QACzE,wEAAwE;QACxE,MAAMC,QAAQJ,iBAAiBK,QAAQ;QACvC,IAAI,CAACD,OAAO;YACV,MAAM,OAAA,cAEL,CAFK,IAAIE,gBAAAA,cAAc,CACtB,6EADI,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QACF;QAEA,MAAM,EAAEC,4BAA4B,EAAE,GACpCN,QAAQ;QACVC,qBAAqBK,6BAA6BX,cAAcQ;QAEhE,MAAM,EAAEI,sBAAsB,EAAE,GAC9BP,QAAQ;QACVE,eAAeK,uBAAuBX,QAAQO;QAE9C,OAAA,WAAA,GAAO,CAAA,GAAA,YAAA,GAAA,EAACT,WAAAA;YAAUE,QAAQM;YAAcP,cAAcM;;IACxD,OAAO;QACL,MAAM,EAAEO,kCAAkC,EAAE,GAC1CR,QAAQ;QACV,MAAMC,qBAAqBO,mCAAmCb;QAC9D,MAAM,EAAEc,4BAA4B,EAAE,GACpCT,QAAQ;QACV,MAAME,eAAeO,6BAA6Bb;QAElD,OAAA,WAAA,GAAO,CAAA,GAAA,YAAA,GAAA,EAACF,WAAAA;YAAUE,QAAQM;YAAcP,cAAcM;;IACxD;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 14724, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/next/src/client/components/client-segment.tsx"],"sourcesContent":["'use client'\n\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nimport type { Params } from '../../server/request/params'\n\n/**\n * When the Page is a client component we send the params to this client wrapper\n * where they are turned into dynamically tracked values before being passed to the actual Segment component.\n *\n * additionally we may send a promise representing params. We don't ever use this passed\n * value but it can be necessary for the sender to send a Promise that doesn't resolve in certain situations\n * such as when dynamicIO is enabled. It is up to the caller to decide if the promises are needed.\n */\nexport function ClientSegmentRoot({\n  Component,\n  slots,\n  params,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  promise,\n}: {\n  Component: React.ComponentType<any>\n  slots: { [key: string]: React.ReactNode }\n  params: Params\n  promise?: Promise<any>\n}) {\n  if (typeof window === 'undefined') {\n    const { workAsyncStorage } =\n      require('../../server/app-render/work-async-storage.external') as typeof import('../../server/app-render/work-async-storage.external')\n\n    let clientParams: Promise<Params>\n    // We are going to instrument the searchParams prop with tracking for the\n    // appropriate context. We wrap differently in prerendering vs rendering\n    const store = workAsyncStorage.getStore()\n    if (!store) {\n      throw new InvariantError(\n        'Expected workStore to exist when handling params in a client segment such as a Layout or Template.'\n      )\n    }\n\n    const { createParamsFromClient } =\n      require('../../server/request/params') as typeof import('../../server/request/params')\n    clientParams = createParamsFromClient(params, store)\n\n    return <Component {...slots} params={clientParams} />\n  } else {\n    const { createRenderParamsFromClient } =\n      require('../request/params.browser') as typeof import('../request/params.browser')\n    const clientParams = createRenderParamsFromClient(params)\n    return <Component {...slots} params={clientParams} />\n  }\n}\n"],"names":["ClientSegmentRoot","Component","slots","params","promise","window","workAsyncStorage","require","clientParams","store","getStore","InvariantError","createParamsFromClient","createRenderParamsFromClient"],"mappings":"AAAA;;;;;+BAcgBA,qBAAAA;;;eAAAA;;;;gCAZe;AAYxB,SAASA,kBAAkB,KAWjC;IAXiC,IAAA,EAChCC,SAAS,EACTC,KAAK,EACLC,MAAM,EACN,AACAC,OAAO,EAMR,GAXiC,iDAI6B;IAQ7D,IAAI,OAAOC,WAAW,aAAa;QACjC,MAAM,EAAEC,gBAAgB,EAAE,GACxBC,QAAQ;QAEV,IAAIC;QACJ,yEAAyE;QACzE,wEAAwE;QACxE,MAAMC,QAAQH,iBAAiBI,QAAQ;QACvC,IAAI,CAACD,OAAO;YACV,MAAM,OAAA,cAEL,CAFK,IAAIE,gBAAAA,cAAc,CACtB,uGADI,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QACF;QAEA,MAAM,EAAEC,sBAAsB,EAAE,GAC9BL,QAAQ;QACVC,eAAeI,uBAAuBT,QAAQM;QAE9C,OAAA,WAAA,GAAO,CAAA,GAAA,YAAA,GAAA,EAACR,WAAAA;YAAW,GAAGC,KAAK;YAAEC,QAAQK;;IACvC,OAAO;QACL,MAAM,EAAEK,4BAA4B,EAAE,GACpCN,QAAQ;QACV,MAAMC,eAAeK,6BAA6BV;QAClD,OAAA,WAAA,GAAO,CAAA,GAAA,YAAA,GAAA,EAACF,WAAAA;YAAW,GAAGC,KAAK;YAAEC,QAAQK;;IACvC;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 14779, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/next/src/client/components/metadata/browser-resolved-metadata.tsx"],"sourcesContent":["import { use } from 'react'\nimport type { StreamingMetadataResolvedState } from './types'\n\nexport function BrowserResolvedMetadata({\n  promise,\n}: {\n  promise: Promise<StreamingMetadataResolvedState>\n}) {\n  const { metadata, error } = use(promise)\n  // If there's metadata error on client, discard the browser metadata\n  // and let metadata outlet deal with the error. This will avoid the duplication metadata.\n  if (error) return null\n  return metadata\n}\n"],"names":["BrowserResolvedMetadata","promise","metadata","error","use"],"mappings":";;;;+BAGgBA,2BAAAA;;;eAAAA;;;uBAHI;AAGb,SAASA,wBAAwB,KAIvC;IAJuC,IAAA,EACtCC,OAAO,EAGR,GAJuC;IAKtC,MAAM,EAAEC,QAAQ,EAAEC,KAAK,EAAE,GAAGC,CAAAA,GAAAA,OAAAA,GAAG,EAACH;IAChC,oEAAoE;IACpE,yFAAyF;IACzF,IAAIE,OAAO,OAAO;IAClB,OAAOD;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 14810, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/next/src/shared/lib/server-inserted-metadata.shared-runtime.ts"],"sourcesContent":["'use client'\n\nimport type React from 'react'\nimport { createContext } from 'react'\n\nexport type MetadataResolver = () => React.ReactNode\ntype MetadataResolverSetter = (m: MetadataResolver) => void\n\nexport const ServerInsertedMetadataContext =\n  createContext<MetadataResolverSetter | null>(null)\n"],"names":["ServerInsertedMetadataContext","createContext"],"mappings":"AAAA;;;;;+BAQaA,iCAAAA;;;eAAAA;;;uBALiB;AAKvB,MAAMA,gCACXC,CAAAA,GAAAA,OAAAA,aAAa,EAAgC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 14828, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/next/src/client/components/metadata/server-inserted-metadata.tsx"],"sourcesContent":["import { use, useContext } from 'react'\nimport {\n  type MetadataResolver,\n  ServerInsertedMetadataContext,\n} from '../../../shared/lib/server-inserted-metadata.shared-runtime'\nimport type { StreamingMetadataResolvedState } from './types'\n\n// Receives a metadata resolver setter from the context, and will pass the metadata resolving promise to\n// the context where we gonna use it to resolve the metadata, and render as string to append in <body>.\nconst useServerInsertedMetadata = (metadataResolver: MetadataResolver) => {\n  const setMetadataResolver = useContext(ServerInsertedMetadataContext)\n\n  if (setMetadataResolver) {\n    setMetadataResolver(metadataResolver)\n  }\n}\n\nexport function ServerInsertMetadata({\n  promise,\n}: {\n  promise: Promise<StreamingMetadataResolvedState>\n}) {\n  // Apply use() to the metadata promise to suspend the rendering in SSR.\n  const { metadata } = use(promise)\n  // Insert metadata into the HTML stream through the `useServerInsertedMetadata`\n  useServerInsertedMetadata(() => metadata)\n\n  return null\n}\n"],"names":["ServerInsertMetadata","useServerInsertedMetadata","metadataResolver","setMetadataResolver","useContext","ServerInsertedMetadataContext","promise","metadata","use"],"mappings":";;;;+BAiBgBA,wBAAAA;;;eAAAA;;;uBAjBgB;qDAIzB;AAGP,wGAAwG;AACxG,uGAAuG;AACvG,MAAMC,4BAA4B,CAACC;IACjC,MAAMC,sBAAsBC,CAAAA,GAAAA,OAAAA,UAAU,EAACC,qCAAAA,6BAA6B;IAEpE,IAAIF,qBAAqB;QACvBA,oBAAoBD;IACtB;AACF;AAEO,SAASF,qBAAqB,KAIpC;IAJoC,IAAA,EACnCM,OAAO,EAGR,GAJoC;IAKnC,uEAAuE;IACvE,MAAM,EAAEC,QAAQ,EAAE,GAAGC,CAAAA,GAAAA,OAAAA,GAAG,EAACF;IACzB,+EAA+E;IAC/EL;0DAA0B,IAAMM;;IAEhC,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 14870, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/next/src/client/components/metadata/async-metadata.tsx"],"sourcesContent":["'use client'\n\nimport { Suspense, use } from 'react'\nimport type { StreamingMetadataResolvedState } from './types'\n\nexport const AsyncMetadata =\n  typeof window === 'undefined'\n    ? (\n        require('./server-inserted-metadata') as typeof import('./server-inserted-metadata')\n      ).ServerInsertMetadata\n    : (\n        require('./browser-resolved-metadata') as typeof import('./browser-resolved-metadata')\n      ).BrowserResolvedMetadata\n\nfunction MetadataOutlet({\n  promise,\n}: {\n  promise: Promise<StreamingMetadataResolvedState>\n}) {\n  const { error, digest } = use(promise)\n  if (error) {\n    if (digest) {\n      // The error will lose its original digest after passing from server layer to client layer；\n      // We recover the digest property here to override the React created one if original digest exists.\n      ;(error as any).digest = digest\n    }\n    throw error\n  }\n  return null\n}\n\nexport function AsyncMetadataOutlet({\n  promise,\n}: {\n  promise: Promise<StreamingMetadataResolvedState>\n}) {\n  return (\n    <Suspense fallback={null}>\n      <MetadataOutlet promise={promise} />\n    </Suspense>\n  )\n}\n"],"names":["AsyncMetadata","AsyncMetadataOutlet","window","require","ServerInsertMetadata","BrowserResolvedMetadata","MetadataOutlet","promise","error","digest","use","Suspense","fallback"],"mappings":"AAAA;;;;;;;;;;;;;;;;IAKaA,aAAa,EAAA;eAAbA;;IA0BGC,mBAAmB,EAAA;eAAnBA;;;;uBA7Bc;AAGvB,MAAMD,gBACX,OAAOE,WAAW,cAEZC,QAAQ,qIACRC,oBAAoB,GAEpBD,QAAQ,sIACRE,uBAAuB;AAE/B,SAASC,eAAe,KAIvB;IAJuB,IAAA,EACtBC,OAAO,EAGR,GAJuB;IAKtB,MAAM,EAAEC,KAAK,EAAEC,MAAM,EAAE,GAAGC,CAAAA,GAAAA,OAAAA,GAAG,EAACH;IAC9B,IAAIC,OAAO;QACT,IAAIC,QAAQ;YACV,2FAA2F;YAC3F,mGAAmG;;YACjGD,MAAcC,MAAM,GAAGA;QAC3B;QACA,MAAMD;IACR;IACA,OAAO;AACT;AAEO,SAASP,oBAAoB,KAInC;IAJmC,IAAA,EAClCM,OAAO,EAGR,GAJmC;IAKlC,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,GAAA,EAACI,OAAAA,QAAQ,EAAA;QAACC,UAAU;kBAClB,WAAA,GAAA,CAAA,GAAA,YAAA,GAAA,EAACN,gBAAAA;YAAeC,SAASA;;;AAG/B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 14931, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruslan/Work/EH/yeezyhauk/node_modules/next/src/client/components/metadata/metadata-boundary.tsx"],"sourcesContent":["'use client'\n\nimport {\n  METADATA_BOUNDARY_NAME,\n  VIEWPORT_BOUNDARY_NAME,\n  OUTLET_BOUNDARY_NAME,\n} from '../../../lib/metadata/metadata-constants'\n\n// We use a namespace object to allow us to recover the name of the function\n// at runtime even when production bundling/minification is used.\nconst NameSpace = {\n  [METADATA_BOUNDARY_NAME]: function ({\n    children,\n  }: {\n    children: React.ReactNode\n  }) {\n    return children\n  },\n  [VIEWPORT_BOUNDARY_NAME]: function ({\n    children,\n  }: {\n    children: React.ReactNode\n  }) {\n    return children\n  },\n  [OUTLET_BOUNDARY_NAME]: function ({\n    children,\n  }: {\n    children: React.ReactNode\n  }) {\n    return children\n  },\n}\n\nexport const MetadataBoundary =\n  // We use slice(0) to trick the bundler into not inlining/minifying the function\n  // so it retains the name inferred from the namespace object\n  NameSpace[METADATA_BOUNDARY_NAME.slice(0) as typeof METADATA_BOUNDARY_NAME]\n\nexport const ViewportBoundary =\n  // We use slice(0) to trick the bundler into not inlining/minifying the function\n  // so it retains the name inferred from the namespace object\n  NameSpace[VIEWPORT_BOUNDARY_NAME.slice(0) as typeof VIEWPORT_BOUNDARY_NAME]\n\nexport const OutletBoundary =\n  // We use slice(0) to trick the bundler into not inlining/minifying the function\n  // so it retains the name inferred from the namespace object\n  NameSpace[OUTLET_BOUNDARY_NAME.slice(0) as typeof OUTLET_BOUNDARY_NAME]\n"],"names":["MetadataBoundary","OutletBoundary","ViewportBoundary","NameSpace","METADATA_BOUNDARY_NAME","children","VIEWPORT_BOUNDARY_NAME","OUTLET_BOUNDARY_NAME","slice"],"mappings":"AAAA;;;;;;;;;;;;;;;;;IAkCaA,gBAAgB,EAAA;eAAhBA;;IAUAC,cAAc,EAAA;eAAdA;;IALAC,gBAAgB,EAAA;eAAhBA;;;mCAjCN;AAEP,4EAA4E;AAC5E,iEAAiE;AACjE,MAAMC,YAAY;IAChB,CAACC,mBAAAA,sBAAsB,CAAC,EAAE,SAAU,KAInC;QAJmC,IAAA,EAClCC,QAAQ,EAGT,GAJmC;QAKlC,OAAOA;IACT;IACA,CAACC,mBAAAA,sBAAsB,CAAC,EAAE,SAAU,KAInC;QAJmC,IAAA,EAClCD,QAAQ,EAGT,GAJmC;QAKlC,OAAOA;IACT;IACA,CAACE,mBAAAA,oBAAoB,CAAC,EAAE,SAAU,KAIjC;QAJiC,IAAA,EAChCF,QAAQ,EAGT,GAJiC;QAKhC,OAAOA;IACT;AACF;AAEO,MAAML,mBACX,AACA,4DAA4D,oBADoB;AAEhFG,SAAS,CAACC,mBAAAA,sBAAsB,CAACI,KAAK,CAAC,GAAoC;AAEtE,MAAMN,mBACX,AACA,4DAA4D,oBADoB;AAEhFC,SAAS,CAACG,mBAAAA,sBAAsB,CAACE,KAAK,CAAC,GAAoC;AAEtE,MAAMP,iBACX,AACA,4DAA4D,oBADoB;AAEhFE,SAAS,CAACI,mBAAAA,oBAAoB,CAACC,KAAK,CAAC,GAAkC","ignoreList":[0],"debugId":null}}]
}